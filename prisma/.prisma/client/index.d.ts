
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Resume
 * 
 */
export type Resume = $Result.DefaultSelection<Prisma.$ResumePayload>
/**
 * Model ResumeEvent
 * 
 */
export type ResumeEvent = $Result.DefaultSelection<Prisma.$ResumeEventPayload>
/**
 * Model AnalyticsEvent
 * 
 */
export type AnalyticsEvent = $Result.DefaultSelection<Prisma.$AnalyticsEventPayload>
/**
 * Model TailoringAnalytics
 * 
 */
export type TailoringAnalytics = $Result.DefaultSelection<Prisma.$TailoringAnalyticsPayload>
/**
 * Model ScrubbedResume
 * 
 */
export type ScrubbedResume = $Result.DefaultSelection<Prisma.$ScrubbedResumePayload>
/**
 * Model PromptArchive
 * 
 */
export type PromptArchive = $Result.DefaultSelection<Prisma.$PromptArchivePayload>
/**
 * Model ResumeInteraction
 * 
 */
export type ResumeInteraction = $Result.DefaultSelection<Prisma.$ResumeInteractionPayload>
/**
 * Model ResumeTag
 * 
 */
export type ResumeTag = $Result.DefaultSelection<Prisma.$ResumeTagPayload>
/**
 * Model ResumeMetadata
 * 
 */
export type ResumeMetadata = $Result.DefaultSelection<Prisma.$ResumeMetadataPayload>
/**
 * Model TailoringPrompt
 * 
 */
export type TailoringPrompt = $Result.DefaultSelection<Prisma.$TailoringPromptPayload>
/**
 * Model TailoringProgress
 * 
 */
export type TailoringProgress = $Result.DefaultSelection<Prisma.$TailoringProgressPayload>
/**
 * Model TailoringAttempt
 * 
 */
export type TailoringAttempt = $Result.DefaultSelection<Prisma.$TailoringAttemptPayload>
/**
 * Model ResumeFeedback
 * 
 */
export type ResumeFeedback = $Result.DefaultSelection<Prisma.$ResumeFeedbackPayload>
/**
 * Model ManualEdit
 * 
 */
export type ManualEdit = $Result.DefaultSelection<Prisma.$ManualEditPayload>
/**
 * Model ManualScoring
 * 
 */
export type ManualScoring = $Result.DefaultSelection<Prisma.$ManualScoringPayload>
/**
 * Model CoverLetter
 * 
 */
export type CoverLetter = $Result.DefaultSelection<Prisma.$CoverLetterPayload>
/**
 * Model LinkedInOptimization
 * 
 */
export type LinkedInOptimization = $Result.DefaultSelection<Prisma.$LinkedInOptimizationPayload>
/**
 * Model InterviewSession
 * 
 */
export type InterviewSession = $Result.DefaultSelection<Prisma.$InterviewSessionPayload>
/**
 * Model ResumeExport
 * 
 */
export type ResumeExport = $Result.DefaultSelection<Prisma.$ResumeExportPayload>
/**
 * Model JobDescriptionIntelligence
 * 
 */
export type JobDescriptionIntelligence = $Result.DefaultSelection<Prisma.$JobDescriptionIntelligencePayload>
/**
 * Model ResumeSectionRationale
 * 
 */
export type ResumeSectionRationale = $Result.DefaultSelection<Prisma.$ResumeSectionRationalePayload>
/**
 * Model ContactSubmission
 * 
 */
export type ContactSubmission = $Result.DefaultSelection<Prisma.$ContactSubmissionPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resume`: Exposes CRUD operations for the **Resume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resumes
    * const resumes = await prisma.resume.findMany()
    * ```
    */
  get resume(): Prisma.ResumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumeEvent`: Exposes CRUD operations for the **ResumeEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeEvents
    * const resumeEvents = await prisma.resumeEvent.findMany()
    * ```
    */
  get resumeEvent(): Prisma.ResumeEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tailoringAnalytics`: Exposes CRUD operations for the **TailoringAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TailoringAnalytics
    * const tailoringAnalytics = await prisma.tailoringAnalytics.findMany()
    * ```
    */
  get tailoringAnalytics(): Prisma.TailoringAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scrubbedResume`: Exposes CRUD operations for the **ScrubbedResume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScrubbedResumes
    * const scrubbedResumes = await prisma.scrubbedResume.findMany()
    * ```
    */
  get scrubbedResume(): Prisma.ScrubbedResumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promptArchive`: Exposes CRUD operations for the **PromptArchive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromptArchives
    * const promptArchives = await prisma.promptArchive.findMany()
    * ```
    */
  get promptArchive(): Prisma.PromptArchiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumeInteraction`: Exposes CRUD operations for the **ResumeInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeInteractions
    * const resumeInteractions = await prisma.resumeInteraction.findMany()
    * ```
    */
  get resumeInteraction(): Prisma.ResumeInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumeTag`: Exposes CRUD operations for the **ResumeTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeTags
    * const resumeTags = await prisma.resumeTag.findMany()
    * ```
    */
  get resumeTag(): Prisma.ResumeTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumeMetadata`: Exposes CRUD operations for the **ResumeMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeMetadata
    * const resumeMetadata = await prisma.resumeMetadata.findMany()
    * ```
    */
  get resumeMetadata(): Prisma.ResumeMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tailoringPrompt`: Exposes CRUD operations for the **TailoringPrompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TailoringPrompts
    * const tailoringPrompts = await prisma.tailoringPrompt.findMany()
    * ```
    */
  get tailoringPrompt(): Prisma.TailoringPromptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tailoringProgress`: Exposes CRUD operations for the **TailoringProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TailoringProgresses
    * const tailoringProgresses = await prisma.tailoringProgress.findMany()
    * ```
    */
  get tailoringProgress(): Prisma.TailoringProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tailoringAttempt`: Exposes CRUD operations for the **TailoringAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TailoringAttempts
    * const tailoringAttempts = await prisma.tailoringAttempt.findMany()
    * ```
    */
  get tailoringAttempt(): Prisma.TailoringAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumeFeedback`: Exposes CRUD operations for the **ResumeFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeFeedbacks
    * const resumeFeedbacks = await prisma.resumeFeedback.findMany()
    * ```
    */
  get resumeFeedback(): Prisma.ResumeFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manualEdit`: Exposes CRUD operations for the **ManualEdit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManualEdits
    * const manualEdits = await prisma.manualEdit.findMany()
    * ```
    */
  get manualEdit(): Prisma.ManualEditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manualScoring`: Exposes CRUD operations for the **ManualScoring** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManualScorings
    * const manualScorings = await prisma.manualScoring.findMany()
    * ```
    */
  get manualScoring(): Prisma.ManualScoringDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coverLetter`: Exposes CRUD operations for the **CoverLetter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoverLetters
    * const coverLetters = await prisma.coverLetter.findMany()
    * ```
    */
  get coverLetter(): Prisma.CoverLetterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.linkedInOptimization`: Exposes CRUD operations for the **LinkedInOptimization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkedInOptimizations
    * const linkedInOptimizations = await prisma.linkedInOptimization.findMany()
    * ```
    */
  get linkedInOptimization(): Prisma.LinkedInOptimizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interviewSession`: Exposes CRUD operations for the **InterviewSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewSessions
    * const interviewSessions = await prisma.interviewSession.findMany()
    * ```
    */
  get interviewSession(): Prisma.InterviewSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumeExport`: Exposes CRUD operations for the **ResumeExport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeExports
    * const resumeExports = await prisma.resumeExport.findMany()
    * ```
    */
  get resumeExport(): Prisma.ResumeExportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobDescriptionIntelligence`: Exposes CRUD operations for the **JobDescriptionIntelligence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobDescriptionIntelligences
    * const jobDescriptionIntelligences = await prisma.jobDescriptionIntelligence.findMany()
    * ```
    */
  get jobDescriptionIntelligence(): Prisma.JobDescriptionIntelligenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumeSectionRationale`: Exposes CRUD operations for the **ResumeSectionRationale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeSectionRationales
    * const resumeSectionRationales = await prisma.resumeSectionRationale.findMany()
    * ```
    */
  get resumeSectionRationale(): Prisma.ResumeSectionRationaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactSubmission`: Exposes CRUD operations for the **ContactSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactSubmissions
    * const contactSubmissions = await prisma.contactSubmission.findMany()
    * ```
    */
  get contactSubmission(): Prisma.ContactSubmissionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Resume: 'Resume',
    ResumeEvent: 'ResumeEvent',
    AnalyticsEvent: 'AnalyticsEvent',
    TailoringAnalytics: 'TailoringAnalytics',
    ScrubbedResume: 'ScrubbedResume',
    PromptArchive: 'PromptArchive',
    ResumeInteraction: 'ResumeInteraction',
    ResumeTag: 'ResumeTag',
    ResumeMetadata: 'ResumeMetadata',
    TailoringPrompt: 'TailoringPrompt',
    TailoringProgress: 'TailoringProgress',
    TailoringAttempt: 'TailoringAttempt',
    ResumeFeedback: 'ResumeFeedback',
    ManualEdit: 'ManualEdit',
    ManualScoring: 'ManualScoring',
    CoverLetter: 'CoverLetter',
    LinkedInOptimization: 'LinkedInOptimization',
    InterviewSession: 'InterviewSession',
    ResumeExport: 'ResumeExport',
    JobDescriptionIntelligence: 'JobDescriptionIntelligence',
    ResumeSectionRationale: 'ResumeSectionRationale',
    ContactSubmission: 'ContactSubmission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "resume" | "resumeEvent" | "analyticsEvent" | "tailoringAnalytics" | "scrubbedResume" | "promptArchive" | "resumeInteraction" | "resumeTag" | "resumeMetadata" | "tailoringPrompt" | "tailoringProgress" | "tailoringAttempt" | "resumeFeedback" | "manualEdit" | "manualScoring" | "coverLetter" | "linkedInOptimization" | "interviewSession" | "resumeExport" | "jobDescriptionIntelligence" | "resumeSectionRationale" | "contactSubmission"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Resume: {
        payload: Prisma.$ResumePayload<ExtArgs>
        fields: Prisma.ResumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          findFirst: {
            args: Prisma.ResumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          findMany: {
            args: Prisma.ResumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          create: {
            args: Prisma.ResumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          createMany: {
            args: Prisma.ResumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          delete: {
            args: Prisma.ResumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          update: {
            args: Prisma.ResumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          deleteMany: {
            args: Prisma.ResumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          upsert: {
            args: Prisma.ResumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          aggregate: {
            args: Prisma.ResumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResume>
          }
          groupBy: {
            args: Prisma.ResumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeCountAggregateOutputType> | number
          }
        }
      }
      ResumeEvent: {
        payload: Prisma.$ResumeEventPayload<ExtArgs>
        fields: Prisma.ResumeEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>
          }
          findFirst: {
            args: Prisma.ResumeEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>
          }
          findMany: {
            args: Prisma.ResumeEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>[]
          }
          create: {
            args: Prisma.ResumeEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>
          }
          createMany: {
            args: Prisma.ResumeEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>[]
          }
          delete: {
            args: Prisma.ResumeEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>
          }
          update: {
            args: Prisma.ResumeEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>
          }
          deleteMany: {
            args: Prisma.ResumeEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>[]
          }
          upsert: {
            args: Prisma.ResumeEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeEventPayload>
          }
          aggregate: {
            args: Prisma.ResumeEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumeEvent>
          }
          groupBy: {
            args: Prisma.ResumeEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeEventCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeEventCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: Prisma.$AnalyticsEventPayload<ExtArgs>
        fields: Prisma.AnalyticsEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      TailoringAnalytics: {
        payload: Prisma.$TailoringAnalyticsPayload<ExtArgs>
        fields: Prisma.TailoringAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TailoringAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TailoringAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.TailoringAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TailoringAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>
          }
          findMany: {
            args: Prisma.TailoringAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>[]
          }
          create: {
            args: Prisma.TailoringAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>
          }
          createMany: {
            args: Prisma.TailoringAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TailoringAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.TailoringAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>
          }
          update: {
            args: Prisma.TailoringAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.TailoringAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TailoringAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TailoringAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.TailoringAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.TailoringAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTailoringAnalytics>
          }
          groupBy: {
            args: Prisma.TailoringAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TailoringAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TailoringAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<TailoringAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      ScrubbedResume: {
        payload: Prisma.$ScrubbedResumePayload<ExtArgs>
        fields: Prisma.ScrubbedResumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScrubbedResumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScrubbedResumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>
          }
          findFirst: {
            args: Prisma.ScrubbedResumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScrubbedResumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>
          }
          findMany: {
            args: Prisma.ScrubbedResumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>[]
          }
          create: {
            args: Prisma.ScrubbedResumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>
          }
          createMany: {
            args: Prisma.ScrubbedResumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScrubbedResumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>[]
          }
          delete: {
            args: Prisma.ScrubbedResumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>
          }
          update: {
            args: Prisma.ScrubbedResumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>
          }
          deleteMany: {
            args: Prisma.ScrubbedResumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScrubbedResumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScrubbedResumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>[]
          }
          upsert: {
            args: Prisma.ScrubbedResumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScrubbedResumePayload>
          }
          aggregate: {
            args: Prisma.ScrubbedResumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScrubbedResume>
          }
          groupBy: {
            args: Prisma.ScrubbedResumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScrubbedResumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScrubbedResumeCountArgs<ExtArgs>
            result: $Utils.Optional<ScrubbedResumeCountAggregateOutputType> | number
          }
        }
      }
      PromptArchive: {
        payload: Prisma.$PromptArchivePayload<ExtArgs>
        fields: Prisma.PromptArchiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptArchiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptArchiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>
          }
          findFirst: {
            args: Prisma.PromptArchiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptArchiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>
          }
          findMany: {
            args: Prisma.PromptArchiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>[]
          }
          create: {
            args: Prisma.PromptArchiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>
          }
          createMany: {
            args: Prisma.PromptArchiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromptArchiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>[]
          }
          delete: {
            args: Prisma.PromptArchiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>
          }
          update: {
            args: Prisma.PromptArchiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>
          }
          deleteMany: {
            args: Prisma.PromptArchiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptArchiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromptArchiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>[]
          }
          upsert: {
            args: Prisma.PromptArchiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptArchivePayload>
          }
          aggregate: {
            args: Prisma.PromptArchiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromptArchive>
          }
          groupBy: {
            args: Prisma.PromptArchiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptArchiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptArchiveCountArgs<ExtArgs>
            result: $Utils.Optional<PromptArchiveCountAggregateOutputType> | number
          }
        }
      }
      ResumeInteraction: {
        payload: Prisma.$ResumeInteractionPayload<ExtArgs>
        fields: Prisma.ResumeInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>
          }
          findFirst: {
            args: Prisma.ResumeInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>
          }
          findMany: {
            args: Prisma.ResumeInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>[]
          }
          create: {
            args: Prisma.ResumeInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>
          }
          createMany: {
            args: Prisma.ResumeInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>[]
          }
          delete: {
            args: Prisma.ResumeInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>
          }
          update: {
            args: Prisma.ResumeInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>
          }
          deleteMany: {
            args: Prisma.ResumeInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>[]
          }
          upsert: {
            args: Prisma.ResumeInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeInteractionPayload>
          }
          aggregate: {
            args: Prisma.ResumeInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumeInteraction>
          }
          groupBy: {
            args: Prisma.ResumeInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeInteractionCountAggregateOutputType> | number
          }
        }
      }
      ResumeTag: {
        payload: Prisma.$ResumeTagPayload<ExtArgs>
        fields: Prisma.ResumeTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>
          }
          findFirst: {
            args: Prisma.ResumeTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>
          }
          findMany: {
            args: Prisma.ResumeTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>[]
          }
          create: {
            args: Prisma.ResumeTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>
          }
          createMany: {
            args: Prisma.ResumeTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>[]
          }
          delete: {
            args: Prisma.ResumeTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>
          }
          update: {
            args: Prisma.ResumeTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>
          }
          deleteMany: {
            args: Prisma.ResumeTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>[]
          }
          upsert: {
            args: Prisma.ResumeTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeTagPayload>
          }
          aggregate: {
            args: Prisma.ResumeTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumeTag>
          }
          groupBy: {
            args: Prisma.ResumeTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeTagCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeTagCountAggregateOutputType> | number
          }
        }
      }
      ResumeMetadata: {
        payload: Prisma.$ResumeMetadataPayload<ExtArgs>
        fields: Prisma.ResumeMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>
          }
          findFirst: {
            args: Prisma.ResumeMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>
          }
          findMany: {
            args: Prisma.ResumeMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>[]
          }
          create: {
            args: Prisma.ResumeMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>
          }
          createMany: {
            args: Prisma.ResumeMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>[]
          }
          delete: {
            args: Prisma.ResumeMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>
          }
          update: {
            args: Prisma.ResumeMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>
          }
          deleteMany: {
            args: Prisma.ResumeMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>[]
          }
          upsert: {
            args: Prisma.ResumeMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeMetadataPayload>
          }
          aggregate: {
            args: Prisma.ResumeMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumeMetadata>
          }
          groupBy: {
            args: Prisma.ResumeMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeMetadataCountAggregateOutputType> | number
          }
        }
      }
      TailoringPrompt: {
        payload: Prisma.$TailoringPromptPayload<ExtArgs>
        fields: Prisma.TailoringPromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TailoringPromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TailoringPromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>
          }
          findFirst: {
            args: Prisma.TailoringPromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TailoringPromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>
          }
          findMany: {
            args: Prisma.TailoringPromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>[]
          }
          create: {
            args: Prisma.TailoringPromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>
          }
          createMany: {
            args: Prisma.TailoringPromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TailoringPromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>[]
          }
          delete: {
            args: Prisma.TailoringPromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>
          }
          update: {
            args: Prisma.TailoringPromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>
          }
          deleteMany: {
            args: Prisma.TailoringPromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TailoringPromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TailoringPromptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>[]
          }
          upsert: {
            args: Prisma.TailoringPromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringPromptPayload>
          }
          aggregate: {
            args: Prisma.TailoringPromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTailoringPrompt>
          }
          groupBy: {
            args: Prisma.TailoringPromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TailoringPromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TailoringPromptCountArgs<ExtArgs>
            result: $Utils.Optional<TailoringPromptCountAggregateOutputType> | number
          }
        }
      }
      TailoringProgress: {
        payload: Prisma.$TailoringProgressPayload<ExtArgs>
        fields: Prisma.TailoringProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TailoringProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TailoringProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>
          }
          findFirst: {
            args: Prisma.TailoringProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TailoringProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>
          }
          findMany: {
            args: Prisma.TailoringProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>[]
          }
          create: {
            args: Prisma.TailoringProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>
          }
          createMany: {
            args: Prisma.TailoringProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TailoringProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>[]
          }
          delete: {
            args: Prisma.TailoringProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>
          }
          update: {
            args: Prisma.TailoringProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>
          }
          deleteMany: {
            args: Prisma.TailoringProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TailoringProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TailoringProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>[]
          }
          upsert: {
            args: Prisma.TailoringProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringProgressPayload>
          }
          aggregate: {
            args: Prisma.TailoringProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTailoringProgress>
          }
          groupBy: {
            args: Prisma.TailoringProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<TailoringProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.TailoringProgressCountArgs<ExtArgs>
            result: $Utils.Optional<TailoringProgressCountAggregateOutputType> | number
          }
        }
      }
      TailoringAttempt: {
        payload: Prisma.$TailoringAttemptPayload<ExtArgs>
        fields: Prisma.TailoringAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TailoringAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TailoringAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>
          }
          findFirst: {
            args: Prisma.TailoringAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TailoringAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>
          }
          findMany: {
            args: Prisma.TailoringAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>[]
          }
          create: {
            args: Prisma.TailoringAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>
          }
          createMany: {
            args: Prisma.TailoringAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TailoringAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>[]
          }
          delete: {
            args: Prisma.TailoringAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>
          }
          update: {
            args: Prisma.TailoringAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>
          }
          deleteMany: {
            args: Prisma.TailoringAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TailoringAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TailoringAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>[]
          }
          upsert: {
            args: Prisma.TailoringAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailoringAttemptPayload>
          }
          aggregate: {
            args: Prisma.TailoringAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTailoringAttempt>
          }
          groupBy: {
            args: Prisma.TailoringAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TailoringAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TailoringAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<TailoringAttemptCountAggregateOutputType> | number
          }
        }
      }
      ResumeFeedback: {
        payload: Prisma.$ResumeFeedbackPayload<ExtArgs>
        fields: Prisma.ResumeFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>
          }
          findFirst: {
            args: Prisma.ResumeFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>
          }
          findMany: {
            args: Prisma.ResumeFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>[]
          }
          create: {
            args: Prisma.ResumeFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>
          }
          createMany: {
            args: Prisma.ResumeFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>[]
          }
          delete: {
            args: Prisma.ResumeFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>
          }
          update: {
            args: Prisma.ResumeFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.ResumeFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.ResumeFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeFeedbackPayload>
          }
          aggregate: {
            args: Prisma.ResumeFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumeFeedback>
          }
          groupBy: {
            args: Prisma.ResumeFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeFeedbackCountAggregateOutputType> | number
          }
        }
      }
      ManualEdit: {
        payload: Prisma.$ManualEditPayload<ExtArgs>
        fields: Prisma.ManualEditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManualEditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManualEditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>
          }
          findFirst: {
            args: Prisma.ManualEditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManualEditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>
          }
          findMany: {
            args: Prisma.ManualEditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>[]
          }
          create: {
            args: Prisma.ManualEditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>
          }
          createMany: {
            args: Prisma.ManualEditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManualEditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>[]
          }
          delete: {
            args: Prisma.ManualEditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>
          }
          update: {
            args: Prisma.ManualEditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>
          }
          deleteMany: {
            args: Prisma.ManualEditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManualEditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManualEditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>[]
          }
          upsert: {
            args: Prisma.ManualEditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualEditPayload>
          }
          aggregate: {
            args: Prisma.ManualEditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManualEdit>
          }
          groupBy: {
            args: Prisma.ManualEditGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManualEditGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManualEditCountArgs<ExtArgs>
            result: $Utils.Optional<ManualEditCountAggregateOutputType> | number
          }
        }
      }
      ManualScoring: {
        payload: Prisma.$ManualScoringPayload<ExtArgs>
        fields: Prisma.ManualScoringFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManualScoringFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManualScoringFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>
          }
          findFirst: {
            args: Prisma.ManualScoringFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManualScoringFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>
          }
          findMany: {
            args: Prisma.ManualScoringFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>[]
          }
          create: {
            args: Prisma.ManualScoringCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>
          }
          createMany: {
            args: Prisma.ManualScoringCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManualScoringCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>[]
          }
          delete: {
            args: Prisma.ManualScoringDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>
          }
          update: {
            args: Prisma.ManualScoringUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>
          }
          deleteMany: {
            args: Prisma.ManualScoringDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManualScoringUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManualScoringUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>[]
          }
          upsert: {
            args: Prisma.ManualScoringUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualScoringPayload>
          }
          aggregate: {
            args: Prisma.ManualScoringAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManualScoring>
          }
          groupBy: {
            args: Prisma.ManualScoringGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManualScoringGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManualScoringCountArgs<ExtArgs>
            result: $Utils.Optional<ManualScoringCountAggregateOutputType> | number
          }
        }
      }
      CoverLetter: {
        payload: Prisma.$CoverLetterPayload<ExtArgs>
        fields: Prisma.CoverLetterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoverLetterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoverLetterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>
          }
          findFirst: {
            args: Prisma.CoverLetterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoverLetterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>
          }
          findMany: {
            args: Prisma.CoverLetterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>[]
          }
          create: {
            args: Prisma.CoverLetterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>
          }
          createMany: {
            args: Prisma.CoverLetterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoverLetterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>[]
          }
          delete: {
            args: Prisma.CoverLetterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>
          }
          update: {
            args: Prisma.CoverLetterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>
          }
          deleteMany: {
            args: Prisma.CoverLetterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoverLetterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoverLetterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>[]
          }
          upsert: {
            args: Prisma.CoverLetterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoverLetterPayload>
          }
          aggregate: {
            args: Prisma.CoverLetterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoverLetter>
          }
          groupBy: {
            args: Prisma.CoverLetterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoverLetterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoverLetterCountArgs<ExtArgs>
            result: $Utils.Optional<CoverLetterCountAggregateOutputType> | number
          }
        }
      }
      LinkedInOptimization: {
        payload: Prisma.$LinkedInOptimizationPayload<ExtArgs>
        fields: Prisma.LinkedInOptimizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkedInOptimizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkedInOptimizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>
          }
          findFirst: {
            args: Prisma.LinkedInOptimizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkedInOptimizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>
          }
          findMany: {
            args: Prisma.LinkedInOptimizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>[]
          }
          create: {
            args: Prisma.LinkedInOptimizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>
          }
          createMany: {
            args: Prisma.LinkedInOptimizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkedInOptimizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>[]
          }
          delete: {
            args: Prisma.LinkedInOptimizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>
          }
          update: {
            args: Prisma.LinkedInOptimizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>
          }
          deleteMany: {
            args: Prisma.LinkedInOptimizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkedInOptimizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LinkedInOptimizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>[]
          }
          upsert: {
            args: Prisma.LinkedInOptimizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedInOptimizationPayload>
          }
          aggregate: {
            args: Prisma.LinkedInOptimizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkedInOptimization>
          }
          groupBy: {
            args: Prisma.LinkedInOptimizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkedInOptimizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkedInOptimizationCountArgs<ExtArgs>
            result: $Utils.Optional<LinkedInOptimizationCountAggregateOutputType> | number
          }
        }
      }
      InterviewSession: {
        payload: Prisma.$InterviewSessionPayload<ExtArgs>
        fields: Prisma.InterviewSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          findFirst: {
            args: Prisma.InterviewSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          findMany: {
            args: Prisma.InterviewSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>[]
          }
          create: {
            args: Prisma.InterviewSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          createMany: {
            args: Prisma.InterviewSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>[]
          }
          delete: {
            args: Prisma.InterviewSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          update: {
            args: Prisma.InterviewSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          deleteMany: {
            args: Prisma.InterviewSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterviewSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>[]
          }
          upsert: {
            args: Prisma.InterviewSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          aggregate: {
            args: Prisma.InterviewSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewSession>
          }
          groupBy: {
            args: Prisma.InterviewSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewSessionCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewSessionCountAggregateOutputType> | number
          }
        }
      }
      ResumeExport: {
        payload: Prisma.$ResumeExportPayload<ExtArgs>
        fields: Prisma.ResumeExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeExportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeExportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>
          }
          findFirst: {
            args: Prisma.ResumeExportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeExportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>
          }
          findMany: {
            args: Prisma.ResumeExportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>[]
          }
          create: {
            args: Prisma.ResumeExportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>
          }
          createMany: {
            args: Prisma.ResumeExportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeExportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>[]
          }
          delete: {
            args: Prisma.ResumeExportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>
          }
          update: {
            args: Prisma.ResumeExportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>
          }
          deleteMany: {
            args: Prisma.ResumeExportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeExportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeExportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>[]
          }
          upsert: {
            args: Prisma.ResumeExportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeExportPayload>
          }
          aggregate: {
            args: Prisma.ResumeExportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumeExport>
          }
          groupBy: {
            args: Prisma.ResumeExportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeExportCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeExportCountAggregateOutputType> | number
          }
        }
      }
      JobDescriptionIntelligence: {
        payload: Prisma.$JobDescriptionIntelligencePayload<ExtArgs>
        fields: Prisma.JobDescriptionIntelligenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobDescriptionIntelligenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobDescriptionIntelligenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>
          }
          findFirst: {
            args: Prisma.JobDescriptionIntelligenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobDescriptionIntelligenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>
          }
          findMany: {
            args: Prisma.JobDescriptionIntelligenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>[]
          }
          create: {
            args: Prisma.JobDescriptionIntelligenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>
          }
          createMany: {
            args: Prisma.JobDescriptionIntelligenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobDescriptionIntelligenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>[]
          }
          delete: {
            args: Prisma.JobDescriptionIntelligenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>
          }
          update: {
            args: Prisma.JobDescriptionIntelligenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>
          }
          deleteMany: {
            args: Prisma.JobDescriptionIntelligenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobDescriptionIntelligenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobDescriptionIntelligenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>[]
          }
          upsert: {
            args: Prisma.JobDescriptionIntelligenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobDescriptionIntelligencePayload>
          }
          aggregate: {
            args: Prisma.JobDescriptionIntelligenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobDescriptionIntelligence>
          }
          groupBy: {
            args: Prisma.JobDescriptionIntelligenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobDescriptionIntelligenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobDescriptionIntelligenceCountArgs<ExtArgs>
            result: $Utils.Optional<JobDescriptionIntelligenceCountAggregateOutputType> | number
          }
        }
      }
      ResumeSectionRationale: {
        payload: Prisma.$ResumeSectionRationalePayload<ExtArgs>
        fields: Prisma.ResumeSectionRationaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeSectionRationaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeSectionRationaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>
          }
          findFirst: {
            args: Prisma.ResumeSectionRationaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeSectionRationaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>
          }
          findMany: {
            args: Prisma.ResumeSectionRationaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>[]
          }
          create: {
            args: Prisma.ResumeSectionRationaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>
          }
          createMany: {
            args: Prisma.ResumeSectionRationaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeSectionRationaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>[]
          }
          delete: {
            args: Prisma.ResumeSectionRationaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>
          }
          update: {
            args: Prisma.ResumeSectionRationaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>
          }
          deleteMany: {
            args: Prisma.ResumeSectionRationaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeSectionRationaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeSectionRationaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>[]
          }
          upsert: {
            args: Prisma.ResumeSectionRationaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeSectionRationalePayload>
          }
          aggregate: {
            args: Prisma.ResumeSectionRationaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumeSectionRationale>
          }
          groupBy: {
            args: Prisma.ResumeSectionRationaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeSectionRationaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeSectionRationaleCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeSectionRationaleCountAggregateOutputType> | number
          }
        }
      }
      ContactSubmission: {
        payload: Prisma.$ContactSubmissionPayload<ExtArgs>
        fields: Prisma.ContactSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findFirst: {
            args: Prisma.ContactSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findMany: {
            args: Prisma.ContactSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          create: {
            args: Prisma.ContactSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          createMany: {
            args: Prisma.ContactSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          delete: {
            args: Prisma.ContactSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          update: {
            args: Prisma.ContactSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.ContactSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.ContactSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          aggregate: {
            args: Prisma.ContactSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactSubmission>
          }
          groupBy: {
            args: Prisma.ContactSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    resume?: ResumeOmit
    resumeEvent?: ResumeEventOmit
    analyticsEvent?: AnalyticsEventOmit
    tailoringAnalytics?: TailoringAnalyticsOmit
    scrubbedResume?: ScrubbedResumeOmit
    promptArchive?: PromptArchiveOmit
    resumeInteraction?: ResumeInteractionOmit
    resumeTag?: ResumeTagOmit
    resumeMetadata?: ResumeMetadataOmit
    tailoringPrompt?: TailoringPromptOmit
    tailoringProgress?: TailoringProgressOmit
    tailoringAttempt?: TailoringAttemptOmit
    resumeFeedback?: ResumeFeedbackOmit
    manualEdit?: ManualEditOmit
    manualScoring?: ManualScoringOmit
    coverLetter?: CoverLetterOmit
    linkedInOptimization?: LinkedInOptimizationOmit
    interviewSession?: InterviewSessionOmit
    resumeExport?: ResumeExportOmit
    jobDescriptionIntelligence?: JobDescriptionIntelligenceOmit
    resumeSectionRationale?: ResumeSectionRationaleOmit
    contactSubmission?: ContactSubmissionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    resumes: number
    analytics: number
    interactions: number
    coverLetters: number
    linkedInOptimizations: number
    interviewSessions: number
    resumeExports: number
    jdIntelligence: number
    ResumeTag: number
    ResumeMetadata: number
    ResumeSectionRationale: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resumes?: boolean | UserCountOutputTypeCountResumesArgs
    analytics?: boolean | UserCountOutputTypeCountAnalyticsArgs
    interactions?: boolean | UserCountOutputTypeCountInteractionsArgs
    coverLetters?: boolean | UserCountOutputTypeCountCoverLettersArgs
    linkedInOptimizations?: boolean | UserCountOutputTypeCountLinkedInOptimizationsArgs
    interviewSessions?: boolean | UserCountOutputTypeCountInterviewSessionsArgs
    resumeExports?: boolean | UserCountOutputTypeCountResumeExportsArgs
    jdIntelligence?: boolean | UserCountOutputTypeCountJdIntelligenceArgs
    ResumeTag?: boolean | UserCountOutputTypeCountResumeTagArgs
    ResumeMetadata?: boolean | UserCountOutputTypeCountResumeMetadataArgs
    ResumeSectionRationale?: boolean | UserCountOutputTypeCountResumeSectionRationaleArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringAnalyticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeInteractionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoverLetterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLinkedInOptimizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkedInOptimizationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterviewSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResumeExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeExportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJdIntelligenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobDescriptionIntelligenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResumeTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeTagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResumeMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeMetadataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResumeSectionRationaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeSectionRationaleWhereInput
  }


  /**
   * Count Type ResumeCountOutputType
   */

  export type ResumeCountOutputType = {
    analytics: number
    promptArchives: number
    interactions: number
    tags: number
    tailoringPrompts: number
    coverLetters: number
    exports: number
    tailoringProgress: number
    tailoringAttempts: number
    manualEdits: number
    manualScorings: number
    resumeFeedback: number
    ResumeSectionRationale: number
  }

  export type ResumeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analytics?: boolean | ResumeCountOutputTypeCountAnalyticsArgs
    promptArchives?: boolean | ResumeCountOutputTypeCountPromptArchivesArgs
    interactions?: boolean | ResumeCountOutputTypeCountInteractionsArgs
    tags?: boolean | ResumeCountOutputTypeCountTagsArgs
    tailoringPrompts?: boolean | ResumeCountOutputTypeCountTailoringPromptsArgs
    coverLetters?: boolean | ResumeCountOutputTypeCountCoverLettersArgs
    exports?: boolean | ResumeCountOutputTypeCountExportsArgs
    tailoringProgress?: boolean | ResumeCountOutputTypeCountTailoringProgressArgs
    tailoringAttempts?: boolean | ResumeCountOutputTypeCountTailoringAttemptsArgs
    manualEdits?: boolean | ResumeCountOutputTypeCountManualEditsArgs
    manualScorings?: boolean | ResumeCountOutputTypeCountManualScoringsArgs
    resumeFeedback?: boolean | ResumeCountOutputTypeCountResumeFeedbackArgs
    ResumeSectionRationale?: boolean | ResumeCountOutputTypeCountResumeSectionRationaleArgs
  }

  // Custom InputTypes
  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCountOutputType
     */
    select?: ResumeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringAnalyticsWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountPromptArchivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptArchiveWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeInteractionWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeTagWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountTailoringPromptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringPromptWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoverLetterWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeExportWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountTailoringProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringProgressWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountTailoringAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringAttemptWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountManualEditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualEditWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountManualScoringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualScoringWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountResumeFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeFeedbackWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountResumeSectionRationaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeSectionRationaleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    dailyBasicTailoringsUsed: number | null
    dailyPersonalizedTailoringsUsed: number | null
    dailyAggressiveTailoringsUsed: number | null
    dailyCoverLettersUsed: number | null
    dailyLinkedinOptimizationsUsed: number | null
    dailyInterviewSessionsUsed: number | null
  }

  export type UserSumAggregateOutputType = {
    dailyBasicTailoringsUsed: number | null
    dailyPersonalizedTailoringsUsed: number | null
    dailyAggressiveTailoringsUsed: number | null
    dailyCoverLettersUsed: number | null
    dailyLinkedinOptimizationsUsed: number | null
    dailyInterviewSessionsUsed: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    isPremium: boolean | null
    dailyResetDate: Date | null
    dailyBasicTailoringsUsed: number | null
    dailyPersonalizedTailoringsUsed: number | null
    dailyAggressiveTailoringsUsed: number | null
    dailyCoverLettersUsed: number | null
    dailyLinkedinOptimizationsUsed: number | null
    dailyInterviewSessionsUsed: number | null
    analyticsTimeRange: string | null
    analyticsViewMode: string | null
    resumeTemplate: string | null
    preferredTailoringMode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    isPremium: boolean | null
    dailyResetDate: Date | null
    dailyBasicTailoringsUsed: number | null
    dailyPersonalizedTailoringsUsed: number | null
    dailyAggressiveTailoringsUsed: number | null
    dailyCoverLettersUsed: number | null
    dailyLinkedinOptimizationsUsed: number | null
    dailyInterviewSessionsUsed: number | null
    analyticsTimeRange: string | null
    analyticsViewMode: string | null
    resumeTemplate: string | null
    preferredTailoringMode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    fullName: number
    isPremium: number
    dailyResetDate: number
    dailyBasicTailoringsUsed: number
    dailyPersonalizedTailoringsUsed: number
    dailyAggressiveTailoringsUsed: number
    dailyCoverLettersUsed: number
    dailyLinkedinOptimizationsUsed: number
    dailyInterviewSessionsUsed: number
    analyticsTimeRange: number
    analyticsViewMode: number
    resumeTemplate: number
    preferredTailoringMode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    dailyBasicTailoringsUsed?: true
    dailyPersonalizedTailoringsUsed?: true
    dailyAggressiveTailoringsUsed?: true
    dailyCoverLettersUsed?: true
    dailyLinkedinOptimizationsUsed?: true
    dailyInterviewSessionsUsed?: true
  }

  export type UserSumAggregateInputType = {
    dailyBasicTailoringsUsed?: true
    dailyPersonalizedTailoringsUsed?: true
    dailyAggressiveTailoringsUsed?: true
    dailyCoverLettersUsed?: true
    dailyLinkedinOptimizationsUsed?: true
    dailyInterviewSessionsUsed?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    isPremium?: true
    dailyResetDate?: true
    dailyBasicTailoringsUsed?: true
    dailyPersonalizedTailoringsUsed?: true
    dailyAggressiveTailoringsUsed?: true
    dailyCoverLettersUsed?: true
    dailyLinkedinOptimizationsUsed?: true
    dailyInterviewSessionsUsed?: true
    analyticsTimeRange?: true
    analyticsViewMode?: true
    resumeTemplate?: true
    preferredTailoringMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    isPremium?: true
    dailyResetDate?: true
    dailyBasicTailoringsUsed?: true
    dailyPersonalizedTailoringsUsed?: true
    dailyAggressiveTailoringsUsed?: true
    dailyCoverLettersUsed?: true
    dailyLinkedinOptimizationsUsed?: true
    dailyInterviewSessionsUsed?: true
    analyticsTimeRange?: true
    analyticsViewMode?: true
    resumeTemplate?: true
    preferredTailoringMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    isPremium?: true
    dailyResetDate?: true
    dailyBasicTailoringsUsed?: true
    dailyPersonalizedTailoringsUsed?: true
    dailyAggressiveTailoringsUsed?: true
    dailyCoverLettersUsed?: true
    dailyLinkedinOptimizationsUsed?: true
    dailyInterviewSessionsUsed?: true
    analyticsTimeRange?: true
    analyticsViewMode?: true
    resumeTemplate?: true
    preferredTailoringMode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    fullName: string | null
    isPremium: boolean
    dailyResetDate: Date | null
    dailyBasicTailoringsUsed: number
    dailyPersonalizedTailoringsUsed: number
    dailyAggressiveTailoringsUsed: number
    dailyCoverLettersUsed: number
    dailyLinkedinOptimizationsUsed: number
    dailyInterviewSessionsUsed: number
    analyticsTimeRange: string | null
    analyticsViewMode: string | null
    resumeTemplate: string | null
    preferredTailoringMode: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    isPremium?: boolean
    dailyResetDate?: boolean
    dailyBasicTailoringsUsed?: boolean
    dailyPersonalizedTailoringsUsed?: boolean
    dailyAggressiveTailoringsUsed?: boolean
    dailyCoverLettersUsed?: boolean
    dailyLinkedinOptimizationsUsed?: boolean
    dailyInterviewSessionsUsed?: boolean
    analyticsTimeRange?: boolean
    analyticsViewMode?: boolean
    resumeTemplate?: boolean
    preferredTailoringMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resumes?: boolean | User$resumesArgs<ExtArgs>
    analytics?: boolean | User$analyticsArgs<ExtArgs>
    interactions?: boolean | User$interactionsArgs<ExtArgs>
    coverLetters?: boolean | User$coverLettersArgs<ExtArgs>
    linkedInOptimizations?: boolean | User$linkedInOptimizationsArgs<ExtArgs>
    interviewSessions?: boolean | User$interviewSessionsArgs<ExtArgs>
    resumeExports?: boolean | User$resumeExportsArgs<ExtArgs>
    jdIntelligence?: boolean | User$jdIntelligenceArgs<ExtArgs>
    ResumeTag?: boolean | User$ResumeTagArgs<ExtArgs>
    ResumeMetadata?: boolean | User$ResumeMetadataArgs<ExtArgs>
    ResumeSectionRationale?: boolean | User$ResumeSectionRationaleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    isPremium?: boolean
    dailyResetDate?: boolean
    dailyBasicTailoringsUsed?: boolean
    dailyPersonalizedTailoringsUsed?: boolean
    dailyAggressiveTailoringsUsed?: boolean
    dailyCoverLettersUsed?: boolean
    dailyLinkedinOptimizationsUsed?: boolean
    dailyInterviewSessionsUsed?: boolean
    analyticsTimeRange?: boolean
    analyticsViewMode?: boolean
    resumeTemplate?: boolean
    preferredTailoringMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    isPremium?: boolean
    dailyResetDate?: boolean
    dailyBasicTailoringsUsed?: boolean
    dailyPersonalizedTailoringsUsed?: boolean
    dailyAggressiveTailoringsUsed?: boolean
    dailyCoverLettersUsed?: boolean
    dailyLinkedinOptimizationsUsed?: boolean
    dailyInterviewSessionsUsed?: boolean
    analyticsTimeRange?: boolean
    analyticsViewMode?: boolean
    resumeTemplate?: boolean
    preferredTailoringMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    fullName?: boolean
    isPremium?: boolean
    dailyResetDate?: boolean
    dailyBasicTailoringsUsed?: boolean
    dailyPersonalizedTailoringsUsed?: boolean
    dailyAggressiveTailoringsUsed?: boolean
    dailyCoverLettersUsed?: boolean
    dailyLinkedinOptimizationsUsed?: boolean
    dailyInterviewSessionsUsed?: boolean
    analyticsTimeRange?: boolean
    analyticsViewMode?: boolean
    resumeTemplate?: boolean
    preferredTailoringMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "fullName" | "isPremium" | "dailyResetDate" | "dailyBasicTailoringsUsed" | "dailyPersonalizedTailoringsUsed" | "dailyAggressiveTailoringsUsed" | "dailyCoverLettersUsed" | "dailyLinkedinOptimizationsUsed" | "dailyInterviewSessionsUsed" | "analyticsTimeRange" | "analyticsViewMode" | "resumeTemplate" | "preferredTailoringMode" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resumes?: boolean | User$resumesArgs<ExtArgs>
    analytics?: boolean | User$analyticsArgs<ExtArgs>
    interactions?: boolean | User$interactionsArgs<ExtArgs>
    coverLetters?: boolean | User$coverLettersArgs<ExtArgs>
    linkedInOptimizations?: boolean | User$linkedInOptimizationsArgs<ExtArgs>
    interviewSessions?: boolean | User$interviewSessionsArgs<ExtArgs>
    resumeExports?: boolean | User$resumeExportsArgs<ExtArgs>
    jdIntelligence?: boolean | User$jdIntelligenceArgs<ExtArgs>
    ResumeTag?: boolean | User$ResumeTagArgs<ExtArgs>
    ResumeMetadata?: boolean | User$ResumeMetadataArgs<ExtArgs>
    ResumeSectionRationale?: boolean | User$ResumeSectionRationaleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      resumes: Prisma.$ResumePayload<ExtArgs>[]
      analytics: Prisma.$TailoringAnalyticsPayload<ExtArgs>[]
      interactions: Prisma.$ResumeInteractionPayload<ExtArgs>[]
      coverLetters: Prisma.$CoverLetterPayload<ExtArgs>[]
      linkedInOptimizations: Prisma.$LinkedInOptimizationPayload<ExtArgs>[]
      interviewSessions: Prisma.$InterviewSessionPayload<ExtArgs>[]
      resumeExports: Prisma.$ResumeExportPayload<ExtArgs>[]
      jdIntelligence: Prisma.$JobDescriptionIntelligencePayload<ExtArgs>[]
      ResumeTag: Prisma.$ResumeTagPayload<ExtArgs>[]
      ResumeMetadata: Prisma.$ResumeMetadataPayload<ExtArgs>[]
      ResumeSectionRationale: Prisma.$ResumeSectionRationalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      fullName: string | null
      isPremium: boolean
      dailyResetDate: Date | null
      dailyBasicTailoringsUsed: number
      dailyPersonalizedTailoringsUsed: number
      dailyAggressiveTailoringsUsed: number
      dailyCoverLettersUsed: number
      dailyLinkedinOptimizationsUsed: number
      dailyInterviewSessionsUsed: number
      analyticsTimeRange: string | null
      analyticsViewMode: string | null
      resumeTemplate: string | null
      preferredTailoringMode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resumes<T extends User$resumesArgs<ExtArgs> = {}>(args?: Subset<T, User$resumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analytics<T extends User$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends User$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coverLetters<T extends User$coverLettersArgs<ExtArgs> = {}>(args?: Subset<T, User$coverLettersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    linkedInOptimizations<T extends User$linkedInOptimizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$linkedInOptimizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interviewSessions<T extends User$interviewSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$interviewSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resumeExports<T extends User$resumeExportsArgs<ExtArgs> = {}>(args?: Subset<T, User$resumeExportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jdIntelligence<T extends User$jdIntelligenceArgs<ExtArgs> = {}>(args?: Subset<T, User$jdIntelligenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ResumeTag<T extends User$ResumeTagArgs<ExtArgs> = {}>(args?: Subset<T, User$ResumeTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ResumeMetadata<T extends User$ResumeMetadataArgs<ExtArgs> = {}>(args?: Subset<T, User$ResumeMetadataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ResumeSectionRationale<T extends User$ResumeSectionRationaleArgs<ExtArgs> = {}>(args?: Subset<T, User$ResumeSectionRationaleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly isPremium: FieldRef<"User", 'Boolean'>
    readonly dailyResetDate: FieldRef<"User", 'DateTime'>
    readonly dailyBasicTailoringsUsed: FieldRef<"User", 'Int'>
    readonly dailyPersonalizedTailoringsUsed: FieldRef<"User", 'Int'>
    readonly dailyAggressiveTailoringsUsed: FieldRef<"User", 'Int'>
    readonly dailyCoverLettersUsed: FieldRef<"User", 'Int'>
    readonly dailyLinkedinOptimizationsUsed: FieldRef<"User", 'Int'>
    readonly dailyInterviewSessionsUsed: FieldRef<"User", 'Int'>
    readonly analyticsTimeRange: FieldRef<"User", 'String'>
    readonly analyticsViewMode: FieldRef<"User", 'String'>
    readonly resumeTemplate: FieldRef<"User", 'String'>
    readonly preferredTailoringMode: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.resumes
   */
  export type User$resumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    where?: ResumeWhereInput
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    cursor?: ResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * User.analytics
   */
  export type User$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    where?: TailoringAnalyticsWhereInput
    orderBy?: TailoringAnalyticsOrderByWithRelationInput | TailoringAnalyticsOrderByWithRelationInput[]
    cursor?: TailoringAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TailoringAnalyticsScalarFieldEnum | TailoringAnalyticsScalarFieldEnum[]
  }

  /**
   * User.interactions
   */
  export type User$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    where?: ResumeInteractionWhereInput
    orderBy?: ResumeInteractionOrderByWithRelationInput | ResumeInteractionOrderByWithRelationInput[]
    cursor?: ResumeInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeInteractionScalarFieldEnum | ResumeInteractionScalarFieldEnum[]
  }

  /**
   * User.coverLetters
   */
  export type User$coverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    where?: CoverLetterWhereInput
    orderBy?: CoverLetterOrderByWithRelationInput | CoverLetterOrderByWithRelationInput[]
    cursor?: CoverLetterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoverLetterScalarFieldEnum | CoverLetterScalarFieldEnum[]
  }

  /**
   * User.linkedInOptimizations
   */
  export type User$linkedInOptimizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    where?: LinkedInOptimizationWhereInput
    orderBy?: LinkedInOptimizationOrderByWithRelationInput | LinkedInOptimizationOrderByWithRelationInput[]
    cursor?: LinkedInOptimizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkedInOptimizationScalarFieldEnum | LinkedInOptimizationScalarFieldEnum[]
  }

  /**
   * User.interviewSessions
   */
  export type User$interviewSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    where?: InterviewSessionWhereInput
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    cursor?: InterviewSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewSessionScalarFieldEnum | InterviewSessionScalarFieldEnum[]
  }

  /**
   * User.resumeExports
   */
  export type User$resumeExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    where?: ResumeExportWhereInput
    orderBy?: ResumeExportOrderByWithRelationInput | ResumeExportOrderByWithRelationInput[]
    cursor?: ResumeExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeExportScalarFieldEnum | ResumeExportScalarFieldEnum[]
  }

  /**
   * User.jdIntelligence
   */
  export type User$jdIntelligenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    where?: JobDescriptionIntelligenceWhereInput
    orderBy?: JobDescriptionIntelligenceOrderByWithRelationInput | JobDescriptionIntelligenceOrderByWithRelationInput[]
    cursor?: JobDescriptionIntelligenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobDescriptionIntelligenceScalarFieldEnum | JobDescriptionIntelligenceScalarFieldEnum[]
  }

  /**
   * User.ResumeTag
   */
  export type User$ResumeTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    where?: ResumeTagWhereInput
    orderBy?: ResumeTagOrderByWithRelationInput | ResumeTagOrderByWithRelationInput[]
    cursor?: ResumeTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeTagScalarFieldEnum | ResumeTagScalarFieldEnum[]
  }

  /**
   * User.ResumeMetadata
   */
  export type User$ResumeMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    where?: ResumeMetadataWhereInput
    orderBy?: ResumeMetadataOrderByWithRelationInput | ResumeMetadataOrderByWithRelationInput[]
    cursor?: ResumeMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeMetadataScalarFieldEnum | ResumeMetadataScalarFieldEnum[]
  }

  /**
   * User.ResumeSectionRationale
   */
  export type User$ResumeSectionRationaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    where?: ResumeSectionRationaleWhereInput
    orderBy?: ResumeSectionRationaleOrderByWithRelationInput | ResumeSectionRationaleOrderByWithRelationInput[]
    cursor?: ResumeSectionRationaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeSectionRationaleScalarFieldEnum | ResumeSectionRationaleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Resume
   */

  export type AggregateResume = {
    _count: ResumeCountAggregateOutputType | null
    _avg: ResumeAvgAggregateOutputType | null
    _sum: ResumeSumAggregateOutputType | null
    _min: ResumeMinAggregateOutputType | null
    _max: ResumeMaxAggregateOutputType | null
  }

  export type ResumeAvgAggregateOutputType = {
    version: number | null
    atsScore: number | null
    jdScore: number | null
  }

  export type ResumeSumAggregateOutputType = {
    version: number | null
    atsScore: number | null
    jdScore: number | null
  }

  export type ResumeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeText: string | null
    jobDescription: string | null
    modifiedResume: string | null
    tailoringMode: string | null
    version: number | null
    label: string | null
    atsScore: number | null
    jdScore: number | null
    goldenPassed: boolean | null
    isRefinement: boolean | null
    isSaved: boolean | null
    originalResumeId: string | null
    wasManuallyEdited: boolean | null
    scoresStale: boolean | null
    finalModifiedSections: string | null
    atsWarnings: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResumeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeText: string | null
    jobDescription: string | null
    modifiedResume: string | null
    tailoringMode: string | null
    version: number | null
    label: string | null
    atsScore: number | null
    jdScore: number | null
    goldenPassed: boolean | null
    isRefinement: boolean | null
    isSaved: boolean | null
    originalResumeId: string | null
    wasManuallyEdited: boolean | null
    scoresStale: boolean | null
    finalModifiedSections: string | null
    atsWarnings: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResumeCountAggregateOutputType = {
    id: number
    userId: number
    resumeText: number
    jobDescription: number
    modifiedResume: number
    tailoringMode: number
    version: number
    label: number
    atsScore: number
    jdScore: number
    goldenPassed: number
    isRefinement: number
    isSaved: number
    originalResumeId: number
    wasManuallyEdited: number
    scoresStale: number
    finalModifiedSections: number
    atsWarnings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResumeAvgAggregateInputType = {
    version?: true
    atsScore?: true
    jdScore?: true
  }

  export type ResumeSumAggregateInputType = {
    version?: true
    atsScore?: true
    jdScore?: true
  }

  export type ResumeMinAggregateInputType = {
    id?: true
    userId?: true
    resumeText?: true
    jobDescription?: true
    modifiedResume?: true
    tailoringMode?: true
    version?: true
    label?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    isRefinement?: true
    isSaved?: true
    originalResumeId?: true
    wasManuallyEdited?: true
    scoresStale?: true
    finalModifiedSections?: true
    atsWarnings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResumeMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeText?: true
    jobDescription?: true
    modifiedResume?: true
    tailoringMode?: true
    version?: true
    label?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    isRefinement?: true
    isSaved?: true
    originalResumeId?: true
    wasManuallyEdited?: true
    scoresStale?: true
    finalModifiedSections?: true
    atsWarnings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResumeCountAggregateInputType = {
    id?: true
    userId?: true
    resumeText?: true
    jobDescription?: true
    modifiedResume?: true
    tailoringMode?: true
    version?: true
    label?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    isRefinement?: true
    isSaved?: true
    originalResumeId?: true
    wasManuallyEdited?: true
    scoresStale?: true
    finalModifiedSections?: true
    atsWarnings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resume to aggregate.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resumes
    **/
    _count?: true | ResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeMaxAggregateInputType
  }

  export type GetResumeAggregateType<T extends ResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResume[P]>
      : GetScalarType<T[P], AggregateResume[P]>
  }




  export type ResumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeWhereInput
    orderBy?: ResumeOrderByWithAggregationInput | ResumeOrderByWithAggregationInput[]
    by: ResumeScalarFieldEnum[] | ResumeScalarFieldEnum
    having?: ResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeCountAggregateInputType | true
    _avg?: ResumeAvgAggregateInputType
    _sum?: ResumeSumAggregateInputType
    _min?: ResumeMinAggregateInputType
    _max?: ResumeMaxAggregateInputType
  }

  export type ResumeGroupByOutputType = {
    id: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume: string | null
    tailoringMode: string
    version: number
    label: string | null
    atsScore: number | null
    jdScore: number | null
    goldenPassed: boolean
    isRefinement: boolean
    isSaved: boolean
    originalResumeId: string | null
    wasManuallyEdited: boolean
    scoresStale: boolean
    finalModifiedSections: string | null
    atsWarnings: string | null
    createdAt: Date
    updatedAt: Date
    _count: ResumeCountAggregateOutputType | null
    _avg: ResumeAvgAggregateOutputType | null
    _sum: ResumeSumAggregateOutputType | null
    _min: ResumeMinAggregateOutputType | null
    _max: ResumeMaxAggregateOutputType | null
  }

  type GetResumeGroupByPayload<T extends ResumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeGroupByOutputType[P]>
        }
      >
    >


  export type ResumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    modifiedResume?: boolean
    tailoringMode?: boolean
    version?: boolean
    label?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: boolean
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: boolean
    atsWarnings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    analytics?: boolean | Resume$analyticsArgs<ExtArgs>
    scrubbedResume?: boolean | Resume$scrubbedResumeArgs<ExtArgs>
    promptArchives?: boolean | Resume$promptArchivesArgs<ExtArgs>
    interactions?: boolean | Resume$interactionsArgs<ExtArgs>
    tags?: boolean | Resume$tagsArgs<ExtArgs>
    metadata?: boolean | Resume$metadataArgs<ExtArgs>
    tailoringPrompts?: boolean | Resume$tailoringPromptsArgs<ExtArgs>
    coverLetters?: boolean | Resume$coverLettersArgs<ExtArgs>
    exports?: boolean | Resume$exportsArgs<ExtArgs>
    tailoringProgress?: boolean | Resume$tailoringProgressArgs<ExtArgs>
    tailoringAttempts?: boolean | Resume$tailoringAttemptsArgs<ExtArgs>
    manualEdits?: boolean | Resume$manualEditsArgs<ExtArgs>
    manualScorings?: boolean | Resume$manualScoringsArgs<ExtArgs>
    resumeFeedback?: boolean | Resume$resumeFeedbackArgs<ExtArgs>
    ResumeSectionRationale?: boolean | Resume$ResumeSectionRationaleArgs<ExtArgs>
    _count?: boolean | ResumeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    modifiedResume?: boolean
    tailoringMode?: boolean
    version?: boolean
    label?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: boolean
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: boolean
    atsWarnings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    modifiedResume?: boolean
    tailoringMode?: boolean
    version?: boolean
    label?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: boolean
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: boolean
    atsWarnings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    modifiedResume?: boolean
    tailoringMode?: boolean
    version?: boolean
    label?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: boolean
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: boolean
    atsWarnings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeText" | "jobDescription" | "modifiedResume" | "tailoringMode" | "version" | "label" | "atsScore" | "jdScore" | "goldenPassed" | "isRefinement" | "isSaved" | "originalResumeId" | "wasManuallyEdited" | "scoresStale" | "finalModifiedSections" | "atsWarnings" | "createdAt" | "updatedAt", ExtArgs["result"]["resume"]>
  export type ResumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    analytics?: boolean | Resume$analyticsArgs<ExtArgs>
    scrubbedResume?: boolean | Resume$scrubbedResumeArgs<ExtArgs>
    promptArchives?: boolean | Resume$promptArchivesArgs<ExtArgs>
    interactions?: boolean | Resume$interactionsArgs<ExtArgs>
    tags?: boolean | Resume$tagsArgs<ExtArgs>
    metadata?: boolean | Resume$metadataArgs<ExtArgs>
    tailoringPrompts?: boolean | Resume$tailoringPromptsArgs<ExtArgs>
    coverLetters?: boolean | Resume$coverLettersArgs<ExtArgs>
    exports?: boolean | Resume$exportsArgs<ExtArgs>
    tailoringProgress?: boolean | Resume$tailoringProgressArgs<ExtArgs>
    tailoringAttempts?: boolean | Resume$tailoringAttemptsArgs<ExtArgs>
    manualEdits?: boolean | Resume$manualEditsArgs<ExtArgs>
    manualScorings?: boolean | Resume$manualScoringsArgs<ExtArgs>
    resumeFeedback?: boolean | Resume$resumeFeedbackArgs<ExtArgs>
    ResumeSectionRationale?: boolean | Resume$ResumeSectionRationaleArgs<ExtArgs>
    _count?: boolean | ResumeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resume"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      analytics: Prisma.$TailoringAnalyticsPayload<ExtArgs>[]
      scrubbedResume: Prisma.$ScrubbedResumePayload<ExtArgs> | null
      promptArchives: Prisma.$PromptArchivePayload<ExtArgs>[]
      interactions: Prisma.$ResumeInteractionPayload<ExtArgs>[]
      tags: Prisma.$ResumeTagPayload<ExtArgs>[]
      metadata: Prisma.$ResumeMetadataPayload<ExtArgs> | null
      tailoringPrompts: Prisma.$TailoringPromptPayload<ExtArgs>[]
      coverLetters: Prisma.$CoverLetterPayload<ExtArgs>[]
      exports: Prisma.$ResumeExportPayload<ExtArgs>[]
      tailoringProgress: Prisma.$TailoringProgressPayload<ExtArgs>[]
      tailoringAttempts: Prisma.$TailoringAttemptPayload<ExtArgs>[]
      manualEdits: Prisma.$ManualEditPayload<ExtArgs>[]
      manualScorings: Prisma.$ManualScoringPayload<ExtArgs>[]
      resumeFeedback: Prisma.$ResumeFeedbackPayload<ExtArgs>[]
      ResumeSectionRationale: Prisma.$ResumeSectionRationalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeText: string
      jobDescription: string
      modifiedResume: string | null
      tailoringMode: string
      version: number
      label: string | null
      atsScore: number | null
      jdScore: number | null
      goldenPassed: boolean
      isRefinement: boolean
      isSaved: boolean
      originalResumeId: string | null
      wasManuallyEdited: boolean
      scoresStale: boolean
      finalModifiedSections: string | null
      atsWarnings: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resume"]>
    composites: {}
  }

  type ResumeGetPayload<S extends boolean | null | undefined | ResumeDefaultArgs> = $Result.GetResult<Prisma.$ResumePayload, S>

  type ResumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeCountAggregateInputType | true
    }

  export interface ResumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resume'], meta: { name: 'Resume' } }
    /**
     * Find zero or one Resume that matches the filter.
     * @param {ResumeFindUniqueArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeFindUniqueArgs>(args: SelectSubset<T, ResumeFindUniqueArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeFindUniqueOrThrowArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindFirstArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeFindFirstArgs>(args?: SelectSubset<T, ResumeFindFirstArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindFirstOrThrowArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resumes
     * const resumes = await prisma.resume.findMany()
     * 
     * // Get first 10 Resumes
     * const resumes = await prisma.resume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeWithIdOnly = await prisma.resume.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeFindManyArgs>(args?: SelectSubset<T, ResumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resume.
     * @param {ResumeCreateArgs} args - Arguments to create a Resume.
     * @example
     * // Create one Resume
     * const Resume = await prisma.resume.create({
     *   data: {
     *     // ... data to create a Resume
     *   }
     * })
     * 
     */
    create<T extends ResumeCreateArgs>(args: SelectSubset<T, ResumeCreateArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resumes.
     * @param {ResumeCreateManyArgs} args - Arguments to create many Resumes.
     * @example
     * // Create many Resumes
     * const resume = await prisma.resume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeCreateManyArgs>(args?: SelectSubset<T, ResumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resumes and returns the data saved in the database.
     * @param {ResumeCreateManyAndReturnArgs} args - Arguments to create many Resumes.
     * @example
     * // Create many Resumes
     * const resume = await prisma.resume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resumes and only return the `id`
     * const resumeWithIdOnly = await prisma.resume.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resume.
     * @param {ResumeDeleteArgs} args - Arguments to delete one Resume.
     * @example
     * // Delete one Resume
     * const Resume = await prisma.resume.delete({
     *   where: {
     *     // ... filter to delete one Resume
     *   }
     * })
     * 
     */
    delete<T extends ResumeDeleteArgs>(args: SelectSubset<T, ResumeDeleteArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resume.
     * @param {ResumeUpdateArgs} args - Arguments to update one Resume.
     * @example
     * // Update one Resume
     * const resume = await prisma.resume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeUpdateArgs>(args: SelectSubset<T, ResumeUpdateArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resumes.
     * @param {ResumeDeleteManyArgs} args - Arguments to filter Resumes to delete.
     * @example
     * // Delete a few Resumes
     * const { count } = await prisma.resume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeDeleteManyArgs>(args?: SelectSubset<T, ResumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resumes
     * const resume = await prisma.resume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeUpdateManyArgs>(args: SelectSubset<T, ResumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes and returns the data updated in the database.
     * @param {ResumeUpdateManyAndReturnArgs} args - Arguments to update many Resumes.
     * @example
     * // Update many Resumes
     * const resume = await prisma.resume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resumes and only return the `id`
     * const resumeWithIdOnly = await prisma.resume.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resume.
     * @param {ResumeUpsertArgs} args - Arguments to update or create a Resume.
     * @example
     * // Update or create a Resume
     * const resume = await prisma.resume.upsert({
     *   create: {
     *     // ... data to create a Resume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resume we want to update
     *   }
     * })
     */
    upsert<T extends ResumeUpsertArgs>(args: SelectSubset<T, ResumeUpsertArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCountArgs} args - Arguments to filter Resumes to count.
     * @example
     * // Count the number of Resumes
     * const count = await prisma.resume.count({
     *   where: {
     *     // ... the filter for the Resumes we want to count
     *   }
     * })
    **/
    count<T extends ResumeCountArgs>(
      args?: Subset<T, ResumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeAggregateArgs>(args: Subset<T, ResumeAggregateArgs>): Prisma.PrismaPromise<GetResumeAggregateType<T>>

    /**
     * Group by Resume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeGroupByArgs['orderBy'] }
        : { orderBy?: ResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resume model
   */
  readonly fields: ResumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    analytics<T extends Resume$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scrubbedResume<T extends Resume$scrubbedResumeArgs<ExtArgs> = {}>(args?: Subset<T, Resume$scrubbedResumeArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    promptArchives<T extends Resume$promptArchivesArgs<ExtArgs> = {}>(args?: Subset<T, Resume$promptArchivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends Resume$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Resume$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metadata<T extends Resume$metadataArgs<ExtArgs> = {}>(args?: Subset<T, Resume$metadataArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tailoringPrompts<T extends Resume$tailoringPromptsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$tailoringPromptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coverLetters<T extends Resume$coverLettersArgs<ExtArgs> = {}>(args?: Subset<T, Resume$coverLettersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exports<T extends Resume$exportsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$exportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tailoringProgress<T extends Resume$tailoringProgressArgs<ExtArgs> = {}>(args?: Subset<T, Resume$tailoringProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tailoringAttempts<T extends Resume$tailoringAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$tailoringAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manualEdits<T extends Resume$manualEditsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$manualEditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manualScorings<T extends Resume$manualScoringsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$manualScoringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resumeFeedback<T extends Resume$resumeFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, Resume$resumeFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ResumeSectionRationale<T extends Resume$ResumeSectionRationaleArgs<ExtArgs> = {}>(args?: Subset<T, Resume$ResumeSectionRationaleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resume model
   */
  interface ResumeFieldRefs {
    readonly id: FieldRef<"Resume", 'String'>
    readonly userId: FieldRef<"Resume", 'String'>
    readonly resumeText: FieldRef<"Resume", 'String'>
    readonly jobDescription: FieldRef<"Resume", 'String'>
    readonly modifiedResume: FieldRef<"Resume", 'String'>
    readonly tailoringMode: FieldRef<"Resume", 'String'>
    readonly version: FieldRef<"Resume", 'Int'>
    readonly label: FieldRef<"Resume", 'String'>
    readonly atsScore: FieldRef<"Resume", 'Int'>
    readonly jdScore: FieldRef<"Resume", 'Int'>
    readonly goldenPassed: FieldRef<"Resume", 'Boolean'>
    readonly isRefinement: FieldRef<"Resume", 'Boolean'>
    readonly isSaved: FieldRef<"Resume", 'Boolean'>
    readonly originalResumeId: FieldRef<"Resume", 'String'>
    readonly wasManuallyEdited: FieldRef<"Resume", 'Boolean'>
    readonly scoresStale: FieldRef<"Resume", 'Boolean'>
    readonly finalModifiedSections: FieldRef<"Resume", 'String'>
    readonly atsWarnings: FieldRef<"Resume", 'String'>
    readonly createdAt: FieldRef<"Resume", 'DateTime'>
    readonly updatedAt: FieldRef<"Resume", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resume findUnique
   */
  export type ResumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume findUniqueOrThrow
   */
  export type ResumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume findFirst
   */
  export type ResumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resumes.
     */
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume findFirstOrThrow
   */
  export type ResumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resumes.
     */
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume findMany
   */
  export type ResumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resumes to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume create
   */
  export type ResumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The data needed to create a Resume.
     */
    data: XOR<ResumeCreateInput, ResumeUncheckedCreateInput>
  }

  /**
   * Resume createMany
   */
  export type ResumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resumes.
     */
    data: ResumeCreateManyInput | ResumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resume createManyAndReturn
   */
  export type ResumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * The data used to create many Resumes.
     */
    data: ResumeCreateManyInput | ResumeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resume update
   */
  export type ResumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The data needed to update a Resume.
     */
    data: XOR<ResumeUpdateInput, ResumeUncheckedUpdateInput>
    /**
     * Choose, which Resume to update.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume updateMany
   */
  export type ResumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resumes.
     */
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyInput>
    /**
     * Filter which Resumes to update
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to update.
     */
    limit?: number
  }

  /**
   * Resume updateManyAndReturn
   */
  export type ResumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * The data used to update Resumes.
     */
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyInput>
    /**
     * Filter which Resumes to update
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resume upsert
   */
  export type ResumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The filter to search for the Resume to update in case it exists.
     */
    where: ResumeWhereUniqueInput
    /**
     * In case the Resume found by the `where` argument doesn't exist, create a new Resume with this data.
     */
    create: XOR<ResumeCreateInput, ResumeUncheckedCreateInput>
    /**
     * In case the Resume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeUpdateInput, ResumeUncheckedUpdateInput>
  }

  /**
   * Resume delete
   */
  export type ResumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter which Resume to delete.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume deleteMany
   */
  export type ResumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resumes to delete
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to delete.
     */
    limit?: number
  }

  /**
   * Resume.analytics
   */
  export type Resume$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    where?: TailoringAnalyticsWhereInput
    orderBy?: TailoringAnalyticsOrderByWithRelationInput | TailoringAnalyticsOrderByWithRelationInput[]
    cursor?: TailoringAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TailoringAnalyticsScalarFieldEnum | TailoringAnalyticsScalarFieldEnum[]
  }

  /**
   * Resume.scrubbedResume
   */
  export type Resume$scrubbedResumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    where?: ScrubbedResumeWhereInput
  }

  /**
   * Resume.promptArchives
   */
  export type Resume$promptArchivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    where?: PromptArchiveWhereInput
    orderBy?: PromptArchiveOrderByWithRelationInput | PromptArchiveOrderByWithRelationInput[]
    cursor?: PromptArchiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptArchiveScalarFieldEnum | PromptArchiveScalarFieldEnum[]
  }

  /**
   * Resume.interactions
   */
  export type Resume$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    where?: ResumeInteractionWhereInput
    orderBy?: ResumeInteractionOrderByWithRelationInput | ResumeInteractionOrderByWithRelationInput[]
    cursor?: ResumeInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeInteractionScalarFieldEnum | ResumeInteractionScalarFieldEnum[]
  }

  /**
   * Resume.tags
   */
  export type Resume$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    where?: ResumeTagWhereInput
    orderBy?: ResumeTagOrderByWithRelationInput | ResumeTagOrderByWithRelationInput[]
    cursor?: ResumeTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeTagScalarFieldEnum | ResumeTagScalarFieldEnum[]
  }

  /**
   * Resume.metadata
   */
  export type Resume$metadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    where?: ResumeMetadataWhereInput
  }

  /**
   * Resume.tailoringPrompts
   */
  export type Resume$tailoringPromptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    where?: TailoringPromptWhereInput
    orderBy?: TailoringPromptOrderByWithRelationInput | TailoringPromptOrderByWithRelationInput[]
    cursor?: TailoringPromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TailoringPromptScalarFieldEnum | TailoringPromptScalarFieldEnum[]
  }

  /**
   * Resume.coverLetters
   */
  export type Resume$coverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    where?: CoverLetterWhereInput
    orderBy?: CoverLetterOrderByWithRelationInput | CoverLetterOrderByWithRelationInput[]
    cursor?: CoverLetterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoverLetterScalarFieldEnum | CoverLetterScalarFieldEnum[]
  }

  /**
   * Resume.exports
   */
  export type Resume$exportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    where?: ResumeExportWhereInput
    orderBy?: ResumeExportOrderByWithRelationInput | ResumeExportOrderByWithRelationInput[]
    cursor?: ResumeExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeExportScalarFieldEnum | ResumeExportScalarFieldEnum[]
  }

  /**
   * Resume.tailoringProgress
   */
  export type Resume$tailoringProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    where?: TailoringProgressWhereInput
    orderBy?: TailoringProgressOrderByWithRelationInput | TailoringProgressOrderByWithRelationInput[]
    cursor?: TailoringProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TailoringProgressScalarFieldEnum | TailoringProgressScalarFieldEnum[]
  }

  /**
   * Resume.tailoringAttempts
   */
  export type Resume$tailoringAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    where?: TailoringAttemptWhereInput
    orderBy?: TailoringAttemptOrderByWithRelationInput | TailoringAttemptOrderByWithRelationInput[]
    cursor?: TailoringAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TailoringAttemptScalarFieldEnum | TailoringAttemptScalarFieldEnum[]
  }

  /**
   * Resume.manualEdits
   */
  export type Resume$manualEditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    where?: ManualEditWhereInput
    orderBy?: ManualEditOrderByWithRelationInput | ManualEditOrderByWithRelationInput[]
    cursor?: ManualEditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManualEditScalarFieldEnum | ManualEditScalarFieldEnum[]
  }

  /**
   * Resume.manualScorings
   */
  export type Resume$manualScoringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    where?: ManualScoringWhereInput
    orderBy?: ManualScoringOrderByWithRelationInput | ManualScoringOrderByWithRelationInput[]
    cursor?: ManualScoringWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManualScoringScalarFieldEnum | ManualScoringScalarFieldEnum[]
  }

  /**
   * Resume.resumeFeedback
   */
  export type Resume$resumeFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    where?: ResumeFeedbackWhereInput
    orderBy?: ResumeFeedbackOrderByWithRelationInput | ResumeFeedbackOrderByWithRelationInput[]
    cursor?: ResumeFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeFeedbackScalarFieldEnum | ResumeFeedbackScalarFieldEnum[]
  }

  /**
   * Resume.ResumeSectionRationale
   */
  export type Resume$ResumeSectionRationaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    where?: ResumeSectionRationaleWhereInput
    orderBy?: ResumeSectionRationaleOrderByWithRelationInput | ResumeSectionRationaleOrderByWithRelationInput[]
    cursor?: ResumeSectionRationaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeSectionRationaleScalarFieldEnum | ResumeSectionRationaleScalarFieldEnum[]
  }

  /**
   * Resume without action
   */
  export type ResumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
  }


  /**
   * Model ResumeEvent
   */

  export type AggregateResumeEvent = {
    _count: ResumeEventCountAggregateOutputType | null
    _min: ResumeEventMinAggregateOutputType | null
    _max: ResumeEventMaxAggregateOutputType | null
  }

  export type ResumeEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    eventType: string | null
    resumeText: string | null
    jobDescription: string | null
    createdAt: Date | null
  }

  export type ResumeEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    eventType: string | null
    resumeText: string | null
    jobDescription: string | null
    createdAt: Date | null
  }

  export type ResumeEventCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    eventType: number
    resumeText: number
    jobDescription: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ResumeEventMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    eventType?: true
    resumeText?: true
    jobDescription?: true
    createdAt?: true
  }

  export type ResumeEventMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    eventType?: true
    resumeText?: true
    jobDescription?: true
    createdAt?: true
  }

  export type ResumeEventCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    eventType?: true
    resumeText?: true
    jobDescription?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ResumeEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeEvent to aggregate.
     */
    where?: ResumeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeEvents to fetch.
     */
    orderBy?: ResumeEventOrderByWithRelationInput | ResumeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeEvents
    **/
    _count?: true | ResumeEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeEventMaxAggregateInputType
  }

  export type GetResumeEventAggregateType<T extends ResumeEventAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeEvent[P]>
      : GetScalarType<T[P], AggregateResumeEvent[P]>
  }




  export type ResumeEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeEventWhereInput
    orderBy?: ResumeEventOrderByWithAggregationInput | ResumeEventOrderByWithAggregationInput[]
    by: ResumeEventScalarFieldEnum[] | ResumeEventScalarFieldEnum
    having?: ResumeEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeEventCountAggregateInputType | true
    _min?: ResumeEventMinAggregateInputType
    _max?: ResumeEventMaxAggregateInputType
  }

  export type ResumeEventGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    eventType: string
    resumeText: string | null
    jobDescription: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: ResumeEventCountAggregateOutputType | null
    _min: ResumeEventMinAggregateOutputType | null
    _max: ResumeEventMaxAggregateOutputType | null
  }

  type GetResumeEventGroupByPayload<T extends ResumeEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeEventGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeEventGroupByOutputType[P]>
        }
      >
    >


  export type ResumeEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    eventType?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resumeEvent"]>

  export type ResumeEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    eventType?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resumeEvent"]>

  export type ResumeEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    eventType?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resumeEvent"]>

  export type ResumeEventSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    eventType?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ResumeEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "eventType" | "resumeText" | "jobDescription" | "metadata" | "createdAt", ExtArgs["result"]["resumeEvent"]>

  export type $ResumeEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      eventType: string
      resumeText: string | null
      jobDescription: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["resumeEvent"]>
    composites: {}
  }

  type ResumeEventGetPayload<S extends boolean | null | undefined | ResumeEventDefaultArgs> = $Result.GetResult<Prisma.$ResumeEventPayload, S>

  type ResumeEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeEventCountAggregateInputType | true
    }

  export interface ResumeEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeEvent'], meta: { name: 'ResumeEvent' } }
    /**
     * Find zero or one ResumeEvent that matches the filter.
     * @param {ResumeEventFindUniqueArgs} args - Arguments to find a ResumeEvent
     * @example
     * // Get one ResumeEvent
     * const resumeEvent = await prisma.resumeEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeEventFindUniqueArgs>(args: SelectSubset<T, ResumeEventFindUniqueArgs<ExtArgs>>): Prisma__ResumeEventClient<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResumeEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeEventFindUniqueOrThrowArgs} args - Arguments to find a ResumeEvent
     * @example
     * // Get one ResumeEvent
     * const resumeEvent = await prisma.resumeEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeEventClient<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeEventFindFirstArgs} args - Arguments to find a ResumeEvent
     * @example
     * // Get one ResumeEvent
     * const resumeEvent = await prisma.resumeEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeEventFindFirstArgs>(args?: SelectSubset<T, ResumeEventFindFirstArgs<ExtArgs>>): Prisma__ResumeEventClient<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeEventFindFirstOrThrowArgs} args - Arguments to find a ResumeEvent
     * @example
     * // Get one ResumeEvent
     * const resumeEvent = await prisma.resumeEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeEventClient<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResumeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeEvents
     * const resumeEvents = await prisma.resumeEvent.findMany()
     * 
     * // Get first 10 ResumeEvents
     * const resumeEvents = await prisma.resumeEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeEventWithIdOnly = await prisma.resumeEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeEventFindManyArgs>(args?: SelectSubset<T, ResumeEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResumeEvent.
     * @param {ResumeEventCreateArgs} args - Arguments to create a ResumeEvent.
     * @example
     * // Create one ResumeEvent
     * const ResumeEvent = await prisma.resumeEvent.create({
     *   data: {
     *     // ... data to create a ResumeEvent
     *   }
     * })
     * 
     */
    create<T extends ResumeEventCreateArgs>(args: SelectSubset<T, ResumeEventCreateArgs<ExtArgs>>): Prisma__ResumeEventClient<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResumeEvents.
     * @param {ResumeEventCreateManyArgs} args - Arguments to create many ResumeEvents.
     * @example
     * // Create many ResumeEvents
     * const resumeEvent = await prisma.resumeEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeEventCreateManyArgs>(args?: SelectSubset<T, ResumeEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResumeEvents and returns the data saved in the database.
     * @param {ResumeEventCreateManyAndReturnArgs} args - Arguments to create many ResumeEvents.
     * @example
     * // Create many ResumeEvents
     * const resumeEvent = await prisma.resumeEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResumeEvents and only return the `id`
     * const resumeEventWithIdOnly = await prisma.resumeEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResumeEvent.
     * @param {ResumeEventDeleteArgs} args - Arguments to delete one ResumeEvent.
     * @example
     * // Delete one ResumeEvent
     * const ResumeEvent = await prisma.resumeEvent.delete({
     *   where: {
     *     // ... filter to delete one ResumeEvent
     *   }
     * })
     * 
     */
    delete<T extends ResumeEventDeleteArgs>(args: SelectSubset<T, ResumeEventDeleteArgs<ExtArgs>>): Prisma__ResumeEventClient<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResumeEvent.
     * @param {ResumeEventUpdateArgs} args - Arguments to update one ResumeEvent.
     * @example
     * // Update one ResumeEvent
     * const resumeEvent = await prisma.resumeEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeEventUpdateArgs>(args: SelectSubset<T, ResumeEventUpdateArgs<ExtArgs>>): Prisma__ResumeEventClient<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResumeEvents.
     * @param {ResumeEventDeleteManyArgs} args - Arguments to filter ResumeEvents to delete.
     * @example
     * // Delete a few ResumeEvents
     * const { count } = await prisma.resumeEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeEventDeleteManyArgs>(args?: SelectSubset<T, ResumeEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeEvents
     * const resumeEvent = await prisma.resumeEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeEventUpdateManyArgs>(args: SelectSubset<T, ResumeEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeEvents and returns the data updated in the database.
     * @param {ResumeEventUpdateManyAndReturnArgs} args - Arguments to update many ResumeEvents.
     * @example
     * // Update many ResumeEvents
     * const resumeEvent = await prisma.resumeEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResumeEvents and only return the `id`
     * const resumeEventWithIdOnly = await prisma.resumeEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeEventUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResumeEvent.
     * @param {ResumeEventUpsertArgs} args - Arguments to update or create a ResumeEvent.
     * @example
     * // Update or create a ResumeEvent
     * const resumeEvent = await prisma.resumeEvent.upsert({
     *   create: {
     *     // ... data to create a ResumeEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeEvent we want to update
     *   }
     * })
     */
    upsert<T extends ResumeEventUpsertArgs>(args: SelectSubset<T, ResumeEventUpsertArgs<ExtArgs>>): Prisma__ResumeEventClient<$Result.GetResult<Prisma.$ResumeEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResumeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeEventCountArgs} args - Arguments to filter ResumeEvents to count.
     * @example
     * // Count the number of ResumeEvents
     * const count = await prisma.resumeEvent.count({
     *   where: {
     *     // ... the filter for the ResumeEvents we want to count
     *   }
     * })
    **/
    count<T extends ResumeEventCountArgs>(
      args?: Subset<T, ResumeEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeEventAggregateArgs>(args: Subset<T, ResumeEventAggregateArgs>): Prisma.PrismaPromise<GetResumeEventAggregateType<T>>

    /**
     * Group by ResumeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeEventGroupByArgs['orderBy'] }
        : { orderBy?: ResumeEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeEvent model
   */
  readonly fields: ResumeEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumeEvent model
   */
  interface ResumeEventFieldRefs {
    readonly id: FieldRef<"ResumeEvent", 'String'>
    readonly userId: FieldRef<"ResumeEvent", 'String'>
    readonly resumeId: FieldRef<"ResumeEvent", 'String'>
    readonly eventType: FieldRef<"ResumeEvent", 'String'>
    readonly resumeText: FieldRef<"ResumeEvent", 'String'>
    readonly jobDescription: FieldRef<"ResumeEvent", 'String'>
    readonly metadata: FieldRef<"ResumeEvent", 'Json'>
    readonly createdAt: FieldRef<"ResumeEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResumeEvent findUnique
   */
  export type ResumeEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * Filter, which ResumeEvent to fetch.
     */
    where: ResumeEventWhereUniqueInput
  }

  /**
   * ResumeEvent findUniqueOrThrow
   */
  export type ResumeEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * Filter, which ResumeEvent to fetch.
     */
    where: ResumeEventWhereUniqueInput
  }

  /**
   * ResumeEvent findFirst
   */
  export type ResumeEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * Filter, which ResumeEvent to fetch.
     */
    where?: ResumeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeEvents to fetch.
     */
    orderBy?: ResumeEventOrderByWithRelationInput | ResumeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeEvents.
     */
    cursor?: ResumeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeEvents.
     */
    distinct?: ResumeEventScalarFieldEnum | ResumeEventScalarFieldEnum[]
  }

  /**
   * ResumeEvent findFirstOrThrow
   */
  export type ResumeEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * Filter, which ResumeEvent to fetch.
     */
    where?: ResumeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeEvents to fetch.
     */
    orderBy?: ResumeEventOrderByWithRelationInput | ResumeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeEvents.
     */
    cursor?: ResumeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeEvents.
     */
    distinct?: ResumeEventScalarFieldEnum | ResumeEventScalarFieldEnum[]
  }

  /**
   * ResumeEvent findMany
   */
  export type ResumeEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * Filter, which ResumeEvents to fetch.
     */
    where?: ResumeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeEvents to fetch.
     */
    orderBy?: ResumeEventOrderByWithRelationInput | ResumeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeEvents.
     */
    cursor?: ResumeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeEvents.
     */
    skip?: number
    distinct?: ResumeEventScalarFieldEnum | ResumeEventScalarFieldEnum[]
  }

  /**
   * ResumeEvent create
   */
  export type ResumeEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * The data needed to create a ResumeEvent.
     */
    data: XOR<ResumeEventCreateInput, ResumeEventUncheckedCreateInput>
  }

  /**
   * ResumeEvent createMany
   */
  export type ResumeEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeEvents.
     */
    data: ResumeEventCreateManyInput | ResumeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeEvent createManyAndReturn
   */
  export type ResumeEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * The data used to create many ResumeEvents.
     */
    data: ResumeEventCreateManyInput | ResumeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeEvent update
   */
  export type ResumeEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * The data needed to update a ResumeEvent.
     */
    data: XOR<ResumeEventUpdateInput, ResumeEventUncheckedUpdateInput>
    /**
     * Choose, which ResumeEvent to update.
     */
    where: ResumeEventWhereUniqueInput
  }

  /**
   * ResumeEvent updateMany
   */
  export type ResumeEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeEvents.
     */
    data: XOR<ResumeEventUpdateManyMutationInput, ResumeEventUncheckedUpdateManyInput>
    /**
     * Filter which ResumeEvents to update
     */
    where?: ResumeEventWhereInput
    /**
     * Limit how many ResumeEvents to update.
     */
    limit?: number
  }

  /**
   * ResumeEvent updateManyAndReturn
   */
  export type ResumeEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * The data used to update ResumeEvents.
     */
    data: XOR<ResumeEventUpdateManyMutationInput, ResumeEventUncheckedUpdateManyInput>
    /**
     * Filter which ResumeEvents to update
     */
    where?: ResumeEventWhereInput
    /**
     * Limit how many ResumeEvents to update.
     */
    limit?: number
  }

  /**
   * ResumeEvent upsert
   */
  export type ResumeEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * The filter to search for the ResumeEvent to update in case it exists.
     */
    where: ResumeEventWhereUniqueInput
    /**
     * In case the ResumeEvent found by the `where` argument doesn't exist, create a new ResumeEvent with this data.
     */
    create: XOR<ResumeEventCreateInput, ResumeEventUncheckedCreateInput>
    /**
     * In case the ResumeEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeEventUpdateInput, ResumeEventUncheckedUpdateInput>
  }

  /**
   * ResumeEvent delete
   */
  export type ResumeEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
    /**
     * Filter which ResumeEvent to delete.
     */
    where: ResumeEventWhereUniqueInput
  }

  /**
   * ResumeEvent deleteMany
   */
  export type ResumeEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeEvents to delete
     */
    where?: ResumeEventWhereInput
    /**
     * Limit how many ResumeEvents to delete.
     */
    limit?: number
  }

  /**
   * ResumeEvent without action
   */
  export type ResumeEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeEvent
     */
    select?: ResumeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeEvent
     */
    omit?: ResumeEventOmit<ExtArgs> | null
  }


  /**
   * Model AnalyticsEvent
   */

  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    createdAt: Date | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    createdAt: Date | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    createdAt?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    createdAt?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithAggregationInput | AnalyticsEventOrderByWithAggregationInput[]
    by: AnalyticsEventScalarFieldEnum[] | AnalyticsEventScalarFieldEnum
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type AnalyticsEventGroupByOutputType = {
    id: string
    userId: string | null
    eventType: string
    metadata: JsonValue | null
    createdAt: Date
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AnalyticsEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "eventType" | "metadata" | "createdAt", ExtArgs["result"]["analyticsEvent"]>

  export type $AnalyticsEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      eventType: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["analyticsEvent"]>
    composites: {}
  }

  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEventFindUniqueArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEventFindFirstArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEventFindManyArgs>(args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEventCreateArgs>(args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsEvents.
     * @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEventCreateManyArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEvents and returns the data saved in the database.
     * @param {AnalyticsEventCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEventDeleteArgs>(args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEventUpdateArgs>(args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEventDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEventUpdateManyArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents and returns the data updated in the database.
     * @param {AnalyticsEventUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsEvents.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEventUpsertArgs>(args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEvent model
   */
  readonly fields: AnalyticsEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEvent model
   */
  interface AnalyticsEventFieldRefs {
    readonly id: FieldRef<"AnalyticsEvent", 'String'>
    readonly userId: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventType: FieldRef<"AnalyticsEvent", 'String'>
    readonly metadata: FieldRef<"AnalyticsEvent", 'Json'>
    readonly createdAt: FieldRef<"AnalyticsEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEvent findUnique
   */
  export type AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findFirst
   */
  export type AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }

  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent createManyAndReturn
   */
  export type AnalyticsEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent updateManyAndReturn
   */
  export type AnalyticsEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }

  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
  }


  /**
   * Model TailoringAnalytics
   */

  export type AggregateTailoringAnalytics = {
    _count: TailoringAnalyticsCountAggregateOutputType | null
    _avg: TailoringAnalyticsAvgAggregateOutputType | null
    _sum: TailoringAnalyticsSumAggregateOutputType | null
    _min: TailoringAnalyticsMinAggregateOutputType | null
    _max: TailoringAnalyticsMaxAggregateOutputType | null
  }

  export type TailoringAnalyticsAvgAggregateOutputType = {
    iterations: number | null
    atsScore: number | null
    jdScore: number | null
  }

  export type TailoringAnalyticsSumAggregateOutputType = {
    iterations: number | null
    atsScore: number | null
    jdScore: number | null
  }

  export type TailoringAnalyticsMinAggregateOutputType = {
    id: string | null
    resumeId: string | null
    userId: string | null
    tailoringMode: string | null
    iterations: number | null
    atsScore: number | null
    jdScore: number | null
    goldenPassed: boolean | null
    isRefinement: boolean | null
    createdAt: Date | null
    modifiedSections: string | null
  }

  export type TailoringAnalyticsMaxAggregateOutputType = {
    id: string | null
    resumeId: string | null
    userId: string | null
    tailoringMode: string | null
    iterations: number | null
    atsScore: number | null
    jdScore: number | null
    goldenPassed: boolean | null
    isRefinement: boolean | null
    createdAt: Date | null
    modifiedSections: string | null
  }

  export type TailoringAnalyticsCountAggregateOutputType = {
    id: number
    resumeId: number
    userId: number
    tailoringMode: number
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: number
    isRefinement: number
    createdAt: number
    modifiedSections: number
    _all: number
  }


  export type TailoringAnalyticsAvgAggregateInputType = {
    iterations?: true
    atsScore?: true
    jdScore?: true
  }

  export type TailoringAnalyticsSumAggregateInputType = {
    iterations?: true
    atsScore?: true
    jdScore?: true
  }

  export type TailoringAnalyticsMinAggregateInputType = {
    id?: true
    resumeId?: true
    userId?: true
    tailoringMode?: true
    iterations?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    isRefinement?: true
    createdAt?: true
    modifiedSections?: true
  }

  export type TailoringAnalyticsMaxAggregateInputType = {
    id?: true
    resumeId?: true
    userId?: true
    tailoringMode?: true
    iterations?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    isRefinement?: true
    createdAt?: true
    modifiedSections?: true
  }

  export type TailoringAnalyticsCountAggregateInputType = {
    id?: true
    resumeId?: true
    userId?: true
    tailoringMode?: true
    iterations?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    isRefinement?: true
    createdAt?: true
    modifiedSections?: true
    _all?: true
  }

  export type TailoringAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailoringAnalytics to aggregate.
     */
    where?: TailoringAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringAnalytics to fetch.
     */
    orderBy?: TailoringAnalyticsOrderByWithRelationInput | TailoringAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TailoringAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TailoringAnalytics
    **/
    _count?: true | TailoringAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TailoringAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TailoringAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TailoringAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TailoringAnalyticsMaxAggregateInputType
  }

  export type GetTailoringAnalyticsAggregateType<T extends TailoringAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateTailoringAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTailoringAnalytics[P]>
      : GetScalarType<T[P], AggregateTailoringAnalytics[P]>
  }




  export type TailoringAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringAnalyticsWhereInput
    orderBy?: TailoringAnalyticsOrderByWithAggregationInput | TailoringAnalyticsOrderByWithAggregationInput[]
    by: TailoringAnalyticsScalarFieldEnum[] | TailoringAnalyticsScalarFieldEnum
    having?: TailoringAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TailoringAnalyticsCountAggregateInputType | true
    _avg?: TailoringAnalyticsAvgAggregateInputType
    _sum?: TailoringAnalyticsSumAggregateInputType
    _min?: TailoringAnalyticsMinAggregateInputType
    _max?: TailoringAnalyticsMaxAggregateInputType
  }

  export type TailoringAnalyticsGroupByOutputType = {
    id: string
    resumeId: string
    userId: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement: boolean
    createdAt: Date
    modifiedSections: string | null
    _count: TailoringAnalyticsCountAggregateOutputType | null
    _avg: TailoringAnalyticsAvgAggregateOutputType | null
    _sum: TailoringAnalyticsSumAggregateOutputType | null
    _min: TailoringAnalyticsMinAggregateOutputType | null
    _max: TailoringAnalyticsMaxAggregateOutputType | null
  }

  type GetTailoringAnalyticsGroupByPayload<T extends TailoringAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TailoringAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TailoringAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TailoringAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], TailoringAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type TailoringAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    userId?: boolean
    tailoringMode?: boolean
    iterations?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    isRefinement?: boolean
    createdAt?: boolean
    modifiedSections?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringAnalytics"]>

  export type TailoringAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    userId?: boolean
    tailoringMode?: boolean
    iterations?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    isRefinement?: boolean
    createdAt?: boolean
    modifiedSections?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringAnalytics"]>

  export type TailoringAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    userId?: boolean
    tailoringMode?: boolean
    iterations?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    isRefinement?: boolean
    createdAt?: boolean
    modifiedSections?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringAnalytics"]>

  export type TailoringAnalyticsSelectScalar = {
    id?: boolean
    resumeId?: boolean
    userId?: boolean
    tailoringMode?: boolean
    iterations?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    isRefinement?: boolean
    createdAt?: boolean
    modifiedSections?: boolean
  }

  export type TailoringAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resumeId" | "userId" | "tailoringMode" | "iterations" | "atsScore" | "jdScore" | "goldenPassed" | "isRefinement" | "createdAt" | "modifiedSections", ExtArgs["result"]["tailoringAnalytics"]>
  export type TailoringAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type TailoringAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type TailoringAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $TailoringAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TailoringAnalytics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resumeId: string
      userId: string
      tailoringMode: string
      iterations: number
      atsScore: number
      jdScore: number
      goldenPassed: boolean
      isRefinement: boolean
      createdAt: Date
      modifiedSections: string | null
    }, ExtArgs["result"]["tailoringAnalytics"]>
    composites: {}
  }

  type TailoringAnalyticsGetPayload<S extends boolean | null | undefined | TailoringAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$TailoringAnalyticsPayload, S>

  type TailoringAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TailoringAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TailoringAnalyticsCountAggregateInputType | true
    }

  export interface TailoringAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TailoringAnalytics'], meta: { name: 'TailoringAnalytics' } }
    /**
     * Find zero or one TailoringAnalytics that matches the filter.
     * @param {TailoringAnalyticsFindUniqueArgs} args - Arguments to find a TailoringAnalytics
     * @example
     * // Get one TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TailoringAnalyticsFindUniqueArgs>(args: SelectSubset<T, TailoringAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__TailoringAnalyticsClient<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TailoringAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TailoringAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a TailoringAnalytics
     * @example
     * // Get one TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TailoringAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, TailoringAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TailoringAnalyticsClient<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TailoringAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAnalyticsFindFirstArgs} args - Arguments to find a TailoringAnalytics
     * @example
     * // Get one TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TailoringAnalyticsFindFirstArgs>(args?: SelectSubset<T, TailoringAnalyticsFindFirstArgs<ExtArgs>>): Prisma__TailoringAnalyticsClient<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TailoringAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAnalyticsFindFirstOrThrowArgs} args - Arguments to find a TailoringAnalytics
     * @example
     * // Get one TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TailoringAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, TailoringAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TailoringAnalyticsClient<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TailoringAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.findMany()
     * 
     * // Get first 10 TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tailoringAnalyticsWithIdOnly = await prisma.tailoringAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TailoringAnalyticsFindManyArgs>(args?: SelectSubset<T, TailoringAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TailoringAnalytics.
     * @param {TailoringAnalyticsCreateArgs} args - Arguments to create a TailoringAnalytics.
     * @example
     * // Create one TailoringAnalytics
     * const TailoringAnalytics = await prisma.tailoringAnalytics.create({
     *   data: {
     *     // ... data to create a TailoringAnalytics
     *   }
     * })
     * 
     */
    create<T extends TailoringAnalyticsCreateArgs>(args: SelectSubset<T, TailoringAnalyticsCreateArgs<ExtArgs>>): Prisma__TailoringAnalyticsClient<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TailoringAnalytics.
     * @param {TailoringAnalyticsCreateManyArgs} args - Arguments to create many TailoringAnalytics.
     * @example
     * // Create many TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TailoringAnalyticsCreateManyArgs>(args?: SelectSubset<T, TailoringAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TailoringAnalytics and returns the data saved in the database.
     * @param {TailoringAnalyticsCreateManyAndReturnArgs} args - Arguments to create many TailoringAnalytics.
     * @example
     * // Create many TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TailoringAnalytics and only return the `id`
     * const tailoringAnalyticsWithIdOnly = await prisma.tailoringAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TailoringAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, TailoringAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TailoringAnalytics.
     * @param {TailoringAnalyticsDeleteArgs} args - Arguments to delete one TailoringAnalytics.
     * @example
     * // Delete one TailoringAnalytics
     * const TailoringAnalytics = await prisma.tailoringAnalytics.delete({
     *   where: {
     *     // ... filter to delete one TailoringAnalytics
     *   }
     * })
     * 
     */
    delete<T extends TailoringAnalyticsDeleteArgs>(args: SelectSubset<T, TailoringAnalyticsDeleteArgs<ExtArgs>>): Prisma__TailoringAnalyticsClient<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TailoringAnalytics.
     * @param {TailoringAnalyticsUpdateArgs} args - Arguments to update one TailoringAnalytics.
     * @example
     * // Update one TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TailoringAnalyticsUpdateArgs>(args: SelectSubset<T, TailoringAnalyticsUpdateArgs<ExtArgs>>): Prisma__TailoringAnalyticsClient<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TailoringAnalytics.
     * @param {TailoringAnalyticsDeleteManyArgs} args - Arguments to filter TailoringAnalytics to delete.
     * @example
     * // Delete a few TailoringAnalytics
     * const { count } = await prisma.tailoringAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TailoringAnalyticsDeleteManyArgs>(args?: SelectSubset<T, TailoringAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailoringAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TailoringAnalyticsUpdateManyArgs>(args: SelectSubset<T, TailoringAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailoringAnalytics and returns the data updated in the database.
     * @param {TailoringAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many TailoringAnalytics.
     * @example
     * // Update many TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TailoringAnalytics and only return the `id`
     * const tailoringAnalyticsWithIdOnly = await prisma.tailoringAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TailoringAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, TailoringAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TailoringAnalytics.
     * @param {TailoringAnalyticsUpsertArgs} args - Arguments to update or create a TailoringAnalytics.
     * @example
     * // Update or create a TailoringAnalytics
     * const tailoringAnalytics = await prisma.tailoringAnalytics.upsert({
     *   create: {
     *     // ... data to create a TailoringAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TailoringAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends TailoringAnalyticsUpsertArgs>(args: SelectSubset<T, TailoringAnalyticsUpsertArgs<ExtArgs>>): Prisma__TailoringAnalyticsClient<$Result.GetResult<Prisma.$TailoringAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TailoringAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAnalyticsCountArgs} args - Arguments to filter TailoringAnalytics to count.
     * @example
     * // Count the number of TailoringAnalytics
     * const count = await prisma.tailoringAnalytics.count({
     *   where: {
     *     // ... the filter for the TailoringAnalytics we want to count
     *   }
     * })
    **/
    count<T extends TailoringAnalyticsCountArgs>(
      args?: Subset<T, TailoringAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TailoringAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TailoringAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TailoringAnalyticsAggregateArgs>(args: Subset<T, TailoringAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetTailoringAnalyticsAggregateType<T>>

    /**
     * Group by TailoringAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TailoringAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TailoringAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: TailoringAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TailoringAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTailoringAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TailoringAnalytics model
   */
  readonly fields: TailoringAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TailoringAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TailoringAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TailoringAnalytics model
   */
  interface TailoringAnalyticsFieldRefs {
    readonly id: FieldRef<"TailoringAnalytics", 'String'>
    readonly resumeId: FieldRef<"TailoringAnalytics", 'String'>
    readonly userId: FieldRef<"TailoringAnalytics", 'String'>
    readonly tailoringMode: FieldRef<"TailoringAnalytics", 'String'>
    readonly iterations: FieldRef<"TailoringAnalytics", 'Int'>
    readonly atsScore: FieldRef<"TailoringAnalytics", 'Int'>
    readonly jdScore: FieldRef<"TailoringAnalytics", 'Int'>
    readonly goldenPassed: FieldRef<"TailoringAnalytics", 'Boolean'>
    readonly isRefinement: FieldRef<"TailoringAnalytics", 'Boolean'>
    readonly createdAt: FieldRef<"TailoringAnalytics", 'DateTime'>
    readonly modifiedSections: FieldRef<"TailoringAnalytics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TailoringAnalytics findUnique
   */
  export type TailoringAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAnalytics to fetch.
     */
    where: TailoringAnalyticsWhereUniqueInput
  }

  /**
   * TailoringAnalytics findUniqueOrThrow
   */
  export type TailoringAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAnalytics to fetch.
     */
    where: TailoringAnalyticsWhereUniqueInput
  }

  /**
   * TailoringAnalytics findFirst
   */
  export type TailoringAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAnalytics to fetch.
     */
    where?: TailoringAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringAnalytics to fetch.
     */
    orderBy?: TailoringAnalyticsOrderByWithRelationInput | TailoringAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailoringAnalytics.
     */
    cursor?: TailoringAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailoringAnalytics.
     */
    distinct?: TailoringAnalyticsScalarFieldEnum | TailoringAnalyticsScalarFieldEnum[]
  }

  /**
   * TailoringAnalytics findFirstOrThrow
   */
  export type TailoringAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAnalytics to fetch.
     */
    where?: TailoringAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringAnalytics to fetch.
     */
    orderBy?: TailoringAnalyticsOrderByWithRelationInput | TailoringAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailoringAnalytics.
     */
    cursor?: TailoringAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailoringAnalytics.
     */
    distinct?: TailoringAnalyticsScalarFieldEnum | TailoringAnalyticsScalarFieldEnum[]
  }

  /**
   * TailoringAnalytics findMany
   */
  export type TailoringAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAnalytics to fetch.
     */
    where?: TailoringAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringAnalytics to fetch.
     */
    orderBy?: TailoringAnalyticsOrderByWithRelationInput | TailoringAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TailoringAnalytics.
     */
    cursor?: TailoringAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringAnalytics.
     */
    skip?: number
    distinct?: TailoringAnalyticsScalarFieldEnum | TailoringAnalyticsScalarFieldEnum[]
  }

  /**
   * TailoringAnalytics create
   */
  export type TailoringAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a TailoringAnalytics.
     */
    data: XOR<TailoringAnalyticsCreateInput, TailoringAnalyticsUncheckedCreateInput>
  }

  /**
   * TailoringAnalytics createMany
   */
  export type TailoringAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TailoringAnalytics.
     */
    data: TailoringAnalyticsCreateManyInput | TailoringAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TailoringAnalytics createManyAndReturn
   */
  export type TailoringAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many TailoringAnalytics.
     */
    data: TailoringAnalyticsCreateManyInput | TailoringAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailoringAnalytics update
   */
  export type TailoringAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a TailoringAnalytics.
     */
    data: XOR<TailoringAnalyticsUpdateInput, TailoringAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which TailoringAnalytics to update.
     */
    where: TailoringAnalyticsWhereUniqueInput
  }

  /**
   * TailoringAnalytics updateMany
   */
  export type TailoringAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TailoringAnalytics.
     */
    data: XOR<TailoringAnalyticsUpdateManyMutationInput, TailoringAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which TailoringAnalytics to update
     */
    where?: TailoringAnalyticsWhereInput
    /**
     * Limit how many TailoringAnalytics to update.
     */
    limit?: number
  }

  /**
   * TailoringAnalytics updateManyAndReturn
   */
  export type TailoringAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update TailoringAnalytics.
     */
    data: XOR<TailoringAnalyticsUpdateManyMutationInput, TailoringAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which TailoringAnalytics to update
     */
    where?: TailoringAnalyticsWhereInput
    /**
     * Limit how many TailoringAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailoringAnalytics upsert
   */
  export type TailoringAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the TailoringAnalytics to update in case it exists.
     */
    where: TailoringAnalyticsWhereUniqueInput
    /**
     * In case the TailoringAnalytics found by the `where` argument doesn't exist, create a new TailoringAnalytics with this data.
     */
    create: XOR<TailoringAnalyticsCreateInput, TailoringAnalyticsUncheckedCreateInput>
    /**
     * In case the TailoringAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TailoringAnalyticsUpdateInput, TailoringAnalyticsUncheckedUpdateInput>
  }

  /**
   * TailoringAnalytics delete
   */
  export type TailoringAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which TailoringAnalytics to delete.
     */
    where: TailoringAnalyticsWhereUniqueInput
  }

  /**
   * TailoringAnalytics deleteMany
   */
  export type TailoringAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailoringAnalytics to delete
     */
    where?: TailoringAnalyticsWhereInput
    /**
     * Limit how many TailoringAnalytics to delete.
     */
    limit?: number
  }

  /**
   * TailoringAnalytics without action
   */
  export type TailoringAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAnalytics
     */
    select?: TailoringAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAnalytics
     */
    omit?: TailoringAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model ScrubbedResume
   */

  export type AggregateScrubbedResume = {
    _count: ScrubbedResumeCountAggregateOutputType | null
    _min: ScrubbedResumeMinAggregateOutputType | null
    _max: ScrubbedResumeMaxAggregateOutputType | null
  }

  export type ScrubbedResumeMinAggregateOutputType = {
    id: string | null
    resumeId: string | null
    cleanText: string | null
    createdAt: Date | null
  }

  export type ScrubbedResumeMaxAggregateOutputType = {
    id: string | null
    resumeId: string | null
    cleanText: string | null
    createdAt: Date | null
  }

  export type ScrubbedResumeCountAggregateOutputType = {
    id: number
    resumeId: number
    cleanText: number
    createdAt: number
    _all: number
  }


  export type ScrubbedResumeMinAggregateInputType = {
    id?: true
    resumeId?: true
    cleanText?: true
    createdAt?: true
  }

  export type ScrubbedResumeMaxAggregateInputType = {
    id?: true
    resumeId?: true
    cleanText?: true
    createdAt?: true
  }

  export type ScrubbedResumeCountAggregateInputType = {
    id?: true
    resumeId?: true
    cleanText?: true
    createdAt?: true
    _all?: true
  }

  export type ScrubbedResumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScrubbedResume to aggregate.
     */
    where?: ScrubbedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScrubbedResumes to fetch.
     */
    orderBy?: ScrubbedResumeOrderByWithRelationInput | ScrubbedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScrubbedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScrubbedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScrubbedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScrubbedResumes
    **/
    _count?: true | ScrubbedResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScrubbedResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScrubbedResumeMaxAggregateInputType
  }

  export type GetScrubbedResumeAggregateType<T extends ScrubbedResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateScrubbedResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScrubbedResume[P]>
      : GetScalarType<T[P], AggregateScrubbedResume[P]>
  }




  export type ScrubbedResumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScrubbedResumeWhereInput
    orderBy?: ScrubbedResumeOrderByWithAggregationInput | ScrubbedResumeOrderByWithAggregationInput[]
    by: ScrubbedResumeScalarFieldEnum[] | ScrubbedResumeScalarFieldEnum
    having?: ScrubbedResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScrubbedResumeCountAggregateInputType | true
    _min?: ScrubbedResumeMinAggregateInputType
    _max?: ScrubbedResumeMaxAggregateInputType
  }

  export type ScrubbedResumeGroupByOutputType = {
    id: string
    resumeId: string
    cleanText: string
    createdAt: Date
    _count: ScrubbedResumeCountAggregateOutputType | null
    _min: ScrubbedResumeMinAggregateOutputType | null
    _max: ScrubbedResumeMaxAggregateOutputType | null
  }

  type GetScrubbedResumeGroupByPayload<T extends ScrubbedResumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScrubbedResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScrubbedResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScrubbedResumeGroupByOutputType[P]>
            : GetScalarType<T[P], ScrubbedResumeGroupByOutputType[P]>
        }
      >
    >


  export type ScrubbedResumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    cleanText?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scrubbedResume"]>

  export type ScrubbedResumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    cleanText?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scrubbedResume"]>

  export type ScrubbedResumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    cleanText?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scrubbedResume"]>

  export type ScrubbedResumeSelectScalar = {
    id?: boolean
    resumeId?: boolean
    cleanText?: boolean
    createdAt?: boolean
  }

  export type ScrubbedResumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resumeId" | "cleanText" | "createdAt", ExtArgs["result"]["scrubbedResume"]>
  export type ScrubbedResumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ScrubbedResumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ScrubbedResumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ScrubbedResumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScrubbedResume"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resumeId: string
      cleanText: string
      createdAt: Date
    }, ExtArgs["result"]["scrubbedResume"]>
    composites: {}
  }

  type ScrubbedResumeGetPayload<S extends boolean | null | undefined | ScrubbedResumeDefaultArgs> = $Result.GetResult<Prisma.$ScrubbedResumePayload, S>

  type ScrubbedResumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScrubbedResumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScrubbedResumeCountAggregateInputType | true
    }

  export interface ScrubbedResumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScrubbedResume'], meta: { name: 'ScrubbedResume' } }
    /**
     * Find zero or one ScrubbedResume that matches the filter.
     * @param {ScrubbedResumeFindUniqueArgs} args - Arguments to find a ScrubbedResume
     * @example
     * // Get one ScrubbedResume
     * const scrubbedResume = await prisma.scrubbedResume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScrubbedResumeFindUniqueArgs>(args: SelectSubset<T, ScrubbedResumeFindUniqueArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScrubbedResume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScrubbedResumeFindUniqueOrThrowArgs} args - Arguments to find a ScrubbedResume
     * @example
     * // Get one ScrubbedResume
     * const scrubbedResume = await prisma.scrubbedResume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScrubbedResumeFindUniqueOrThrowArgs>(args: SelectSubset<T, ScrubbedResumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScrubbedResume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrubbedResumeFindFirstArgs} args - Arguments to find a ScrubbedResume
     * @example
     * // Get one ScrubbedResume
     * const scrubbedResume = await prisma.scrubbedResume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScrubbedResumeFindFirstArgs>(args?: SelectSubset<T, ScrubbedResumeFindFirstArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScrubbedResume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrubbedResumeFindFirstOrThrowArgs} args - Arguments to find a ScrubbedResume
     * @example
     * // Get one ScrubbedResume
     * const scrubbedResume = await prisma.scrubbedResume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScrubbedResumeFindFirstOrThrowArgs>(args?: SelectSubset<T, ScrubbedResumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScrubbedResumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrubbedResumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScrubbedResumes
     * const scrubbedResumes = await prisma.scrubbedResume.findMany()
     * 
     * // Get first 10 ScrubbedResumes
     * const scrubbedResumes = await prisma.scrubbedResume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scrubbedResumeWithIdOnly = await prisma.scrubbedResume.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScrubbedResumeFindManyArgs>(args?: SelectSubset<T, ScrubbedResumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScrubbedResume.
     * @param {ScrubbedResumeCreateArgs} args - Arguments to create a ScrubbedResume.
     * @example
     * // Create one ScrubbedResume
     * const ScrubbedResume = await prisma.scrubbedResume.create({
     *   data: {
     *     // ... data to create a ScrubbedResume
     *   }
     * })
     * 
     */
    create<T extends ScrubbedResumeCreateArgs>(args: SelectSubset<T, ScrubbedResumeCreateArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScrubbedResumes.
     * @param {ScrubbedResumeCreateManyArgs} args - Arguments to create many ScrubbedResumes.
     * @example
     * // Create many ScrubbedResumes
     * const scrubbedResume = await prisma.scrubbedResume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScrubbedResumeCreateManyArgs>(args?: SelectSubset<T, ScrubbedResumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScrubbedResumes and returns the data saved in the database.
     * @param {ScrubbedResumeCreateManyAndReturnArgs} args - Arguments to create many ScrubbedResumes.
     * @example
     * // Create many ScrubbedResumes
     * const scrubbedResume = await prisma.scrubbedResume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScrubbedResumes and only return the `id`
     * const scrubbedResumeWithIdOnly = await prisma.scrubbedResume.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScrubbedResumeCreateManyAndReturnArgs>(args?: SelectSubset<T, ScrubbedResumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScrubbedResume.
     * @param {ScrubbedResumeDeleteArgs} args - Arguments to delete one ScrubbedResume.
     * @example
     * // Delete one ScrubbedResume
     * const ScrubbedResume = await prisma.scrubbedResume.delete({
     *   where: {
     *     // ... filter to delete one ScrubbedResume
     *   }
     * })
     * 
     */
    delete<T extends ScrubbedResumeDeleteArgs>(args: SelectSubset<T, ScrubbedResumeDeleteArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScrubbedResume.
     * @param {ScrubbedResumeUpdateArgs} args - Arguments to update one ScrubbedResume.
     * @example
     * // Update one ScrubbedResume
     * const scrubbedResume = await prisma.scrubbedResume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScrubbedResumeUpdateArgs>(args: SelectSubset<T, ScrubbedResumeUpdateArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScrubbedResumes.
     * @param {ScrubbedResumeDeleteManyArgs} args - Arguments to filter ScrubbedResumes to delete.
     * @example
     * // Delete a few ScrubbedResumes
     * const { count } = await prisma.scrubbedResume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScrubbedResumeDeleteManyArgs>(args?: SelectSubset<T, ScrubbedResumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScrubbedResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrubbedResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScrubbedResumes
     * const scrubbedResume = await prisma.scrubbedResume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScrubbedResumeUpdateManyArgs>(args: SelectSubset<T, ScrubbedResumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScrubbedResumes and returns the data updated in the database.
     * @param {ScrubbedResumeUpdateManyAndReturnArgs} args - Arguments to update many ScrubbedResumes.
     * @example
     * // Update many ScrubbedResumes
     * const scrubbedResume = await prisma.scrubbedResume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScrubbedResumes and only return the `id`
     * const scrubbedResumeWithIdOnly = await prisma.scrubbedResume.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScrubbedResumeUpdateManyAndReturnArgs>(args: SelectSubset<T, ScrubbedResumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScrubbedResume.
     * @param {ScrubbedResumeUpsertArgs} args - Arguments to update or create a ScrubbedResume.
     * @example
     * // Update or create a ScrubbedResume
     * const scrubbedResume = await prisma.scrubbedResume.upsert({
     *   create: {
     *     // ... data to create a ScrubbedResume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScrubbedResume we want to update
     *   }
     * })
     */
    upsert<T extends ScrubbedResumeUpsertArgs>(args: SelectSubset<T, ScrubbedResumeUpsertArgs<ExtArgs>>): Prisma__ScrubbedResumeClient<$Result.GetResult<Prisma.$ScrubbedResumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScrubbedResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrubbedResumeCountArgs} args - Arguments to filter ScrubbedResumes to count.
     * @example
     * // Count the number of ScrubbedResumes
     * const count = await prisma.scrubbedResume.count({
     *   where: {
     *     // ... the filter for the ScrubbedResumes we want to count
     *   }
     * })
    **/
    count<T extends ScrubbedResumeCountArgs>(
      args?: Subset<T, ScrubbedResumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScrubbedResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScrubbedResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrubbedResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScrubbedResumeAggregateArgs>(args: Subset<T, ScrubbedResumeAggregateArgs>): Prisma.PrismaPromise<GetScrubbedResumeAggregateType<T>>

    /**
     * Group by ScrubbedResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScrubbedResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScrubbedResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScrubbedResumeGroupByArgs['orderBy'] }
        : { orderBy?: ScrubbedResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScrubbedResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScrubbedResumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScrubbedResume model
   */
  readonly fields: ScrubbedResumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScrubbedResume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScrubbedResumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScrubbedResume model
   */
  interface ScrubbedResumeFieldRefs {
    readonly id: FieldRef<"ScrubbedResume", 'String'>
    readonly resumeId: FieldRef<"ScrubbedResume", 'String'>
    readonly cleanText: FieldRef<"ScrubbedResume", 'String'>
    readonly createdAt: FieldRef<"ScrubbedResume", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScrubbedResume findUnique
   */
  export type ScrubbedResumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ScrubbedResume to fetch.
     */
    where: ScrubbedResumeWhereUniqueInput
  }

  /**
   * ScrubbedResume findUniqueOrThrow
   */
  export type ScrubbedResumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ScrubbedResume to fetch.
     */
    where: ScrubbedResumeWhereUniqueInput
  }

  /**
   * ScrubbedResume findFirst
   */
  export type ScrubbedResumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ScrubbedResume to fetch.
     */
    where?: ScrubbedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScrubbedResumes to fetch.
     */
    orderBy?: ScrubbedResumeOrderByWithRelationInput | ScrubbedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScrubbedResumes.
     */
    cursor?: ScrubbedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScrubbedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScrubbedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScrubbedResumes.
     */
    distinct?: ScrubbedResumeScalarFieldEnum | ScrubbedResumeScalarFieldEnum[]
  }

  /**
   * ScrubbedResume findFirstOrThrow
   */
  export type ScrubbedResumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ScrubbedResume to fetch.
     */
    where?: ScrubbedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScrubbedResumes to fetch.
     */
    orderBy?: ScrubbedResumeOrderByWithRelationInput | ScrubbedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScrubbedResumes.
     */
    cursor?: ScrubbedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScrubbedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScrubbedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScrubbedResumes.
     */
    distinct?: ScrubbedResumeScalarFieldEnum | ScrubbedResumeScalarFieldEnum[]
  }

  /**
   * ScrubbedResume findMany
   */
  export type ScrubbedResumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ScrubbedResumes to fetch.
     */
    where?: ScrubbedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScrubbedResumes to fetch.
     */
    orderBy?: ScrubbedResumeOrderByWithRelationInput | ScrubbedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScrubbedResumes.
     */
    cursor?: ScrubbedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScrubbedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScrubbedResumes.
     */
    skip?: number
    distinct?: ScrubbedResumeScalarFieldEnum | ScrubbedResumeScalarFieldEnum[]
  }

  /**
   * ScrubbedResume create
   */
  export type ScrubbedResumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * The data needed to create a ScrubbedResume.
     */
    data: XOR<ScrubbedResumeCreateInput, ScrubbedResumeUncheckedCreateInput>
  }

  /**
   * ScrubbedResume createMany
   */
  export type ScrubbedResumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScrubbedResumes.
     */
    data: ScrubbedResumeCreateManyInput | ScrubbedResumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScrubbedResume createManyAndReturn
   */
  export type ScrubbedResumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * The data used to create many ScrubbedResumes.
     */
    data: ScrubbedResumeCreateManyInput | ScrubbedResumeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScrubbedResume update
   */
  export type ScrubbedResumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * The data needed to update a ScrubbedResume.
     */
    data: XOR<ScrubbedResumeUpdateInput, ScrubbedResumeUncheckedUpdateInput>
    /**
     * Choose, which ScrubbedResume to update.
     */
    where: ScrubbedResumeWhereUniqueInput
  }

  /**
   * ScrubbedResume updateMany
   */
  export type ScrubbedResumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScrubbedResumes.
     */
    data: XOR<ScrubbedResumeUpdateManyMutationInput, ScrubbedResumeUncheckedUpdateManyInput>
    /**
     * Filter which ScrubbedResumes to update
     */
    where?: ScrubbedResumeWhereInput
    /**
     * Limit how many ScrubbedResumes to update.
     */
    limit?: number
  }

  /**
   * ScrubbedResume updateManyAndReturn
   */
  export type ScrubbedResumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * The data used to update ScrubbedResumes.
     */
    data: XOR<ScrubbedResumeUpdateManyMutationInput, ScrubbedResumeUncheckedUpdateManyInput>
    /**
     * Filter which ScrubbedResumes to update
     */
    where?: ScrubbedResumeWhereInput
    /**
     * Limit how many ScrubbedResumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScrubbedResume upsert
   */
  export type ScrubbedResumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * The filter to search for the ScrubbedResume to update in case it exists.
     */
    where: ScrubbedResumeWhereUniqueInput
    /**
     * In case the ScrubbedResume found by the `where` argument doesn't exist, create a new ScrubbedResume with this data.
     */
    create: XOR<ScrubbedResumeCreateInput, ScrubbedResumeUncheckedCreateInput>
    /**
     * In case the ScrubbedResume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScrubbedResumeUpdateInput, ScrubbedResumeUncheckedUpdateInput>
  }

  /**
   * ScrubbedResume delete
   */
  export type ScrubbedResumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
    /**
     * Filter which ScrubbedResume to delete.
     */
    where: ScrubbedResumeWhereUniqueInput
  }

  /**
   * ScrubbedResume deleteMany
   */
  export type ScrubbedResumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScrubbedResumes to delete
     */
    where?: ScrubbedResumeWhereInput
    /**
     * Limit how many ScrubbedResumes to delete.
     */
    limit?: number
  }

  /**
   * ScrubbedResume without action
   */
  export type ScrubbedResumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScrubbedResume
     */
    select?: ScrubbedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScrubbedResume
     */
    omit?: ScrubbedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScrubbedResumeInclude<ExtArgs> | null
  }


  /**
   * Model PromptArchive
   */

  export type AggregatePromptArchive = {
    _count: PromptArchiveCountAggregateOutputType | null
    _min: PromptArchiveMinAggregateOutputType | null
    _max: PromptArchiveMaxAggregateOutputType | null
  }

  export type PromptArchiveMinAggregateOutputType = {
    id: string | null
    resumeId: string | null
    content: string | null
    response: string | null
    createdAt: Date | null
  }

  export type PromptArchiveMaxAggregateOutputType = {
    id: string | null
    resumeId: string | null
    content: string | null
    response: string | null
    createdAt: Date | null
  }

  export type PromptArchiveCountAggregateOutputType = {
    id: number
    resumeId: number
    content: number
    response: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type PromptArchiveMinAggregateInputType = {
    id?: true
    resumeId?: true
    content?: true
    response?: true
    createdAt?: true
  }

  export type PromptArchiveMaxAggregateInputType = {
    id?: true
    resumeId?: true
    content?: true
    response?: true
    createdAt?: true
  }

  export type PromptArchiveCountAggregateInputType = {
    id?: true
    resumeId?: true
    content?: true
    response?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type PromptArchiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptArchive to aggregate.
     */
    where?: PromptArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptArchives to fetch.
     */
    orderBy?: PromptArchiveOrderByWithRelationInput | PromptArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromptArchives
    **/
    _count?: true | PromptArchiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptArchiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptArchiveMaxAggregateInputType
  }

  export type GetPromptArchiveAggregateType<T extends PromptArchiveAggregateArgs> = {
        [P in keyof T & keyof AggregatePromptArchive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromptArchive[P]>
      : GetScalarType<T[P], AggregatePromptArchive[P]>
  }




  export type PromptArchiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptArchiveWhereInput
    orderBy?: PromptArchiveOrderByWithAggregationInput | PromptArchiveOrderByWithAggregationInput[]
    by: PromptArchiveScalarFieldEnum[] | PromptArchiveScalarFieldEnum
    having?: PromptArchiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptArchiveCountAggregateInputType | true
    _min?: PromptArchiveMinAggregateInputType
    _max?: PromptArchiveMaxAggregateInputType
  }

  export type PromptArchiveGroupByOutputType = {
    id: string
    resumeId: string
    content: string
    response: string
    metadata: JsonValue | null
    createdAt: Date
    _count: PromptArchiveCountAggregateOutputType | null
    _min: PromptArchiveMinAggregateOutputType | null
    _max: PromptArchiveMaxAggregateOutputType | null
  }

  type GetPromptArchiveGroupByPayload<T extends PromptArchiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptArchiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptArchiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptArchiveGroupByOutputType[P]>
            : GetScalarType<T[P], PromptArchiveGroupByOutputType[P]>
        }
      >
    >


  export type PromptArchiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    content?: boolean
    response?: boolean
    metadata?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promptArchive"]>

  export type PromptArchiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    content?: boolean
    response?: boolean
    metadata?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promptArchive"]>

  export type PromptArchiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    content?: boolean
    response?: boolean
    metadata?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promptArchive"]>

  export type PromptArchiveSelectScalar = {
    id?: boolean
    resumeId?: boolean
    content?: boolean
    response?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type PromptArchiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resumeId" | "content" | "response" | "metadata" | "createdAt", ExtArgs["result"]["promptArchive"]>
  export type PromptArchiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type PromptArchiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type PromptArchiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $PromptArchivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromptArchive"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resumeId: string
      content: string
      response: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["promptArchive"]>
    composites: {}
  }

  type PromptArchiveGetPayload<S extends boolean | null | undefined | PromptArchiveDefaultArgs> = $Result.GetResult<Prisma.$PromptArchivePayload, S>

  type PromptArchiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromptArchiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromptArchiveCountAggregateInputType | true
    }

  export interface PromptArchiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromptArchive'], meta: { name: 'PromptArchive' } }
    /**
     * Find zero or one PromptArchive that matches the filter.
     * @param {PromptArchiveFindUniqueArgs} args - Arguments to find a PromptArchive
     * @example
     * // Get one PromptArchive
     * const promptArchive = await prisma.promptArchive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptArchiveFindUniqueArgs>(args: SelectSubset<T, PromptArchiveFindUniqueArgs<ExtArgs>>): Prisma__PromptArchiveClient<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromptArchive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromptArchiveFindUniqueOrThrowArgs} args - Arguments to find a PromptArchive
     * @example
     * // Get one PromptArchive
     * const promptArchive = await prisma.promptArchive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptArchiveFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptArchiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptArchiveClient<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromptArchive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptArchiveFindFirstArgs} args - Arguments to find a PromptArchive
     * @example
     * // Get one PromptArchive
     * const promptArchive = await prisma.promptArchive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptArchiveFindFirstArgs>(args?: SelectSubset<T, PromptArchiveFindFirstArgs<ExtArgs>>): Prisma__PromptArchiveClient<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromptArchive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptArchiveFindFirstOrThrowArgs} args - Arguments to find a PromptArchive
     * @example
     * // Get one PromptArchive
     * const promptArchive = await prisma.promptArchive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptArchiveFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptArchiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptArchiveClient<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromptArchives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptArchiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromptArchives
     * const promptArchives = await prisma.promptArchive.findMany()
     * 
     * // Get first 10 PromptArchives
     * const promptArchives = await prisma.promptArchive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptArchiveWithIdOnly = await prisma.promptArchive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptArchiveFindManyArgs>(args?: SelectSubset<T, PromptArchiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromptArchive.
     * @param {PromptArchiveCreateArgs} args - Arguments to create a PromptArchive.
     * @example
     * // Create one PromptArchive
     * const PromptArchive = await prisma.promptArchive.create({
     *   data: {
     *     // ... data to create a PromptArchive
     *   }
     * })
     * 
     */
    create<T extends PromptArchiveCreateArgs>(args: SelectSubset<T, PromptArchiveCreateArgs<ExtArgs>>): Prisma__PromptArchiveClient<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromptArchives.
     * @param {PromptArchiveCreateManyArgs} args - Arguments to create many PromptArchives.
     * @example
     * // Create many PromptArchives
     * const promptArchive = await prisma.promptArchive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptArchiveCreateManyArgs>(args?: SelectSubset<T, PromptArchiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromptArchives and returns the data saved in the database.
     * @param {PromptArchiveCreateManyAndReturnArgs} args - Arguments to create many PromptArchives.
     * @example
     * // Create many PromptArchives
     * const promptArchive = await prisma.promptArchive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromptArchives and only return the `id`
     * const promptArchiveWithIdOnly = await prisma.promptArchive.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromptArchiveCreateManyAndReturnArgs>(args?: SelectSubset<T, PromptArchiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromptArchive.
     * @param {PromptArchiveDeleteArgs} args - Arguments to delete one PromptArchive.
     * @example
     * // Delete one PromptArchive
     * const PromptArchive = await prisma.promptArchive.delete({
     *   where: {
     *     // ... filter to delete one PromptArchive
     *   }
     * })
     * 
     */
    delete<T extends PromptArchiveDeleteArgs>(args: SelectSubset<T, PromptArchiveDeleteArgs<ExtArgs>>): Prisma__PromptArchiveClient<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromptArchive.
     * @param {PromptArchiveUpdateArgs} args - Arguments to update one PromptArchive.
     * @example
     * // Update one PromptArchive
     * const promptArchive = await prisma.promptArchive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptArchiveUpdateArgs>(args: SelectSubset<T, PromptArchiveUpdateArgs<ExtArgs>>): Prisma__PromptArchiveClient<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromptArchives.
     * @param {PromptArchiveDeleteManyArgs} args - Arguments to filter PromptArchives to delete.
     * @example
     * // Delete a few PromptArchives
     * const { count } = await prisma.promptArchive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptArchiveDeleteManyArgs>(args?: SelectSubset<T, PromptArchiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptArchiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromptArchives
     * const promptArchive = await prisma.promptArchive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptArchiveUpdateManyArgs>(args: SelectSubset<T, PromptArchiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptArchives and returns the data updated in the database.
     * @param {PromptArchiveUpdateManyAndReturnArgs} args - Arguments to update many PromptArchives.
     * @example
     * // Update many PromptArchives
     * const promptArchive = await prisma.promptArchive.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromptArchives and only return the `id`
     * const promptArchiveWithIdOnly = await prisma.promptArchive.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromptArchiveUpdateManyAndReturnArgs>(args: SelectSubset<T, PromptArchiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromptArchive.
     * @param {PromptArchiveUpsertArgs} args - Arguments to update or create a PromptArchive.
     * @example
     * // Update or create a PromptArchive
     * const promptArchive = await prisma.promptArchive.upsert({
     *   create: {
     *     // ... data to create a PromptArchive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromptArchive we want to update
     *   }
     * })
     */
    upsert<T extends PromptArchiveUpsertArgs>(args: SelectSubset<T, PromptArchiveUpsertArgs<ExtArgs>>): Prisma__PromptArchiveClient<$Result.GetResult<Prisma.$PromptArchivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromptArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptArchiveCountArgs} args - Arguments to filter PromptArchives to count.
     * @example
     * // Count the number of PromptArchives
     * const count = await prisma.promptArchive.count({
     *   where: {
     *     // ... the filter for the PromptArchives we want to count
     *   }
     * })
    **/
    count<T extends PromptArchiveCountArgs>(
      args?: Subset<T, PromptArchiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptArchiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromptArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptArchiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptArchiveAggregateArgs>(args: Subset<T, PromptArchiveAggregateArgs>): Prisma.PrismaPromise<GetPromptArchiveAggregateType<T>>

    /**
     * Group by PromptArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptArchiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptArchiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptArchiveGroupByArgs['orderBy'] }
        : { orderBy?: PromptArchiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptArchiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptArchiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromptArchive model
   */
  readonly fields: PromptArchiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromptArchive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptArchiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromptArchive model
   */
  interface PromptArchiveFieldRefs {
    readonly id: FieldRef<"PromptArchive", 'String'>
    readonly resumeId: FieldRef<"PromptArchive", 'String'>
    readonly content: FieldRef<"PromptArchive", 'String'>
    readonly response: FieldRef<"PromptArchive", 'String'>
    readonly metadata: FieldRef<"PromptArchive", 'Json'>
    readonly createdAt: FieldRef<"PromptArchive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromptArchive findUnique
   */
  export type PromptArchiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * Filter, which PromptArchive to fetch.
     */
    where: PromptArchiveWhereUniqueInput
  }

  /**
   * PromptArchive findUniqueOrThrow
   */
  export type PromptArchiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * Filter, which PromptArchive to fetch.
     */
    where: PromptArchiveWhereUniqueInput
  }

  /**
   * PromptArchive findFirst
   */
  export type PromptArchiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * Filter, which PromptArchive to fetch.
     */
    where?: PromptArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptArchives to fetch.
     */
    orderBy?: PromptArchiveOrderByWithRelationInput | PromptArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptArchives.
     */
    cursor?: PromptArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptArchives.
     */
    distinct?: PromptArchiveScalarFieldEnum | PromptArchiveScalarFieldEnum[]
  }

  /**
   * PromptArchive findFirstOrThrow
   */
  export type PromptArchiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * Filter, which PromptArchive to fetch.
     */
    where?: PromptArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptArchives to fetch.
     */
    orderBy?: PromptArchiveOrderByWithRelationInput | PromptArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptArchives.
     */
    cursor?: PromptArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptArchives.
     */
    distinct?: PromptArchiveScalarFieldEnum | PromptArchiveScalarFieldEnum[]
  }

  /**
   * PromptArchive findMany
   */
  export type PromptArchiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * Filter, which PromptArchives to fetch.
     */
    where?: PromptArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptArchives to fetch.
     */
    orderBy?: PromptArchiveOrderByWithRelationInput | PromptArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromptArchives.
     */
    cursor?: PromptArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptArchives.
     */
    skip?: number
    distinct?: PromptArchiveScalarFieldEnum | PromptArchiveScalarFieldEnum[]
  }

  /**
   * PromptArchive create
   */
  export type PromptArchiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * The data needed to create a PromptArchive.
     */
    data: XOR<PromptArchiveCreateInput, PromptArchiveUncheckedCreateInput>
  }

  /**
   * PromptArchive createMany
   */
  export type PromptArchiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromptArchives.
     */
    data: PromptArchiveCreateManyInput | PromptArchiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromptArchive createManyAndReturn
   */
  export type PromptArchiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * The data used to create many PromptArchives.
     */
    data: PromptArchiveCreateManyInput | PromptArchiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromptArchive update
   */
  export type PromptArchiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * The data needed to update a PromptArchive.
     */
    data: XOR<PromptArchiveUpdateInput, PromptArchiveUncheckedUpdateInput>
    /**
     * Choose, which PromptArchive to update.
     */
    where: PromptArchiveWhereUniqueInput
  }

  /**
   * PromptArchive updateMany
   */
  export type PromptArchiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromptArchives.
     */
    data: XOR<PromptArchiveUpdateManyMutationInput, PromptArchiveUncheckedUpdateManyInput>
    /**
     * Filter which PromptArchives to update
     */
    where?: PromptArchiveWhereInput
    /**
     * Limit how many PromptArchives to update.
     */
    limit?: number
  }

  /**
   * PromptArchive updateManyAndReturn
   */
  export type PromptArchiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * The data used to update PromptArchives.
     */
    data: XOR<PromptArchiveUpdateManyMutationInput, PromptArchiveUncheckedUpdateManyInput>
    /**
     * Filter which PromptArchives to update
     */
    where?: PromptArchiveWhereInput
    /**
     * Limit how many PromptArchives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromptArchive upsert
   */
  export type PromptArchiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * The filter to search for the PromptArchive to update in case it exists.
     */
    where: PromptArchiveWhereUniqueInput
    /**
     * In case the PromptArchive found by the `where` argument doesn't exist, create a new PromptArchive with this data.
     */
    create: XOR<PromptArchiveCreateInput, PromptArchiveUncheckedCreateInput>
    /**
     * In case the PromptArchive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptArchiveUpdateInput, PromptArchiveUncheckedUpdateInput>
  }

  /**
   * PromptArchive delete
   */
  export type PromptArchiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
    /**
     * Filter which PromptArchive to delete.
     */
    where: PromptArchiveWhereUniqueInput
  }

  /**
   * PromptArchive deleteMany
   */
  export type PromptArchiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptArchives to delete
     */
    where?: PromptArchiveWhereInput
    /**
     * Limit how many PromptArchives to delete.
     */
    limit?: number
  }

  /**
   * PromptArchive without action
   */
  export type PromptArchiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptArchive
     */
    select?: PromptArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptArchive
     */
    omit?: PromptArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptArchiveInclude<ExtArgs> | null
  }


  /**
   * Model ResumeInteraction
   */

  export type AggregateResumeInteraction = {
    _count: ResumeInteractionCountAggregateOutputType | null
    _min: ResumeInteractionMinAggregateOutputType | null
    _max: ResumeInteractionMaxAggregateOutputType | null
  }

  export type ResumeInteractionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type ResumeInteractionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type ResumeInteractionCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    action: number
    createdAt: number
    _all: number
  }


  export type ResumeInteractionMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    action?: true
    createdAt?: true
  }

  export type ResumeInteractionMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    action?: true
    createdAt?: true
  }

  export type ResumeInteractionCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    action?: true
    createdAt?: true
    _all?: true
  }

  export type ResumeInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeInteraction to aggregate.
     */
    where?: ResumeInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeInteractions to fetch.
     */
    orderBy?: ResumeInteractionOrderByWithRelationInput | ResumeInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeInteractions
    **/
    _count?: true | ResumeInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeInteractionMaxAggregateInputType
  }

  export type GetResumeInteractionAggregateType<T extends ResumeInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeInteraction[P]>
      : GetScalarType<T[P], AggregateResumeInteraction[P]>
  }




  export type ResumeInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeInteractionWhereInput
    orderBy?: ResumeInteractionOrderByWithAggregationInput | ResumeInteractionOrderByWithAggregationInput[]
    by: ResumeInteractionScalarFieldEnum[] | ResumeInteractionScalarFieldEnum
    having?: ResumeInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeInteractionCountAggregateInputType | true
    _min?: ResumeInteractionMinAggregateInputType
    _max?: ResumeInteractionMaxAggregateInputType
  }

  export type ResumeInteractionGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    action: string
    createdAt: Date
    _count: ResumeInteractionCountAggregateOutputType | null
    _min: ResumeInteractionMinAggregateOutputType | null
    _max: ResumeInteractionMaxAggregateOutputType | null
  }

  type GetResumeInteractionGroupByPayload<T extends ResumeInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeInteractionGroupByOutputType[P]>
        }
      >
    >


  export type ResumeInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    action?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeInteraction"]>

  export type ResumeInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    action?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeInteraction"]>

  export type ResumeInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    action?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeInteraction"]>

  export type ResumeInteractionSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    action?: boolean
    createdAt?: boolean
  }

  export type ResumeInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "action" | "createdAt", ExtArgs["result"]["resumeInteraction"]>
  export type ResumeInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ResumeInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeInteraction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      action: string
      createdAt: Date
    }, ExtArgs["result"]["resumeInteraction"]>
    composites: {}
  }

  type ResumeInteractionGetPayload<S extends boolean | null | undefined | ResumeInteractionDefaultArgs> = $Result.GetResult<Prisma.$ResumeInteractionPayload, S>

  type ResumeInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeInteractionCountAggregateInputType | true
    }

  export interface ResumeInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeInteraction'], meta: { name: 'ResumeInteraction' } }
    /**
     * Find zero or one ResumeInteraction that matches the filter.
     * @param {ResumeInteractionFindUniqueArgs} args - Arguments to find a ResumeInteraction
     * @example
     * // Get one ResumeInteraction
     * const resumeInteraction = await prisma.resumeInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeInteractionFindUniqueArgs>(args: SelectSubset<T, ResumeInteractionFindUniqueArgs<ExtArgs>>): Prisma__ResumeInteractionClient<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResumeInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeInteractionFindUniqueOrThrowArgs} args - Arguments to find a ResumeInteraction
     * @example
     * // Get one ResumeInteraction
     * const resumeInteraction = await prisma.resumeInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeInteractionClient<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeInteractionFindFirstArgs} args - Arguments to find a ResumeInteraction
     * @example
     * // Get one ResumeInteraction
     * const resumeInteraction = await prisma.resumeInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeInteractionFindFirstArgs>(args?: SelectSubset<T, ResumeInteractionFindFirstArgs<ExtArgs>>): Prisma__ResumeInteractionClient<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeInteractionFindFirstOrThrowArgs} args - Arguments to find a ResumeInteraction
     * @example
     * // Get one ResumeInteraction
     * const resumeInteraction = await prisma.resumeInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeInteractionClient<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResumeInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeInteractions
     * const resumeInteractions = await prisma.resumeInteraction.findMany()
     * 
     * // Get first 10 ResumeInteractions
     * const resumeInteractions = await prisma.resumeInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeInteractionWithIdOnly = await prisma.resumeInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeInteractionFindManyArgs>(args?: SelectSubset<T, ResumeInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResumeInteraction.
     * @param {ResumeInteractionCreateArgs} args - Arguments to create a ResumeInteraction.
     * @example
     * // Create one ResumeInteraction
     * const ResumeInteraction = await prisma.resumeInteraction.create({
     *   data: {
     *     // ... data to create a ResumeInteraction
     *   }
     * })
     * 
     */
    create<T extends ResumeInteractionCreateArgs>(args: SelectSubset<T, ResumeInteractionCreateArgs<ExtArgs>>): Prisma__ResumeInteractionClient<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResumeInteractions.
     * @param {ResumeInteractionCreateManyArgs} args - Arguments to create many ResumeInteractions.
     * @example
     * // Create many ResumeInteractions
     * const resumeInteraction = await prisma.resumeInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeInteractionCreateManyArgs>(args?: SelectSubset<T, ResumeInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResumeInteractions and returns the data saved in the database.
     * @param {ResumeInteractionCreateManyAndReturnArgs} args - Arguments to create many ResumeInteractions.
     * @example
     * // Create many ResumeInteractions
     * const resumeInteraction = await prisma.resumeInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResumeInteractions and only return the `id`
     * const resumeInteractionWithIdOnly = await prisma.resumeInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResumeInteraction.
     * @param {ResumeInteractionDeleteArgs} args - Arguments to delete one ResumeInteraction.
     * @example
     * // Delete one ResumeInteraction
     * const ResumeInteraction = await prisma.resumeInteraction.delete({
     *   where: {
     *     // ... filter to delete one ResumeInteraction
     *   }
     * })
     * 
     */
    delete<T extends ResumeInteractionDeleteArgs>(args: SelectSubset<T, ResumeInteractionDeleteArgs<ExtArgs>>): Prisma__ResumeInteractionClient<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResumeInteraction.
     * @param {ResumeInteractionUpdateArgs} args - Arguments to update one ResumeInteraction.
     * @example
     * // Update one ResumeInteraction
     * const resumeInteraction = await prisma.resumeInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeInteractionUpdateArgs>(args: SelectSubset<T, ResumeInteractionUpdateArgs<ExtArgs>>): Prisma__ResumeInteractionClient<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResumeInteractions.
     * @param {ResumeInteractionDeleteManyArgs} args - Arguments to filter ResumeInteractions to delete.
     * @example
     * // Delete a few ResumeInteractions
     * const { count } = await prisma.resumeInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeInteractionDeleteManyArgs>(args?: SelectSubset<T, ResumeInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeInteractions
     * const resumeInteraction = await prisma.resumeInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeInteractionUpdateManyArgs>(args: SelectSubset<T, ResumeInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeInteractions and returns the data updated in the database.
     * @param {ResumeInteractionUpdateManyAndReturnArgs} args - Arguments to update many ResumeInteractions.
     * @example
     * // Update many ResumeInteractions
     * const resumeInteraction = await prisma.resumeInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResumeInteractions and only return the `id`
     * const resumeInteractionWithIdOnly = await prisma.resumeInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResumeInteraction.
     * @param {ResumeInteractionUpsertArgs} args - Arguments to update or create a ResumeInteraction.
     * @example
     * // Update or create a ResumeInteraction
     * const resumeInteraction = await prisma.resumeInteraction.upsert({
     *   create: {
     *     // ... data to create a ResumeInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeInteraction we want to update
     *   }
     * })
     */
    upsert<T extends ResumeInteractionUpsertArgs>(args: SelectSubset<T, ResumeInteractionUpsertArgs<ExtArgs>>): Prisma__ResumeInteractionClient<$Result.GetResult<Prisma.$ResumeInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResumeInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeInteractionCountArgs} args - Arguments to filter ResumeInteractions to count.
     * @example
     * // Count the number of ResumeInteractions
     * const count = await prisma.resumeInteraction.count({
     *   where: {
     *     // ... the filter for the ResumeInteractions we want to count
     *   }
     * })
    **/
    count<T extends ResumeInteractionCountArgs>(
      args?: Subset<T, ResumeInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeInteractionAggregateArgs>(args: Subset<T, ResumeInteractionAggregateArgs>): Prisma.PrismaPromise<GetResumeInteractionAggregateType<T>>

    /**
     * Group by ResumeInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeInteractionGroupByArgs['orderBy'] }
        : { orderBy?: ResumeInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeInteraction model
   */
  readonly fields: ResumeInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumeInteraction model
   */
  interface ResumeInteractionFieldRefs {
    readonly id: FieldRef<"ResumeInteraction", 'String'>
    readonly userId: FieldRef<"ResumeInteraction", 'String'>
    readonly resumeId: FieldRef<"ResumeInteraction", 'String'>
    readonly action: FieldRef<"ResumeInteraction", 'String'>
    readonly createdAt: FieldRef<"ResumeInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResumeInteraction findUnique
   */
  export type ResumeInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ResumeInteraction to fetch.
     */
    where: ResumeInteractionWhereUniqueInput
  }

  /**
   * ResumeInteraction findUniqueOrThrow
   */
  export type ResumeInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ResumeInteraction to fetch.
     */
    where: ResumeInteractionWhereUniqueInput
  }

  /**
   * ResumeInteraction findFirst
   */
  export type ResumeInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ResumeInteraction to fetch.
     */
    where?: ResumeInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeInteractions to fetch.
     */
    orderBy?: ResumeInteractionOrderByWithRelationInput | ResumeInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeInteractions.
     */
    cursor?: ResumeInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeInteractions.
     */
    distinct?: ResumeInteractionScalarFieldEnum | ResumeInteractionScalarFieldEnum[]
  }

  /**
   * ResumeInteraction findFirstOrThrow
   */
  export type ResumeInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ResumeInteraction to fetch.
     */
    where?: ResumeInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeInteractions to fetch.
     */
    orderBy?: ResumeInteractionOrderByWithRelationInput | ResumeInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeInteractions.
     */
    cursor?: ResumeInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeInteractions.
     */
    distinct?: ResumeInteractionScalarFieldEnum | ResumeInteractionScalarFieldEnum[]
  }

  /**
   * ResumeInteraction findMany
   */
  export type ResumeInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ResumeInteractions to fetch.
     */
    where?: ResumeInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeInteractions to fetch.
     */
    orderBy?: ResumeInteractionOrderByWithRelationInput | ResumeInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeInteractions.
     */
    cursor?: ResumeInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeInteractions.
     */
    skip?: number
    distinct?: ResumeInteractionScalarFieldEnum | ResumeInteractionScalarFieldEnum[]
  }

  /**
   * ResumeInteraction create
   */
  export type ResumeInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeInteraction.
     */
    data: XOR<ResumeInteractionCreateInput, ResumeInteractionUncheckedCreateInput>
  }

  /**
   * ResumeInteraction createMany
   */
  export type ResumeInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeInteractions.
     */
    data: ResumeInteractionCreateManyInput | ResumeInteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeInteraction createManyAndReturn
   */
  export type ResumeInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many ResumeInteractions.
     */
    data: ResumeInteractionCreateManyInput | ResumeInteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeInteraction update
   */
  export type ResumeInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeInteraction.
     */
    data: XOR<ResumeInteractionUpdateInput, ResumeInteractionUncheckedUpdateInput>
    /**
     * Choose, which ResumeInteraction to update.
     */
    where: ResumeInteractionWhereUniqueInput
  }

  /**
   * ResumeInteraction updateMany
   */
  export type ResumeInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeInteractions.
     */
    data: XOR<ResumeInteractionUpdateManyMutationInput, ResumeInteractionUncheckedUpdateManyInput>
    /**
     * Filter which ResumeInteractions to update
     */
    where?: ResumeInteractionWhereInput
    /**
     * Limit how many ResumeInteractions to update.
     */
    limit?: number
  }

  /**
   * ResumeInteraction updateManyAndReturn
   */
  export type ResumeInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * The data used to update ResumeInteractions.
     */
    data: XOR<ResumeInteractionUpdateManyMutationInput, ResumeInteractionUncheckedUpdateManyInput>
    /**
     * Filter which ResumeInteractions to update
     */
    where?: ResumeInteractionWhereInput
    /**
     * Limit how many ResumeInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeInteraction upsert
   */
  export type ResumeInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeInteraction to update in case it exists.
     */
    where: ResumeInteractionWhereUniqueInput
    /**
     * In case the ResumeInteraction found by the `where` argument doesn't exist, create a new ResumeInteraction with this data.
     */
    create: XOR<ResumeInteractionCreateInput, ResumeInteractionUncheckedCreateInput>
    /**
     * In case the ResumeInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeInteractionUpdateInput, ResumeInteractionUncheckedUpdateInput>
  }

  /**
   * ResumeInteraction delete
   */
  export type ResumeInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
    /**
     * Filter which ResumeInteraction to delete.
     */
    where: ResumeInteractionWhereUniqueInput
  }

  /**
   * ResumeInteraction deleteMany
   */
  export type ResumeInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeInteractions to delete
     */
    where?: ResumeInteractionWhereInput
    /**
     * Limit how many ResumeInteractions to delete.
     */
    limit?: number
  }

  /**
   * ResumeInteraction without action
   */
  export type ResumeInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeInteraction
     */
    select?: ResumeInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeInteraction
     */
    omit?: ResumeInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInteractionInclude<ExtArgs> | null
  }


  /**
   * Model ResumeTag
   */

  export type AggregateResumeTag = {
    _count: ResumeTagCountAggregateOutputType | null
    _min: ResumeTagMinAggregateOutputType | null
    _max: ResumeTagMaxAggregateOutputType | null
  }

  export type ResumeTagMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    tag: string | null
  }

  export type ResumeTagMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    tag: string | null
  }

  export type ResumeTagCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    tag: number
    _all: number
  }


  export type ResumeTagMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    tag?: true
  }

  export type ResumeTagMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    tag?: true
  }

  export type ResumeTagCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    tag?: true
    _all?: true
  }

  export type ResumeTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeTag to aggregate.
     */
    where?: ResumeTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeTags to fetch.
     */
    orderBy?: ResumeTagOrderByWithRelationInput | ResumeTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeTags
    **/
    _count?: true | ResumeTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeTagMaxAggregateInputType
  }

  export type GetResumeTagAggregateType<T extends ResumeTagAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeTag[P]>
      : GetScalarType<T[P], AggregateResumeTag[P]>
  }




  export type ResumeTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeTagWhereInput
    orderBy?: ResumeTagOrderByWithAggregationInput | ResumeTagOrderByWithAggregationInput[]
    by: ResumeTagScalarFieldEnum[] | ResumeTagScalarFieldEnum
    having?: ResumeTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeTagCountAggregateInputType | true
    _min?: ResumeTagMinAggregateInputType
    _max?: ResumeTagMaxAggregateInputType
  }

  export type ResumeTagGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    tag: string
    _count: ResumeTagCountAggregateOutputType | null
    _min: ResumeTagMinAggregateOutputType | null
    _max: ResumeTagMaxAggregateOutputType | null
  }

  type GetResumeTagGroupByPayload<T extends ResumeTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeTagGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeTagGroupByOutputType[P]>
        }
      >
    >


  export type ResumeTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    tag?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeTag"]>

  export type ResumeTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    tag?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeTag"]>

  export type ResumeTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    tag?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeTag"]>

  export type ResumeTagSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    tag?: boolean
  }

  export type ResumeTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "tag", ExtArgs["result"]["resumeTag"]>
  export type ResumeTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ResumeTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeTag"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      tag: string
    }, ExtArgs["result"]["resumeTag"]>
    composites: {}
  }

  type ResumeTagGetPayload<S extends boolean | null | undefined | ResumeTagDefaultArgs> = $Result.GetResult<Prisma.$ResumeTagPayload, S>

  type ResumeTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeTagCountAggregateInputType | true
    }

  export interface ResumeTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeTag'], meta: { name: 'ResumeTag' } }
    /**
     * Find zero or one ResumeTag that matches the filter.
     * @param {ResumeTagFindUniqueArgs} args - Arguments to find a ResumeTag
     * @example
     * // Get one ResumeTag
     * const resumeTag = await prisma.resumeTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeTagFindUniqueArgs>(args: SelectSubset<T, ResumeTagFindUniqueArgs<ExtArgs>>): Prisma__ResumeTagClient<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResumeTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeTagFindUniqueOrThrowArgs} args - Arguments to find a ResumeTag
     * @example
     * // Get one ResumeTag
     * const resumeTag = await prisma.resumeTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeTagClient<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTagFindFirstArgs} args - Arguments to find a ResumeTag
     * @example
     * // Get one ResumeTag
     * const resumeTag = await prisma.resumeTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeTagFindFirstArgs>(args?: SelectSubset<T, ResumeTagFindFirstArgs<ExtArgs>>): Prisma__ResumeTagClient<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTagFindFirstOrThrowArgs} args - Arguments to find a ResumeTag
     * @example
     * // Get one ResumeTag
     * const resumeTag = await prisma.resumeTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeTagClient<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResumeTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeTags
     * const resumeTags = await prisma.resumeTag.findMany()
     * 
     * // Get first 10 ResumeTags
     * const resumeTags = await prisma.resumeTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeTagWithIdOnly = await prisma.resumeTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeTagFindManyArgs>(args?: SelectSubset<T, ResumeTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResumeTag.
     * @param {ResumeTagCreateArgs} args - Arguments to create a ResumeTag.
     * @example
     * // Create one ResumeTag
     * const ResumeTag = await prisma.resumeTag.create({
     *   data: {
     *     // ... data to create a ResumeTag
     *   }
     * })
     * 
     */
    create<T extends ResumeTagCreateArgs>(args: SelectSubset<T, ResumeTagCreateArgs<ExtArgs>>): Prisma__ResumeTagClient<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResumeTags.
     * @param {ResumeTagCreateManyArgs} args - Arguments to create many ResumeTags.
     * @example
     * // Create many ResumeTags
     * const resumeTag = await prisma.resumeTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeTagCreateManyArgs>(args?: SelectSubset<T, ResumeTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResumeTags and returns the data saved in the database.
     * @param {ResumeTagCreateManyAndReturnArgs} args - Arguments to create many ResumeTags.
     * @example
     * // Create many ResumeTags
     * const resumeTag = await prisma.resumeTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResumeTags and only return the `id`
     * const resumeTagWithIdOnly = await prisma.resumeTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResumeTag.
     * @param {ResumeTagDeleteArgs} args - Arguments to delete one ResumeTag.
     * @example
     * // Delete one ResumeTag
     * const ResumeTag = await prisma.resumeTag.delete({
     *   where: {
     *     // ... filter to delete one ResumeTag
     *   }
     * })
     * 
     */
    delete<T extends ResumeTagDeleteArgs>(args: SelectSubset<T, ResumeTagDeleteArgs<ExtArgs>>): Prisma__ResumeTagClient<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResumeTag.
     * @param {ResumeTagUpdateArgs} args - Arguments to update one ResumeTag.
     * @example
     * // Update one ResumeTag
     * const resumeTag = await prisma.resumeTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeTagUpdateArgs>(args: SelectSubset<T, ResumeTagUpdateArgs<ExtArgs>>): Prisma__ResumeTagClient<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResumeTags.
     * @param {ResumeTagDeleteManyArgs} args - Arguments to filter ResumeTags to delete.
     * @example
     * // Delete a few ResumeTags
     * const { count } = await prisma.resumeTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeTagDeleteManyArgs>(args?: SelectSubset<T, ResumeTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeTags
     * const resumeTag = await prisma.resumeTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeTagUpdateManyArgs>(args: SelectSubset<T, ResumeTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeTags and returns the data updated in the database.
     * @param {ResumeTagUpdateManyAndReturnArgs} args - Arguments to update many ResumeTags.
     * @example
     * // Update many ResumeTags
     * const resumeTag = await prisma.resumeTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResumeTags and only return the `id`
     * const resumeTagWithIdOnly = await prisma.resumeTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResumeTag.
     * @param {ResumeTagUpsertArgs} args - Arguments to update or create a ResumeTag.
     * @example
     * // Update or create a ResumeTag
     * const resumeTag = await prisma.resumeTag.upsert({
     *   create: {
     *     // ... data to create a ResumeTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeTag we want to update
     *   }
     * })
     */
    upsert<T extends ResumeTagUpsertArgs>(args: SelectSubset<T, ResumeTagUpsertArgs<ExtArgs>>): Prisma__ResumeTagClient<$Result.GetResult<Prisma.$ResumeTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResumeTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTagCountArgs} args - Arguments to filter ResumeTags to count.
     * @example
     * // Count the number of ResumeTags
     * const count = await prisma.resumeTag.count({
     *   where: {
     *     // ... the filter for the ResumeTags we want to count
     *   }
     * })
    **/
    count<T extends ResumeTagCountArgs>(
      args?: Subset<T, ResumeTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeTagAggregateArgs>(args: Subset<T, ResumeTagAggregateArgs>): Prisma.PrismaPromise<GetResumeTagAggregateType<T>>

    /**
     * Group by ResumeTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeTagGroupByArgs['orderBy'] }
        : { orderBy?: ResumeTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeTag model
   */
  readonly fields: ResumeTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumeTag model
   */
  interface ResumeTagFieldRefs {
    readonly id: FieldRef<"ResumeTag", 'String'>
    readonly userId: FieldRef<"ResumeTag", 'String'>
    readonly resumeId: FieldRef<"ResumeTag", 'String'>
    readonly tag: FieldRef<"ResumeTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResumeTag findUnique
   */
  export type ResumeTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTag to fetch.
     */
    where: ResumeTagWhereUniqueInput
  }

  /**
   * ResumeTag findUniqueOrThrow
   */
  export type ResumeTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTag to fetch.
     */
    where: ResumeTagWhereUniqueInput
  }

  /**
   * ResumeTag findFirst
   */
  export type ResumeTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTag to fetch.
     */
    where?: ResumeTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeTags to fetch.
     */
    orderBy?: ResumeTagOrderByWithRelationInput | ResumeTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeTags.
     */
    cursor?: ResumeTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeTags.
     */
    distinct?: ResumeTagScalarFieldEnum | ResumeTagScalarFieldEnum[]
  }

  /**
   * ResumeTag findFirstOrThrow
   */
  export type ResumeTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTag to fetch.
     */
    where?: ResumeTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeTags to fetch.
     */
    orderBy?: ResumeTagOrderByWithRelationInput | ResumeTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeTags.
     */
    cursor?: ResumeTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeTags.
     */
    distinct?: ResumeTagScalarFieldEnum | ResumeTagScalarFieldEnum[]
  }

  /**
   * ResumeTag findMany
   */
  export type ResumeTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * Filter, which ResumeTags to fetch.
     */
    where?: ResumeTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeTags to fetch.
     */
    orderBy?: ResumeTagOrderByWithRelationInput | ResumeTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeTags.
     */
    cursor?: ResumeTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeTags.
     */
    skip?: number
    distinct?: ResumeTagScalarFieldEnum | ResumeTagScalarFieldEnum[]
  }

  /**
   * ResumeTag create
   */
  export type ResumeTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeTag.
     */
    data: XOR<ResumeTagCreateInput, ResumeTagUncheckedCreateInput>
  }

  /**
   * ResumeTag createMany
   */
  export type ResumeTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeTags.
     */
    data: ResumeTagCreateManyInput | ResumeTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeTag createManyAndReturn
   */
  export type ResumeTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * The data used to create many ResumeTags.
     */
    data: ResumeTagCreateManyInput | ResumeTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeTag update
   */
  export type ResumeTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeTag.
     */
    data: XOR<ResumeTagUpdateInput, ResumeTagUncheckedUpdateInput>
    /**
     * Choose, which ResumeTag to update.
     */
    where: ResumeTagWhereUniqueInput
  }

  /**
   * ResumeTag updateMany
   */
  export type ResumeTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeTags.
     */
    data: XOR<ResumeTagUpdateManyMutationInput, ResumeTagUncheckedUpdateManyInput>
    /**
     * Filter which ResumeTags to update
     */
    where?: ResumeTagWhereInput
    /**
     * Limit how many ResumeTags to update.
     */
    limit?: number
  }

  /**
   * ResumeTag updateManyAndReturn
   */
  export type ResumeTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * The data used to update ResumeTags.
     */
    data: XOR<ResumeTagUpdateManyMutationInput, ResumeTagUncheckedUpdateManyInput>
    /**
     * Filter which ResumeTags to update
     */
    where?: ResumeTagWhereInput
    /**
     * Limit how many ResumeTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeTag upsert
   */
  export type ResumeTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeTag to update in case it exists.
     */
    where: ResumeTagWhereUniqueInput
    /**
     * In case the ResumeTag found by the `where` argument doesn't exist, create a new ResumeTag with this data.
     */
    create: XOR<ResumeTagCreateInput, ResumeTagUncheckedCreateInput>
    /**
     * In case the ResumeTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeTagUpdateInput, ResumeTagUncheckedUpdateInput>
  }

  /**
   * ResumeTag delete
   */
  export type ResumeTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
    /**
     * Filter which ResumeTag to delete.
     */
    where: ResumeTagWhereUniqueInput
  }

  /**
   * ResumeTag deleteMany
   */
  export type ResumeTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeTags to delete
     */
    where?: ResumeTagWhereInput
    /**
     * Limit how many ResumeTags to delete.
     */
    limit?: number
  }

  /**
   * ResumeTag without action
   */
  export type ResumeTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeTag
     */
    select?: ResumeTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeTag
     */
    omit?: ResumeTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeTagInclude<ExtArgs> | null
  }


  /**
   * Model ResumeMetadata
   */

  export type AggregateResumeMetadata = {
    _count: ResumeMetadataCountAggregateOutputType | null
    _avg: ResumeMetadataAvgAggregateOutputType | null
    _sum: ResumeMetadataSumAggregateOutputType | null
    _min: ResumeMetadataMinAggregateOutputType | null
    _max: ResumeMetadataMaxAggregateOutputType | null
  }

  export type ResumeMetadataAvgAggregateOutputType = {
    iterations: number | null
    atsScore: number | null
    jdScore: number | null
  }

  export type ResumeMetadataSumAggregateOutputType = {
    iterations: number | null
    atsScore: number | null
    jdScore: number | null
  }

  export type ResumeMetadataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    contentSnippet: string | null
    tailoringMode: string | null
    iterations: number | null
    passedRules: boolean | null
    atsScore: number | null
    jdScore: number | null
    createdAt: Date | null
  }

  export type ResumeMetadataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    contentSnippet: string | null
    tailoringMode: string | null
    iterations: number | null
    passedRules: boolean | null
    atsScore: number | null
    jdScore: number | null
    createdAt: Date | null
  }

  export type ResumeMetadataCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    contentSnippet: number
    tailoringMode: number
    iterations: number
    passedRules: number
    atsScore: number
    jdScore: number
    createdAt: number
    _all: number
  }


  export type ResumeMetadataAvgAggregateInputType = {
    iterations?: true
    atsScore?: true
    jdScore?: true
  }

  export type ResumeMetadataSumAggregateInputType = {
    iterations?: true
    atsScore?: true
    jdScore?: true
  }

  export type ResumeMetadataMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    contentSnippet?: true
    tailoringMode?: true
    iterations?: true
    passedRules?: true
    atsScore?: true
    jdScore?: true
    createdAt?: true
  }

  export type ResumeMetadataMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    contentSnippet?: true
    tailoringMode?: true
    iterations?: true
    passedRules?: true
    atsScore?: true
    jdScore?: true
    createdAt?: true
  }

  export type ResumeMetadataCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    contentSnippet?: true
    tailoringMode?: true
    iterations?: true
    passedRules?: true
    atsScore?: true
    jdScore?: true
    createdAt?: true
    _all?: true
  }

  export type ResumeMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeMetadata to aggregate.
     */
    where?: ResumeMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeMetadata to fetch.
     */
    orderBy?: ResumeMetadataOrderByWithRelationInput | ResumeMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeMetadata
    **/
    _count?: true | ResumeMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumeMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumeMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeMetadataMaxAggregateInputType
  }

  export type GetResumeMetadataAggregateType<T extends ResumeMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeMetadata[P]>
      : GetScalarType<T[P], AggregateResumeMetadata[P]>
  }




  export type ResumeMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeMetadataWhereInput
    orderBy?: ResumeMetadataOrderByWithAggregationInput | ResumeMetadataOrderByWithAggregationInput[]
    by: ResumeMetadataScalarFieldEnum[] | ResumeMetadataScalarFieldEnum
    having?: ResumeMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeMetadataCountAggregateInputType | true
    _avg?: ResumeMetadataAvgAggregateInputType
    _sum?: ResumeMetadataSumAggregateInputType
    _min?: ResumeMetadataMinAggregateInputType
    _max?: ResumeMetadataMaxAggregateInputType
  }

  export type ResumeMetadataGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt: Date
    _count: ResumeMetadataCountAggregateOutputType | null
    _avg: ResumeMetadataAvgAggregateOutputType | null
    _sum: ResumeMetadataSumAggregateOutputType | null
    _min: ResumeMetadataMinAggregateOutputType | null
    _max: ResumeMetadataMaxAggregateOutputType | null
  }

  type GetResumeMetadataGroupByPayload<T extends ResumeMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeMetadataGroupByOutputType[P]>
        }
      >
    >


  export type ResumeMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    contentSnippet?: boolean
    tailoringMode?: boolean
    iterations?: boolean
    passedRules?: boolean
    atsScore?: boolean
    jdScore?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeMetadata"]>

  export type ResumeMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    contentSnippet?: boolean
    tailoringMode?: boolean
    iterations?: boolean
    passedRules?: boolean
    atsScore?: boolean
    jdScore?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeMetadata"]>

  export type ResumeMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    contentSnippet?: boolean
    tailoringMode?: boolean
    iterations?: boolean
    passedRules?: boolean
    atsScore?: boolean
    jdScore?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeMetadata"]>

  export type ResumeMetadataSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    contentSnippet?: boolean
    tailoringMode?: boolean
    iterations?: boolean
    passedRules?: boolean
    atsScore?: boolean
    jdScore?: boolean
    createdAt?: boolean
  }

  export type ResumeMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "contentSnippet" | "tailoringMode" | "iterations" | "passedRules" | "atsScore" | "jdScore" | "createdAt", ExtArgs["result"]["resumeMetadata"]>
  export type ResumeMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ResumeMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeMetadata"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      contentSnippet: string
      tailoringMode: string
      iterations: number
      passedRules: boolean
      atsScore: number
      jdScore: number
      createdAt: Date
    }, ExtArgs["result"]["resumeMetadata"]>
    composites: {}
  }

  type ResumeMetadataGetPayload<S extends boolean | null | undefined | ResumeMetadataDefaultArgs> = $Result.GetResult<Prisma.$ResumeMetadataPayload, S>

  type ResumeMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeMetadataCountAggregateInputType | true
    }

  export interface ResumeMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeMetadata'], meta: { name: 'ResumeMetadata' } }
    /**
     * Find zero or one ResumeMetadata that matches the filter.
     * @param {ResumeMetadataFindUniqueArgs} args - Arguments to find a ResumeMetadata
     * @example
     * // Get one ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeMetadataFindUniqueArgs>(args: SelectSubset<T, ResumeMetadataFindUniqueArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResumeMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeMetadataFindUniqueOrThrowArgs} args - Arguments to find a ResumeMetadata
     * @example
     * // Get one ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeMetadataFindFirstArgs} args - Arguments to find a ResumeMetadata
     * @example
     * // Get one ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeMetadataFindFirstArgs>(args?: SelectSubset<T, ResumeMetadataFindFirstArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeMetadataFindFirstOrThrowArgs} args - Arguments to find a ResumeMetadata
     * @example
     * // Get one ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResumeMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.findMany()
     * 
     * // Get first 10 ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeMetadataWithIdOnly = await prisma.resumeMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeMetadataFindManyArgs>(args?: SelectSubset<T, ResumeMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResumeMetadata.
     * @param {ResumeMetadataCreateArgs} args - Arguments to create a ResumeMetadata.
     * @example
     * // Create one ResumeMetadata
     * const ResumeMetadata = await prisma.resumeMetadata.create({
     *   data: {
     *     // ... data to create a ResumeMetadata
     *   }
     * })
     * 
     */
    create<T extends ResumeMetadataCreateArgs>(args: SelectSubset<T, ResumeMetadataCreateArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResumeMetadata.
     * @param {ResumeMetadataCreateManyArgs} args - Arguments to create many ResumeMetadata.
     * @example
     * // Create many ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeMetadataCreateManyArgs>(args?: SelectSubset<T, ResumeMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResumeMetadata and returns the data saved in the database.
     * @param {ResumeMetadataCreateManyAndReturnArgs} args - Arguments to create many ResumeMetadata.
     * @example
     * // Create many ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResumeMetadata and only return the `id`
     * const resumeMetadataWithIdOnly = await prisma.resumeMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResumeMetadata.
     * @param {ResumeMetadataDeleteArgs} args - Arguments to delete one ResumeMetadata.
     * @example
     * // Delete one ResumeMetadata
     * const ResumeMetadata = await prisma.resumeMetadata.delete({
     *   where: {
     *     // ... filter to delete one ResumeMetadata
     *   }
     * })
     * 
     */
    delete<T extends ResumeMetadataDeleteArgs>(args: SelectSubset<T, ResumeMetadataDeleteArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResumeMetadata.
     * @param {ResumeMetadataUpdateArgs} args - Arguments to update one ResumeMetadata.
     * @example
     * // Update one ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeMetadataUpdateArgs>(args: SelectSubset<T, ResumeMetadataUpdateArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResumeMetadata.
     * @param {ResumeMetadataDeleteManyArgs} args - Arguments to filter ResumeMetadata to delete.
     * @example
     * // Delete a few ResumeMetadata
     * const { count } = await prisma.resumeMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeMetadataDeleteManyArgs>(args?: SelectSubset<T, ResumeMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeMetadataUpdateManyArgs>(args: SelectSubset<T, ResumeMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeMetadata and returns the data updated in the database.
     * @param {ResumeMetadataUpdateManyAndReturnArgs} args - Arguments to update many ResumeMetadata.
     * @example
     * // Update many ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResumeMetadata and only return the `id`
     * const resumeMetadataWithIdOnly = await prisma.resumeMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResumeMetadata.
     * @param {ResumeMetadataUpsertArgs} args - Arguments to update or create a ResumeMetadata.
     * @example
     * // Update or create a ResumeMetadata
     * const resumeMetadata = await prisma.resumeMetadata.upsert({
     *   create: {
     *     // ... data to create a ResumeMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeMetadata we want to update
     *   }
     * })
     */
    upsert<T extends ResumeMetadataUpsertArgs>(args: SelectSubset<T, ResumeMetadataUpsertArgs<ExtArgs>>): Prisma__ResumeMetadataClient<$Result.GetResult<Prisma.$ResumeMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResumeMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeMetadataCountArgs} args - Arguments to filter ResumeMetadata to count.
     * @example
     * // Count the number of ResumeMetadata
     * const count = await prisma.resumeMetadata.count({
     *   where: {
     *     // ... the filter for the ResumeMetadata we want to count
     *   }
     * })
    **/
    count<T extends ResumeMetadataCountArgs>(
      args?: Subset<T, ResumeMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeMetadataAggregateArgs>(args: Subset<T, ResumeMetadataAggregateArgs>): Prisma.PrismaPromise<GetResumeMetadataAggregateType<T>>

    /**
     * Group by ResumeMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeMetadataGroupByArgs['orderBy'] }
        : { orderBy?: ResumeMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeMetadata model
   */
  readonly fields: ResumeMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumeMetadata model
   */
  interface ResumeMetadataFieldRefs {
    readonly id: FieldRef<"ResumeMetadata", 'String'>
    readonly userId: FieldRef<"ResumeMetadata", 'String'>
    readonly resumeId: FieldRef<"ResumeMetadata", 'String'>
    readonly contentSnippet: FieldRef<"ResumeMetadata", 'String'>
    readonly tailoringMode: FieldRef<"ResumeMetadata", 'String'>
    readonly iterations: FieldRef<"ResumeMetadata", 'Int'>
    readonly passedRules: FieldRef<"ResumeMetadata", 'Boolean'>
    readonly atsScore: FieldRef<"ResumeMetadata", 'Int'>
    readonly jdScore: FieldRef<"ResumeMetadata", 'Int'>
    readonly createdAt: FieldRef<"ResumeMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResumeMetadata findUnique
   */
  export type ResumeMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ResumeMetadata to fetch.
     */
    where: ResumeMetadataWhereUniqueInput
  }

  /**
   * ResumeMetadata findUniqueOrThrow
   */
  export type ResumeMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ResumeMetadata to fetch.
     */
    where: ResumeMetadataWhereUniqueInput
  }

  /**
   * ResumeMetadata findFirst
   */
  export type ResumeMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ResumeMetadata to fetch.
     */
    where?: ResumeMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeMetadata to fetch.
     */
    orderBy?: ResumeMetadataOrderByWithRelationInput | ResumeMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeMetadata.
     */
    cursor?: ResumeMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeMetadata.
     */
    distinct?: ResumeMetadataScalarFieldEnum | ResumeMetadataScalarFieldEnum[]
  }

  /**
   * ResumeMetadata findFirstOrThrow
   */
  export type ResumeMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ResumeMetadata to fetch.
     */
    where?: ResumeMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeMetadata to fetch.
     */
    orderBy?: ResumeMetadataOrderByWithRelationInput | ResumeMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeMetadata.
     */
    cursor?: ResumeMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeMetadata.
     */
    distinct?: ResumeMetadataScalarFieldEnum | ResumeMetadataScalarFieldEnum[]
  }

  /**
   * ResumeMetadata findMany
   */
  export type ResumeMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ResumeMetadata to fetch.
     */
    where?: ResumeMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeMetadata to fetch.
     */
    orderBy?: ResumeMetadataOrderByWithRelationInput | ResumeMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeMetadata.
     */
    cursor?: ResumeMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeMetadata.
     */
    skip?: number
    distinct?: ResumeMetadataScalarFieldEnum | ResumeMetadataScalarFieldEnum[]
  }

  /**
   * ResumeMetadata create
   */
  export type ResumeMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeMetadata.
     */
    data: XOR<ResumeMetadataCreateInput, ResumeMetadataUncheckedCreateInput>
  }

  /**
   * ResumeMetadata createMany
   */
  export type ResumeMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeMetadata.
     */
    data: ResumeMetadataCreateManyInput | ResumeMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeMetadata createManyAndReturn
   */
  export type ResumeMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many ResumeMetadata.
     */
    data: ResumeMetadataCreateManyInput | ResumeMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeMetadata update
   */
  export type ResumeMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeMetadata.
     */
    data: XOR<ResumeMetadataUpdateInput, ResumeMetadataUncheckedUpdateInput>
    /**
     * Choose, which ResumeMetadata to update.
     */
    where: ResumeMetadataWhereUniqueInput
  }

  /**
   * ResumeMetadata updateMany
   */
  export type ResumeMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeMetadata.
     */
    data: XOR<ResumeMetadataUpdateManyMutationInput, ResumeMetadataUncheckedUpdateManyInput>
    /**
     * Filter which ResumeMetadata to update
     */
    where?: ResumeMetadataWhereInput
    /**
     * Limit how many ResumeMetadata to update.
     */
    limit?: number
  }

  /**
   * ResumeMetadata updateManyAndReturn
   */
  export type ResumeMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * The data used to update ResumeMetadata.
     */
    data: XOR<ResumeMetadataUpdateManyMutationInput, ResumeMetadataUncheckedUpdateManyInput>
    /**
     * Filter which ResumeMetadata to update
     */
    where?: ResumeMetadataWhereInput
    /**
     * Limit how many ResumeMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeMetadata upsert
   */
  export type ResumeMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeMetadata to update in case it exists.
     */
    where: ResumeMetadataWhereUniqueInput
    /**
     * In case the ResumeMetadata found by the `where` argument doesn't exist, create a new ResumeMetadata with this data.
     */
    create: XOR<ResumeMetadataCreateInput, ResumeMetadataUncheckedCreateInput>
    /**
     * In case the ResumeMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeMetadataUpdateInput, ResumeMetadataUncheckedUpdateInput>
  }

  /**
   * ResumeMetadata delete
   */
  export type ResumeMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
    /**
     * Filter which ResumeMetadata to delete.
     */
    where: ResumeMetadataWhereUniqueInput
  }

  /**
   * ResumeMetadata deleteMany
   */
  export type ResumeMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeMetadata to delete
     */
    where?: ResumeMetadataWhereInput
    /**
     * Limit how many ResumeMetadata to delete.
     */
    limit?: number
  }

  /**
   * ResumeMetadata without action
   */
  export type ResumeMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeMetadata
     */
    select?: ResumeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeMetadata
     */
    omit?: ResumeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeMetadataInclude<ExtArgs> | null
  }


  /**
   * Model TailoringPrompt
   */

  export type AggregateTailoringPrompt = {
    _count: TailoringPromptCountAggregateOutputType | null
    _avg: TailoringPromptAvgAggregateOutputType | null
    _sum: TailoringPromptSumAggregateOutputType | null
    _min: TailoringPromptMinAggregateOutputType | null
    _max: TailoringPromptMaxAggregateOutputType | null
  }

  export type TailoringPromptAvgAggregateOutputType = {
    attempt: number | null
    version: number | null
  }

  export type TailoringPromptSumAggregateOutputType = {
    attempt: number | null
    version: number | null
  }

  export type TailoringPromptMinAggregateOutputType = {
    id: string | null
    resumeId: string | null
    tailoringMode: string | null
    prompt: string | null
    attempt: number | null
    version: number | null
    createdAt: Date | null
  }

  export type TailoringPromptMaxAggregateOutputType = {
    id: string | null
    resumeId: string | null
    tailoringMode: string | null
    prompt: string | null
    attempt: number | null
    version: number | null
    createdAt: Date | null
  }

  export type TailoringPromptCountAggregateOutputType = {
    id: number
    resumeId: number
    tailoringMode: number
    prompt: number
    attempt: number
    version: number
    createdAt: number
    _all: number
  }


  export type TailoringPromptAvgAggregateInputType = {
    attempt?: true
    version?: true
  }

  export type TailoringPromptSumAggregateInputType = {
    attempt?: true
    version?: true
  }

  export type TailoringPromptMinAggregateInputType = {
    id?: true
    resumeId?: true
    tailoringMode?: true
    prompt?: true
    attempt?: true
    version?: true
    createdAt?: true
  }

  export type TailoringPromptMaxAggregateInputType = {
    id?: true
    resumeId?: true
    tailoringMode?: true
    prompt?: true
    attempt?: true
    version?: true
    createdAt?: true
  }

  export type TailoringPromptCountAggregateInputType = {
    id?: true
    resumeId?: true
    tailoringMode?: true
    prompt?: true
    attempt?: true
    version?: true
    createdAt?: true
    _all?: true
  }

  export type TailoringPromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailoringPrompt to aggregate.
     */
    where?: TailoringPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringPrompts to fetch.
     */
    orderBy?: TailoringPromptOrderByWithRelationInput | TailoringPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TailoringPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TailoringPrompts
    **/
    _count?: true | TailoringPromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TailoringPromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TailoringPromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TailoringPromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TailoringPromptMaxAggregateInputType
  }

  export type GetTailoringPromptAggregateType<T extends TailoringPromptAggregateArgs> = {
        [P in keyof T & keyof AggregateTailoringPrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTailoringPrompt[P]>
      : GetScalarType<T[P], AggregateTailoringPrompt[P]>
  }




  export type TailoringPromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringPromptWhereInput
    orderBy?: TailoringPromptOrderByWithAggregationInput | TailoringPromptOrderByWithAggregationInput[]
    by: TailoringPromptScalarFieldEnum[] | TailoringPromptScalarFieldEnum
    having?: TailoringPromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TailoringPromptCountAggregateInputType | true
    _avg?: TailoringPromptAvgAggregateInputType
    _sum?: TailoringPromptSumAggregateInputType
    _min?: TailoringPromptMinAggregateInputType
    _max?: TailoringPromptMaxAggregateInputType
  }

  export type TailoringPromptGroupByOutputType = {
    id: string
    resumeId: string
    tailoringMode: string
    prompt: string
    attempt: number
    version: number
    createdAt: Date
    _count: TailoringPromptCountAggregateOutputType | null
    _avg: TailoringPromptAvgAggregateOutputType | null
    _sum: TailoringPromptSumAggregateOutputType | null
    _min: TailoringPromptMinAggregateOutputType | null
    _max: TailoringPromptMaxAggregateOutputType | null
  }

  type GetTailoringPromptGroupByPayload<T extends TailoringPromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TailoringPromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TailoringPromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TailoringPromptGroupByOutputType[P]>
            : GetScalarType<T[P], TailoringPromptGroupByOutputType[P]>
        }
      >
    >


  export type TailoringPromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    tailoringMode?: boolean
    prompt?: boolean
    attempt?: boolean
    version?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringPrompt"]>

  export type TailoringPromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    tailoringMode?: boolean
    prompt?: boolean
    attempt?: boolean
    version?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringPrompt"]>

  export type TailoringPromptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    tailoringMode?: boolean
    prompt?: boolean
    attempt?: boolean
    version?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringPrompt"]>

  export type TailoringPromptSelectScalar = {
    id?: boolean
    resumeId?: boolean
    tailoringMode?: boolean
    prompt?: boolean
    attempt?: boolean
    version?: boolean
    createdAt?: boolean
  }

  export type TailoringPromptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resumeId" | "tailoringMode" | "prompt" | "attempt" | "version" | "createdAt", ExtArgs["result"]["tailoringPrompt"]>
  export type TailoringPromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type TailoringPromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type TailoringPromptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $TailoringPromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TailoringPrompt"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resumeId: string
      tailoringMode: string
      prompt: string
      attempt: number
      version: number
      createdAt: Date
    }, ExtArgs["result"]["tailoringPrompt"]>
    composites: {}
  }

  type TailoringPromptGetPayload<S extends boolean | null | undefined | TailoringPromptDefaultArgs> = $Result.GetResult<Prisma.$TailoringPromptPayload, S>

  type TailoringPromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TailoringPromptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TailoringPromptCountAggregateInputType | true
    }

  export interface TailoringPromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TailoringPrompt'], meta: { name: 'TailoringPrompt' } }
    /**
     * Find zero or one TailoringPrompt that matches the filter.
     * @param {TailoringPromptFindUniqueArgs} args - Arguments to find a TailoringPrompt
     * @example
     * // Get one TailoringPrompt
     * const tailoringPrompt = await prisma.tailoringPrompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TailoringPromptFindUniqueArgs>(args: SelectSubset<T, TailoringPromptFindUniqueArgs<ExtArgs>>): Prisma__TailoringPromptClient<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TailoringPrompt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TailoringPromptFindUniqueOrThrowArgs} args - Arguments to find a TailoringPrompt
     * @example
     * // Get one TailoringPrompt
     * const tailoringPrompt = await prisma.tailoringPrompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TailoringPromptFindUniqueOrThrowArgs>(args: SelectSubset<T, TailoringPromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TailoringPromptClient<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TailoringPrompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringPromptFindFirstArgs} args - Arguments to find a TailoringPrompt
     * @example
     * // Get one TailoringPrompt
     * const tailoringPrompt = await prisma.tailoringPrompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TailoringPromptFindFirstArgs>(args?: SelectSubset<T, TailoringPromptFindFirstArgs<ExtArgs>>): Prisma__TailoringPromptClient<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TailoringPrompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringPromptFindFirstOrThrowArgs} args - Arguments to find a TailoringPrompt
     * @example
     * // Get one TailoringPrompt
     * const tailoringPrompt = await prisma.tailoringPrompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TailoringPromptFindFirstOrThrowArgs>(args?: SelectSubset<T, TailoringPromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TailoringPromptClient<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TailoringPrompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringPromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TailoringPrompts
     * const tailoringPrompts = await prisma.tailoringPrompt.findMany()
     * 
     * // Get first 10 TailoringPrompts
     * const tailoringPrompts = await prisma.tailoringPrompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tailoringPromptWithIdOnly = await prisma.tailoringPrompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TailoringPromptFindManyArgs>(args?: SelectSubset<T, TailoringPromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TailoringPrompt.
     * @param {TailoringPromptCreateArgs} args - Arguments to create a TailoringPrompt.
     * @example
     * // Create one TailoringPrompt
     * const TailoringPrompt = await prisma.tailoringPrompt.create({
     *   data: {
     *     // ... data to create a TailoringPrompt
     *   }
     * })
     * 
     */
    create<T extends TailoringPromptCreateArgs>(args: SelectSubset<T, TailoringPromptCreateArgs<ExtArgs>>): Prisma__TailoringPromptClient<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TailoringPrompts.
     * @param {TailoringPromptCreateManyArgs} args - Arguments to create many TailoringPrompts.
     * @example
     * // Create many TailoringPrompts
     * const tailoringPrompt = await prisma.tailoringPrompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TailoringPromptCreateManyArgs>(args?: SelectSubset<T, TailoringPromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TailoringPrompts and returns the data saved in the database.
     * @param {TailoringPromptCreateManyAndReturnArgs} args - Arguments to create many TailoringPrompts.
     * @example
     * // Create many TailoringPrompts
     * const tailoringPrompt = await prisma.tailoringPrompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TailoringPrompts and only return the `id`
     * const tailoringPromptWithIdOnly = await prisma.tailoringPrompt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TailoringPromptCreateManyAndReturnArgs>(args?: SelectSubset<T, TailoringPromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TailoringPrompt.
     * @param {TailoringPromptDeleteArgs} args - Arguments to delete one TailoringPrompt.
     * @example
     * // Delete one TailoringPrompt
     * const TailoringPrompt = await prisma.tailoringPrompt.delete({
     *   where: {
     *     // ... filter to delete one TailoringPrompt
     *   }
     * })
     * 
     */
    delete<T extends TailoringPromptDeleteArgs>(args: SelectSubset<T, TailoringPromptDeleteArgs<ExtArgs>>): Prisma__TailoringPromptClient<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TailoringPrompt.
     * @param {TailoringPromptUpdateArgs} args - Arguments to update one TailoringPrompt.
     * @example
     * // Update one TailoringPrompt
     * const tailoringPrompt = await prisma.tailoringPrompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TailoringPromptUpdateArgs>(args: SelectSubset<T, TailoringPromptUpdateArgs<ExtArgs>>): Prisma__TailoringPromptClient<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TailoringPrompts.
     * @param {TailoringPromptDeleteManyArgs} args - Arguments to filter TailoringPrompts to delete.
     * @example
     * // Delete a few TailoringPrompts
     * const { count } = await prisma.tailoringPrompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TailoringPromptDeleteManyArgs>(args?: SelectSubset<T, TailoringPromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailoringPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringPromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TailoringPrompts
     * const tailoringPrompt = await prisma.tailoringPrompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TailoringPromptUpdateManyArgs>(args: SelectSubset<T, TailoringPromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailoringPrompts and returns the data updated in the database.
     * @param {TailoringPromptUpdateManyAndReturnArgs} args - Arguments to update many TailoringPrompts.
     * @example
     * // Update many TailoringPrompts
     * const tailoringPrompt = await prisma.tailoringPrompt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TailoringPrompts and only return the `id`
     * const tailoringPromptWithIdOnly = await prisma.tailoringPrompt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TailoringPromptUpdateManyAndReturnArgs>(args: SelectSubset<T, TailoringPromptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TailoringPrompt.
     * @param {TailoringPromptUpsertArgs} args - Arguments to update or create a TailoringPrompt.
     * @example
     * // Update or create a TailoringPrompt
     * const tailoringPrompt = await prisma.tailoringPrompt.upsert({
     *   create: {
     *     // ... data to create a TailoringPrompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TailoringPrompt we want to update
     *   }
     * })
     */
    upsert<T extends TailoringPromptUpsertArgs>(args: SelectSubset<T, TailoringPromptUpsertArgs<ExtArgs>>): Prisma__TailoringPromptClient<$Result.GetResult<Prisma.$TailoringPromptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TailoringPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringPromptCountArgs} args - Arguments to filter TailoringPrompts to count.
     * @example
     * // Count the number of TailoringPrompts
     * const count = await prisma.tailoringPrompt.count({
     *   where: {
     *     // ... the filter for the TailoringPrompts we want to count
     *   }
     * })
    **/
    count<T extends TailoringPromptCountArgs>(
      args?: Subset<T, TailoringPromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TailoringPromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TailoringPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringPromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TailoringPromptAggregateArgs>(args: Subset<T, TailoringPromptAggregateArgs>): Prisma.PrismaPromise<GetTailoringPromptAggregateType<T>>

    /**
     * Group by TailoringPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringPromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TailoringPromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TailoringPromptGroupByArgs['orderBy'] }
        : { orderBy?: TailoringPromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TailoringPromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTailoringPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TailoringPrompt model
   */
  readonly fields: TailoringPromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TailoringPrompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TailoringPromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TailoringPrompt model
   */
  interface TailoringPromptFieldRefs {
    readonly id: FieldRef<"TailoringPrompt", 'String'>
    readonly resumeId: FieldRef<"TailoringPrompt", 'String'>
    readonly tailoringMode: FieldRef<"TailoringPrompt", 'String'>
    readonly prompt: FieldRef<"TailoringPrompt", 'String'>
    readonly attempt: FieldRef<"TailoringPrompt", 'Int'>
    readonly version: FieldRef<"TailoringPrompt", 'Int'>
    readonly createdAt: FieldRef<"TailoringPrompt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TailoringPrompt findUnique
   */
  export type TailoringPromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringPrompt to fetch.
     */
    where: TailoringPromptWhereUniqueInput
  }

  /**
   * TailoringPrompt findUniqueOrThrow
   */
  export type TailoringPromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringPrompt to fetch.
     */
    where: TailoringPromptWhereUniqueInput
  }

  /**
   * TailoringPrompt findFirst
   */
  export type TailoringPromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringPrompt to fetch.
     */
    where?: TailoringPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringPrompts to fetch.
     */
    orderBy?: TailoringPromptOrderByWithRelationInput | TailoringPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailoringPrompts.
     */
    cursor?: TailoringPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailoringPrompts.
     */
    distinct?: TailoringPromptScalarFieldEnum | TailoringPromptScalarFieldEnum[]
  }

  /**
   * TailoringPrompt findFirstOrThrow
   */
  export type TailoringPromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringPrompt to fetch.
     */
    where?: TailoringPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringPrompts to fetch.
     */
    orderBy?: TailoringPromptOrderByWithRelationInput | TailoringPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailoringPrompts.
     */
    cursor?: TailoringPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailoringPrompts.
     */
    distinct?: TailoringPromptScalarFieldEnum | TailoringPromptScalarFieldEnum[]
  }

  /**
   * TailoringPrompt findMany
   */
  export type TailoringPromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringPrompts to fetch.
     */
    where?: TailoringPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringPrompts to fetch.
     */
    orderBy?: TailoringPromptOrderByWithRelationInput | TailoringPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TailoringPrompts.
     */
    cursor?: TailoringPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringPrompts.
     */
    skip?: number
    distinct?: TailoringPromptScalarFieldEnum | TailoringPromptScalarFieldEnum[]
  }

  /**
   * TailoringPrompt create
   */
  export type TailoringPromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * The data needed to create a TailoringPrompt.
     */
    data: XOR<TailoringPromptCreateInput, TailoringPromptUncheckedCreateInput>
  }

  /**
   * TailoringPrompt createMany
   */
  export type TailoringPromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TailoringPrompts.
     */
    data: TailoringPromptCreateManyInput | TailoringPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TailoringPrompt createManyAndReturn
   */
  export type TailoringPromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * The data used to create many TailoringPrompts.
     */
    data: TailoringPromptCreateManyInput | TailoringPromptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailoringPrompt update
   */
  export type TailoringPromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * The data needed to update a TailoringPrompt.
     */
    data: XOR<TailoringPromptUpdateInput, TailoringPromptUncheckedUpdateInput>
    /**
     * Choose, which TailoringPrompt to update.
     */
    where: TailoringPromptWhereUniqueInput
  }

  /**
   * TailoringPrompt updateMany
   */
  export type TailoringPromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TailoringPrompts.
     */
    data: XOR<TailoringPromptUpdateManyMutationInput, TailoringPromptUncheckedUpdateManyInput>
    /**
     * Filter which TailoringPrompts to update
     */
    where?: TailoringPromptWhereInput
    /**
     * Limit how many TailoringPrompts to update.
     */
    limit?: number
  }

  /**
   * TailoringPrompt updateManyAndReturn
   */
  export type TailoringPromptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * The data used to update TailoringPrompts.
     */
    data: XOR<TailoringPromptUpdateManyMutationInput, TailoringPromptUncheckedUpdateManyInput>
    /**
     * Filter which TailoringPrompts to update
     */
    where?: TailoringPromptWhereInput
    /**
     * Limit how many TailoringPrompts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailoringPrompt upsert
   */
  export type TailoringPromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * The filter to search for the TailoringPrompt to update in case it exists.
     */
    where: TailoringPromptWhereUniqueInput
    /**
     * In case the TailoringPrompt found by the `where` argument doesn't exist, create a new TailoringPrompt with this data.
     */
    create: XOR<TailoringPromptCreateInput, TailoringPromptUncheckedCreateInput>
    /**
     * In case the TailoringPrompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TailoringPromptUpdateInput, TailoringPromptUncheckedUpdateInput>
  }

  /**
   * TailoringPrompt delete
   */
  export type TailoringPromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
    /**
     * Filter which TailoringPrompt to delete.
     */
    where: TailoringPromptWhereUniqueInput
  }

  /**
   * TailoringPrompt deleteMany
   */
  export type TailoringPromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailoringPrompts to delete
     */
    where?: TailoringPromptWhereInput
    /**
     * Limit how many TailoringPrompts to delete.
     */
    limit?: number
  }

  /**
   * TailoringPrompt without action
   */
  export type TailoringPromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringPrompt
     */
    select?: TailoringPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringPrompt
     */
    omit?: TailoringPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringPromptInclude<ExtArgs> | null
  }


  /**
   * Model TailoringProgress
   */

  export type AggregateTailoringProgress = {
    _count: TailoringProgressCountAggregateOutputType | null
    _avg: TailoringProgressAvgAggregateOutputType | null
    _sum: TailoringProgressSumAggregateOutputType | null
    _min: TailoringProgressMinAggregateOutputType | null
    _max: TailoringProgressMaxAggregateOutputType | null
  }

  export type TailoringProgressAvgAggregateOutputType = {
    progress: number | null
    currentAttempt: number | null
    maxAttempts: number | null
  }

  export type TailoringProgressSumAggregateOutputType = {
    progress: number | null
    currentAttempt: number | null
    maxAttempts: number | null
  }

  export type TailoringProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    status: string | null
    progress: number | null
    currentAttempt: number | null
    maxAttempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TailoringProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    status: string | null
    progress: number | null
    currentAttempt: number | null
    maxAttempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TailoringProgressCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    status: number
    progress: number
    currentAttempt: number
    maxAttempts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TailoringProgressAvgAggregateInputType = {
    progress?: true
    currentAttempt?: true
    maxAttempts?: true
  }

  export type TailoringProgressSumAggregateInputType = {
    progress?: true
    currentAttempt?: true
    maxAttempts?: true
  }

  export type TailoringProgressMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    status?: true
    progress?: true
    currentAttempt?: true
    maxAttempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TailoringProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    status?: true
    progress?: true
    currentAttempt?: true
    maxAttempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TailoringProgressCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    status?: true
    progress?: true
    currentAttempt?: true
    maxAttempts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TailoringProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailoringProgress to aggregate.
     */
    where?: TailoringProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringProgresses to fetch.
     */
    orderBy?: TailoringProgressOrderByWithRelationInput | TailoringProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TailoringProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TailoringProgresses
    **/
    _count?: true | TailoringProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TailoringProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TailoringProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TailoringProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TailoringProgressMaxAggregateInputType
  }

  export type GetTailoringProgressAggregateType<T extends TailoringProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateTailoringProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTailoringProgress[P]>
      : GetScalarType<T[P], AggregateTailoringProgress[P]>
  }




  export type TailoringProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringProgressWhereInput
    orderBy?: TailoringProgressOrderByWithAggregationInput | TailoringProgressOrderByWithAggregationInput[]
    by: TailoringProgressScalarFieldEnum[] | TailoringProgressScalarFieldEnum
    having?: TailoringProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TailoringProgressCountAggregateInputType | true
    _avg?: TailoringProgressAvgAggregateInputType
    _sum?: TailoringProgressSumAggregateInputType
    _min?: TailoringProgressMinAggregateInputType
    _max?: TailoringProgressMaxAggregateInputType
  }

  export type TailoringProgressGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    status: string
    progress: number
    currentAttempt: number | null
    maxAttempts: number | null
    createdAt: Date
    updatedAt: Date
    _count: TailoringProgressCountAggregateOutputType | null
    _avg: TailoringProgressAvgAggregateOutputType | null
    _sum: TailoringProgressSumAggregateOutputType | null
    _min: TailoringProgressMinAggregateOutputType | null
    _max: TailoringProgressMaxAggregateOutputType | null
  }

  type GetTailoringProgressGroupByPayload<T extends TailoringProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TailoringProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TailoringProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TailoringProgressGroupByOutputType[P]>
            : GetScalarType<T[P], TailoringProgressGroupByOutputType[P]>
        }
      >
    >


  export type TailoringProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    status?: boolean
    progress?: boolean
    currentAttempt?: boolean
    maxAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringProgress"]>

  export type TailoringProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    status?: boolean
    progress?: boolean
    currentAttempt?: boolean
    maxAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringProgress"]>

  export type TailoringProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    status?: boolean
    progress?: boolean
    currentAttempt?: boolean
    maxAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringProgress"]>

  export type TailoringProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    status?: boolean
    progress?: boolean
    currentAttempt?: boolean
    maxAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TailoringProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "status" | "progress" | "currentAttempt" | "maxAttempts" | "createdAt" | "updatedAt", ExtArgs["result"]["tailoringProgress"]>
  export type TailoringProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type TailoringProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type TailoringProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $TailoringProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TailoringProgress"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      status: string
      progress: number
      currentAttempt: number | null
      maxAttempts: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tailoringProgress"]>
    composites: {}
  }

  type TailoringProgressGetPayload<S extends boolean | null | undefined | TailoringProgressDefaultArgs> = $Result.GetResult<Prisma.$TailoringProgressPayload, S>

  type TailoringProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TailoringProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TailoringProgressCountAggregateInputType | true
    }

  export interface TailoringProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TailoringProgress'], meta: { name: 'TailoringProgress' } }
    /**
     * Find zero or one TailoringProgress that matches the filter.
     * @param {TailoringProgressFindUniqueArgs} args - Arguments to find a TailoringProgress
     * @example
     * // Get one TailoringProgress
     * const tailoringProgress = await prisma.tailoringProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TailoringProgressFindUniqueArgs>(args: SelectSubset<T, TailoringProgressFindUniqueArgs<ExtArgs>>): Prisma__TailoringProgressClient<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TailoringProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TailoringProgressFindUniqueOrThrowArgs} args - Arguments to find a TailoringProgress
     * @example
     * // Get one TailoringProgress
     * const tailoringProgress = await prisma.tailoringProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TailoringProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, TailoringProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TailoringProgressClient<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TailoringProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringProgressFindFirstArgs} args - Arguments to find a TailoringProgress
     * @example
     * // Get one TailoringProgress
     * const tailoringProgress = await prisma.tailoringProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TailoringProgressFindFirstArgs>(args?: SelectSubset<T, TailoringProgressFindFirstArgs<ExtArgs>>): Prisma__TailoringProgressClient<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TailoringProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringProgressFindFirstOrThrowArgs} args - Arguments to find a TailoringProgress
     * @example
     * // Get one TailoringProgress
     * const tailoringProgress = await prisma.tailoringProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TailoringProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, TailoringProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__TailoringProgressClient<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TailoringProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TailoringProgresses
     * const tailoringProgresses = await prisma.tailoringProgress.findMany()
     * 
     * // Get first 10 TailoringProgresses
     * const tailoringProgresses = await prisma.tailoringProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tailoringProgressWithIdOnly = await prisma.tailoringProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TailoringProgressFindManyArgs>(args?: SelectSubset<T, TailoringProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TailoringProgress.
     * @param {TailoringProgressCreateArgs} args - Arguments to create a TailoringProgress.
     * @example
     * // Create one TailoringProgress
     * const TailoringProgress = await prisma.tailoringProgress.create({
     *   data: {
     *     // ... data to create a TailoringProgress
     *   }
     * })
     * 
     */
    create<T extends TailoringProgressCreateArgs>(args: SelectSubset<T, TailoringProgressCreateArgs<ExtArgs>>): Prisma__TailoringProgressClient<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TailoringProgresses.
     * @param {TailoringProgressCreateManyArgs} args - Arguments to create many TailoringProgresses.
     * @example
     * // Create many TailoringProgresses
     * const tailoringProgress = await prisma.tailoringProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TailoringProgressCreateManyArgs>(args?: SelectSubset<T, TailoringProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TailoringProgresses and returns the data saved in the database.
     * @param {TailoringProgressCreateManyAndReturnArgs} args - Arguments to create many TailoringProgresses.
     * @example
     * // Create many TailoringProgresses
     * const tailoringProgress = await prisma.tailoringProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TailoringProgresses and only return the `id`
     * const tailoringProgressWithIdOnly = await prisma.tailoringProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TailoringProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, TailoringProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TailoringProgress.
     * @param {TailoringProgressDeleteArgs} args - Arguments to delete one TailoringProgress.
     * @example
     * // Delete one TailoringProgress
     * const TailoringProgress = await prisma.tailoringProgress.delete({
     *   where: {
     *     // ... filter to delete one TailoringProgress
     *   }
     * })
     * 
     */
    delete<T extends TailoringProgressDeleteArgs>(args: SelectSubset<T, TailoringProgressDeleteArgs<ExtArgs>>): Prisma__TailoringProgressClient<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TailoringProgress.
     * @param {TailoringProgressUpdateArgs} args - Arguments to update one TailoringProgress.
     * @example
     * // Update one TailoringProgress
     * const tailoringProgress = await prisma.tailoringProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TailoringProgressUpdateArgs>(args: SelectSubset<T, TailoringProgressUpdateArgs<ExtArgs>>): Prisma__TailoringProgressClient<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TailoringProgresses.
     * @param {TailoringProgressDeleteManyArgs} args - Arguments to filter TailoringProgresses to delete.
     * @example
     * // Delete a few TailoringProgresses
     * const { count } = await prisma.tailoringProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TailoringProgressDeleteManyArgs>(args?: SelectSubset<T, TailoringProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailoringProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TailoringProgresses
     * const tailoringProgress = await prisma.tailoringProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TailoringProgressUpdateManyArgs>(args: SelectSubset<T, TailoringProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailoringProgresses and returns the data updated in the database.
     * @param {TailoringProgressUpdateManyAndReturnArgs} args - Arguments to update many TailoringProgresses.
     * @example
     * // Update many TailoringProgresses
     * const tailoringProgress = await prisma.tailoringProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TailoringProgresses and only return the `id`
     * const tailoringProgressWithIdOnly = await prisma.tailoringProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TailoringProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, TailoringProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TailoringProgress.
     * @param {TailoringProgressUpsertArgs} args - Arguments to update or create a TailoringProgress.
     * @example
     * // Update or create a TailoringProgress
     * const tailoringProgress = await prisma.tailoringProgress.upsert({
     *   create: {
     *     // ... data to create a TailoringProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TailoringProgress we want to update
     *   }
     * })
     */
    upsert<T extends TailoringProgressUpsertArgs>(args: SelectSubset<T, TailoringProgressUpsertArgs<ExtArgs>>): Prisma__TailoringProgressClient<$Result.GetResult<Prisma.$TailoringProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TailoringProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringProgressCountArgs} args - Arguments to filter TailoringProgresses to count.
     * @example
     * // Count the number of TailoringProgresses
     * const count = await prisma.tailoringProgress.count({
     *   where: {
     *     // ... the filter for the TailoringProgresses we want to count
     *   }
     * })
    **/
    count<T extends TailoringProgressCountArgs>(
      args?: Subset<T, TailoringProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TailoringProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TailoringProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TailoringProgressAggregateArgs>(args: Subset<T, TailoringProgressAggregateArgs>): Prisma.PrismaPromise<GetTailoringProgressAggregateType<T>>

    /**
     * Group by TailoringProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TailoringProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TailoringProgressGroupByArgs['orderBy'] }
        : { orderBy?: TailoringProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TailoringProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTailoringProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TailoringProgress model
   */
  readonly fields: TailoringProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TailoringProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TailoringProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TailoringProgress model
   */
  interface TailoringProgressFieldRefs {
    readonly id: FieldRef<"TailoringProgress", 'String'>
    readonly userId: FieldRef<"TailoringProgress", 'String'>
    readonly resumeId: FieldRef<"TailoringProgress", 'String'>
    readonly status: FieldRef<"TailoringProgress", 'String'>
    readonly progress: FieldRef<"TailoringProgress", 'Int'>
    readonly currentAttempt: FieldRef<"TailoringProgress", 'Int'>
    readonly maxAttempts: FieldRef<"TailoringProgress", 'Int'>
    readonly createdAt: FieldRef<"TailoringProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"TailoringProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TailoringProgress findUnique
   */
  export type TailoringProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * Filter, which TailoringProgress to fetch.
     */
    where: TailoringProgressWhereUniqueInput
  }

  /**
   * TailoringProgress findUniqueOrThrow
   */
  export type TailoringProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * Filter, which TailoringProgress to fetch.
     */
    where: TailoringProgressWhereUniqueInput
  }

  /**
   * TailoringProgress findFirst
   */
  export type TailoringProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * Filter, which TailoringProgress to fetch.
     */
    where?: TailoringProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringProgresses to fetch.
     */
    orderBy?: TailoringProgressOrderByWithRelationInput | TailoringProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailoringProgresses.
     */
    cursor?: TailoringProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailoringProgresses.
     */
    distinct?: TailoringProgressScalarFieldEnum | TailoringProgressScalarFieldEnum[]
  }

  /**
   * TailoringProgress findFirstOrThrow
   */
  export type TailoringProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * Filter, which TailoringProgress to fetch.
     */
    where?: TailoringProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringProgresses to fetch.
     */
    orderBy?: TailoringProgressOrderByWithRelationInput | TailoringProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailoringProgresses.
     */
    cursor?: TailoringProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailoringProgresses.
     */
    distinct?: TailoringProgressScalarFieldEnum | TailoringProgressScalarFieldEnum[]
  }

  /**
   * TailoringProgress findMany
   */
  export type TailoringProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * Filter, which TailoringProgresses to fetch.
     */
    where?: TailoringProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringProgresses to fetch.
     */
    orderBy?: TailoringProgressOrderByWithRelationInput | TailoringProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TailoringProgresses.
     */
    cursor?: TailoringProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringProgresses.
     */
    skip?: number
    distinct?: TailoringProgressScalarFieldEnum | TailoringProgressScalarFieldEnum[]
  }

  /**
   * TailoringProgress create
   */
  export type TailoringProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a TailoringProgress.
     */
    data: XOR<TailoringProgressCreateInput, TailoringProgressUncheckedCreateInput>
  }

  /**
   * TailoringProgress createMany
   */
  export type TailoringProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TailoringProgresses.
     */
    data: TailoringProgressCreateManyInput | TailoringProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TailoringProgress createManyAndReturn
   */
  export type TailoringProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * The data used to create many TailoringProgresses.
     */
    data: TailoringProgressCreateManyInput | TailoringProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailoringProgress update
   */
  export type TailoringProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a TailoringProgress.
     */
    data: XOR<TailoringProgressUpdateInput, TailoringProgressUncheckedUpdateInput>
    /**
     * Choose, which TailoringProgress to update.
     */
    where: TailoringProgressWhereUniqueInput
  }

  /**
   * TailoringProgress updateMany
   */
  export type TailoringProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TailoringProgresses.
     */
    data: XOR<TailoringProgressUpdateManyMutationInput, TailoringProgressUncheckedUpdateManyInput>
    /**
     * Filter which TailoringProgresses to update
     */
    where?: TailoringProgressWhereInput
    /**
     * Limit how many TailoringProgresses to update.
     */
    limit?: number
  }

  /**
   * TailoringProgress updateManyAndReturn
   */
  export type TailoringProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * The data used to update TailoringProgresses.
     */
    data: XOR<TailoringProgressUpdateManyMutationInput, TailoringProgressUncheckedUpdateManyInput>
    /**
     * Filter which TailoringProgresses to update
     */
    where?: TailoringProgressWhereInput
    /**
     * Limit how many TailoringProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailoringProgress upsert
   */
  export type TailoringProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the TailoringProgress to update in case it exists.
     */
    where: TailoringProgressWhereUniqueInput
    /**
     * In case the TailoringProgress found by the `where` argument doesn't exist, create a new TailoringProgress with this data.
     */
    create: XOR<TailoringProgressCreateInput, TailoringProgressUncheckedCreateInput>
    /**
     * In case the TailoringProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TailoringProgressUpdateInput, TailoringProgressUncheckedUpdateInput>
  }

  /**
   * TailoringProgress delete
   */
  export type TailoringProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
    /**
     * Filter which TailoringProgress to delete.
     */
    where: TailoringProgressWhereUniqueInput
  }

  /**
   * TailoringProgress deleteMany
   */
  export type TailoringProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailoringProgresses to delete
     */
    where?: TailoringProgressWhereInput
    /**
     * Limit how many TailoringProgresses to delete.
     */
    limit?: number
  }

  /**
   * TailoringProgress without action
   */
  export type TailoringProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringProgress
     */
    select?: TailoringProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringProgress
     */
    omit?: TailoringProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringProgressInclude<ExtArgs> | null
  }


  /**
   * Model TailoringAttempt
   */

  export type AggregateTailoringAttempt = {
    _count: TailoringAttemptCountAggregateOutputType | null
    _avg: TailoringAttemptAvgAggregateOutputType | null
    _sum: TailoringAttemptSumAggregateOutputType | null
    _min: TailoringAttemptMinAggregateOutputType | null
    _max: TailoringAttemptMaxAggregateOutputType | null
  }

  export type TailoringAttemptAvgAggregateOutputType = {
    attemptNumber: number | null
    atsScore: number | null
    jdScore: number | null
    promptTokens: number | null
    iteration: number | null
    score: number | null
  }

  export type TailoringAttemptSumAggregateOutputType = {
    attemptNumber: number | null
    atsScore: number | null
    jdScore: number | null
    promptTokens: number | null
    iteration: number | null
    score: number | null
  }

  export type TailoringAttemptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    attemptNumber: number | null
    atsScore: number | null
    jdScore: number | null
    goldenPassed: boolean | null
    feedback: string | null
    suggestions: string | null
    atsFeedback: string | null
    jdFeedback: string | null
    createdAt: Date | null
    modifiedSectionsSent: string | null
    modifiedSectionsReceived: string | null
    promptTokens: number | null
    goldenRuleFeedback: string | null
    iteration: number | null
    modifiedSections: string | null
    score: number | null
  }

  export type TailoringAttemptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    attemptNumber: number | null
    atsScore: number | null
    jdScore: number | null
    goldenPassed: boolean | null
    feedback: string | null
    suggestions: string | null
    atsFeedback: string | null
    jdFeedback: string | null
    createdAt: Date | null
    modifiedSectionsSent: string | null
    modifiedSectionsReceived: string | null
    promptTokens: number | null
    goldenRuleFeedback: string | null
    iteration: number | null
    modifiedSections: string | null
    score: number | null
  }

  export type TailoringAttemptCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    attemptNumber: number
    atsScore: number
    jdScore: number
    goldenPassed: number
    feedback: number
    suggestions: number
    atsFeedback: number
    jdFeedback: number
    createdAt: number
    modifiedSectionsSent: number
    modifiedSectionsReceived: number
    promptTokens: number
    goldenRuleFeedback: number
    iteration: number
    modifiedSections: number
    score: number
    _all: number
  }


  export type TailoringAttemptAvgAggregateInputType = {
    attemptNumber?: true
    atsScore?: true
    jdScore?: true
    promptTokens?: true
    iteration?: true
    score?: true
  }

  export type TailoringAttemptSumAggregateInputType = {
    attemptNumber?: true
    atsScore?: true
    jdScore?: true
    promptTokens?: true
    iteration?: true
    score?: true
  }

  export type TailoringAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    attemptNumber?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    feedback?: true
    suggestions?: true
    atsFeedback?: true
    jdFeedback?: true
    createdAt?: true
    modifiedSectionsSent?: true
    modifiedSectionsReceived?: true
    promptTokens?: true
    goldenRuleFeedback?: true
    iteration?: true
    modifiedSections?: true
    score?: true
  }

  export type TailoringAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    attemptNumber?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    feedback?: true
    suggestions?: true
    atsFeedback?: true
    jdFeedback?: true
    createdAt?: true
    modifiedSectionsSent?: true
    modifiedSectionsReceived?: true
    promptTokens?: true
    goldenRuleFeedback?: true
    iteration?: true
    modifiedSections?: true
    score?: true
  }

  export type TailoringAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    attemptNumber?: true
    atsScore?: true
    jdScore?: true
    goldenPassed?: true
    feedback?: true
    suggestions?: true
    atsFeedback?: true
    jdFeedback?: true
    createdAt?: true
    modifiedSectionsSent?: true
    modifiedSectionsReceived?: true
    promptTokens?: true
    goldenRuleFeedback?: true
    iteration?: true
    modifiedSections?: true
    score?: true
    _all?: true
  }

  export type TailoringAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailoringAttempt to aggregate.
     */
    where?: TailoringAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringAttempts to fetch.
     */
    orderBy?: TailoringAttemptOrderByWithRelationInput | TailoringAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TailoringAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TailoringAttempts
    **/
    _count?: true | TailoringAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TailoringAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TailoringAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TailoringAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TailoringAttemptMaxAggregateInputType
  }

  export type GetTailoringAttemptAggregateType<T extends TailoringAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateTailoringAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTailoringAttempt[P]>
      : GetScalarType<T[P], AggregateTailoringAttempt[P]>
  }




  export type TailoringAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailoringAttemptWhereInput
    orderBy?: TailoringAttemptOrderByWithAggregationInput | TailoringAttemptOrderByWithAggregationInput[]
    by: TailoringAttemptScalarFieldEnum[] | TailoringAttemptScalarFieldEnum
    having?: TailoringAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TailoringAttemptCountAggregateInputType | true
    _avg?: TailoringAttemptAvgAggregateInputType
    _sum?: TailoringAttemptSumAggregateInputType
    _min?: TailoringAttemptMinAggregateInputType
    _max?: TailoringAttemptMaxAggregateInputType
  }

  export type TailoringAttemptGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    attemptNumber: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    feedback: string
    suggestions: string
    atsFeedback: string | null
    jdFeedback: string | null
    createdAt: Date
    modifiedSectionsSent: string | null
    modifiedSectionsReceived: string | null
    promptTokens: number | null
    goldenRuleFeedback: string | null
    iteration: number | null
    modifiedSections: string | null
    score: number | null
    _count: TailoringAttemptCountAggregateOutputType | null
    _avg: TailoringAttemptAvgAggregateOutputType | null
    _sum: TailoringAttemptSumAggregateOutputType | null
    _min: TailoringAttemptMinAggregateOutputType | null
    _max: TailoringAttemptMaxAggregateOutputType | null
  }

  type GetTailoringAttemptGroupByPayload<T extends TailoringAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TailoringAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TailoringAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TailoringAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], TailoringAttemptGroupByOutputType[P]>
        }
      >
    >


  export type TailoringAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    attemptNumber?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    feedback?: boolean
    suggestions?: boolean
    atsFeedback?: boolean
    jdFeedback?: boolean
    createdAt?: boolean
    modifiedSectionsSent?: boolean
    modifiedSectionsReceived?: boolean
    promptTokens?: boolean
    goldenRuleFeedback?: boolean
    iteration?: boolean
    modifiedSections?: boolean
    score?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringAttempt"]>

  export type TailoringAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    attemptNumber?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    feedback?: boolean
    suggestions?: boolean
    atsFeedback?: boolean
    jdFeedback?: boolean
    createdAt?: boolean
    modifiedSectionsSent?: boolean
    modifiedSectionsReceived?: boolean
    promptTokens?: boolean
    goldenRuleFeedback?: boolean
    iteration?: boolean
    modifiedSections?: boolean
    score?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringAttempt"]>

  export type TailoringAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    attemptNumber?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    feedback?: boolean
    suggestions?: boolean
    atsFeedback?: boolean
    jdFeedback?: boolean
    createdAt?: boolean
    modifiedSectionsSent?: boolean
    modifiedSectionsReceived?: boolean
    promptTokens?: boolean
    goldenRuleFeedback?: boolean
    iteration?: boolean
    modifiedSections?: boolean
    score?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailoringAttempt"]>

  export type TailoringAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    attemptNumber?: boolean
    atsScore?: boolean
    jdScore?: boolean
    goldenPassed?: boolean
    feedback?: boolean
    suggestions?: boolean
    atsFeedback?: boolean
    jdFeedback?: boolean
    createdAt?: boolean
    modifiedSectionsSent?: boolean
    modifiedSectionsReceived?: boolean
    promptTokens?: boolean
    goldenRuleFeedback?: boolean
    iteration?: boolean
    modifiedSections?: boolean
    score?: boolean
  }

  export type TailoringAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "attemptNumber" | "atsScore" | "jdScore" | "goldenPassed" | "feedback" | "suggestions" | "atsFeedback" | "jdFeedback" | "createdAt" | "modifiedSectionsSent" | "modifiedSectionsReceived" | "promptTokens" | "goldenRuleFeedback" | "iteration" | "modifiedSections" | "score", ExtArgs["result"]["tailoringAttempt"]>
  export type TailoringAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type TailoringAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type TailoringAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $TailoringAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TailoringAttempt"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      attemptNumber: number
      atsScore: number
      jdScore: number
      goldenPassed: boolean
      feedback: string
      suggestions: string
      atsFeedback: string | null
      jdFeedback: string | null
      createdAt: Date
      modifiedSectionsSent: string | null
      modifiedSectionsReceived: string | null
      promptTokens: number | null
      goldenRuleFeedback: string | null
      iteration: number | null
      modifiedSections: string | null
      score: number | null
    }, ExtArgs["result"]["tailoringAttempt"]>
    composites: {}
  }

  type TailoringAttemptGetPayload<S extends boolean | null | undefined | TailoringAttemptDefaultArgs> = $Result.GetResult<Prisma.$TailoringAttemptPayload, S>

  type TailoringAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TailoringAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TailoringAttemptCountAggregateInputType | true
    }

  export interface TailoringAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TailoringAttempt'], meta: { name: 'TailoringAttempt' } }
    /**
     * Find zero or one TailoringAttempt that matches the filter.
     * @param {TailoringAttemptFindUniqueArgs} args - Arguments to find a TailoringAttempt
     * @example
     * // Get one TailoringAttempt
     * const tailoringAttempt = await prisma.tailoringAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TailoringAttemptFindUniqueArgs>(args: SelectSubset<T, TailoringAttemptFindUniqueArgs<ExtArgs>>): Prisma__TailoringAttemptClient<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TailoringAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TailoringAttemptFindUniqueOrThrowArgs} args - Arguments to find a TailoringAttempt
     * @example
     * // Get one TailoringAttempt
     * const tailoringAttempt = await prisma.tailoringAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TailoringAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, TailoringAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TailoringAttemptClient<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TailoringAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAttemptFindFirstArgs} args - Arguments to find a TailoringAttempt
     * @example
     * // Get one TailoringAttempt
     * const tailoringAttempt = await prisma.tailoringAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TailoringAttemptFindFirstArgs>(args?: SelectSubset<T, TailoringAttemptFindFirstArgs<ExtArgs>>): Prisma__TailoringAttemptClient<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TailoringAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAttemptFindFirstOrThrowArgs} args - Arguments to find a TailoringAttempt
     * @example
     * // Get one TailoringAttempt
     * const tailoringAttempt = await prisma.tailoringAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TailoringAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, TailoringAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TailoringAttemptClient<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TailoringAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TailoringAttempts
     * const tailoringAttempts = await prisma.tailoringAttempt.findMany()
     * 
     * // Get first 10 TailoringAttempts
     * const tailoringAttempts = await prisma.tailoringAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tailoringAttemptWithIdOnly = await prisma.tailoringAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TailoringAttemptFindManyArgs>(args?: SelectSubset<T, TailoringAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TailoringAttempt.
     * @param {TailoringAttemptCreateArgs} args - Arguments to create a TailoringAttempt.
     * @example
     * // Create one TailoringAttempt
     * const TailoringAttempt = await prisma.tailoringAttempt.create({
     *   data: {
     *     // ... data to create a TailoringAttempt
     *   }
     * })
     * 
     */
    create<T extends TailoringAttemptCreateArgs>(args: SelectSubset<T, TailoringAttemptCreateArgs<ExtArgs>>): Prisma__TailoringAttemptClient<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TailoringAttempts.
     * @param {TailoringAttemptCreateManyArgs} args - Arguments to create many TailoringAttempts.
     * @example
     * // Create many TailoringAttempts
     * const tailoringAttempt = await prisma.tailoringAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TailoringAttemptCreateManyArgs>(args?: SelectSubset<T, TailoringAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TailoringAttempts and returns the data saved in the database.
     * @param {TailoringAttemptCreateManyAndReturnArgs} args - Arguments to create many TailoringAttempts.
     * @example
     * // Create many TailoringAttempts
     * const tailoringAttempt = await prisma.tailoringAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TailoringAttempts and only return the `id`
     * const tailoringAttemptWithIdOnly = await prisma.tailoringAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TailoringAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, TailoringAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TailoringAttempt.
     * @param {TailoringAttemptDeleteArgs} args - Arguments to delete one TailoringAttempt.
     * @example
     * // Delete one TailoringAttempt
     * const TailoringAttempt = await prisma.tailoringAttempt.delete({
     *   where: {
     *     // ... filter to delete one TailoringAttempt
     *   }
     * })
     * 
     */
    delete<T extends TailoringAttemptDeleteArgs>(args: SelectSubset<T, TailoringAttemptDeleteArgs<ExtArgs>>): Prisma__TailoringAttemptClient<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TailoringAttempt.
     * @param {TailoringAttemptUpdateArgs} args - Arguments to update one TailoringAttempt.
     * @example
     * // Update one TailoringAttempt
     * const tailoringAttempt = await prisma.tailoringAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TailoringAttemptUpdateArgs>(args: SelectSubset<T, TailoringAttemptUpdateArgs<ExtArgs>>): Prisma__TailoringAttemptClient<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TailoringAttempts.
     * @param {TailoringAttemptDeleteManyArgs} args - Arguments to filter TailoringAttempts to delete.
     * @example
     * // Delete a few TailoringAttempts
     * const { count } = await prisma.tailoringAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TailoringAttemptDeleteManyArgs>(args?: SelectSubset<T, TailoringAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailoringAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TailoringAttempts
     * const tailoringAttempt = await prisma.tailoringAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TailoringAttemptUpdateManyArgs>(args: SelectSubset<T, TailoringAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailoringAttempts and returns the data updated in the database.
     * @param {TailoringAttemptUpdateManyAndReturnArgs} args - Arguments to update many TailoringAttempts.
     * @example
     * // Update many TailoringAttempts
     * const tailoringAttempt = await prisma.tailoringAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TailoringAttempts and only return the `id`
     * const tailoringAttemptWithIdOnly = await prisma.tailoringAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TailoringAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, TailoringAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TailoringAttempt.
     * @param {TailoringAttemptUpsertArgs} args - Arguments to update or create a TailoringAttempt.
     * @example
     * // Update or create a TailoringAttempt
     * const tailoringAttempt = await prisma.tailoringAttempt.upsert({
     *   create: {
     *     // ... data to create a TailoringAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TailoringAttempt we want to update
     *   }
     * })
     */
    upsert<T extends TailoringAttemptUpsertArgs>(args: SelectSubset<T, TailoringAttemptUpsertArgs<ExtArgs>>): Prisma__TailoringAttemptClient<$Result.GetResult<Prisma.$TailoringAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TailoringAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAttemptCountArgs} args - Arguments to filter TailoringAttempts to count.
     * @example
     * // Count the number of TailoringAttempts
     * const count = await prisma.tailoringAttempt.count({
     *   where: {
     *     // ... the filter for the TailoringAttempts we want to count
     *   }
     * })
    **/
    count<T extends TailoringAttemptCountArgs>(
      args?: Subset<T, TailoringAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TailoringAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TailoringAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TailoringAttemptAggregateArgs>(args: Subset<T, TailoringAttemptAggregateArgs>): Prisma.PrismaPromise<GetTailoringAttemptAggregateType<T>>

    /**
     * Group by TailoringAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailoringAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TailoringAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TailoringAttemptGroupByArgs['orderBy'] }
        : { orderBy?: TailoringAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TailoringAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTailoringAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TailoringAttempt model
   */
  readonly fields: TailoringAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TailoringAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TailoringAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TailoringAttempt model
   */
  interface TailoringAttemptFieldRefs {
    readonly id: FieldRef<"TailoringAttempt", 'String'>
    readonly userId: FieldRef<"TailoringAttempt", 'String'>
    readonly resumeId: FieldRef<"TailoringAttempt", 'String'>
    readonly attemptNumber: FieldRef<"TailoringAttempt", 'Int'>
    readonly atsScore: FieldRef<"TailoringAttempt", 'Int'>
    readonly jdScore: FieldRef<"TailoringAttempt", 'Int'>
    readonly goldenPassed: FieldRef<"TailoringAttempt", 'Boolean'>
    readonly feedback: FieldRef<"TailoringAttempt", 'String'>
    readonly suggestions: FieldRef<"TailoringAttempt", 'String'>
    readonly atsFeedback: FieldRef<"TailoringAttempt", 'String'>
    readonly jdFeedback: FieldRef<"TailoringAttempt", 'String'>
    readonly createdAt: FieldRef<"TailoringAttempt", 'DateTime'>
    readonly modifiedSectionsSent: FieldRef<"TailoringAttempt", 'String'>
    readonly modifiedSectionsReceived: FieldRef<"TailoringAttempt", 'String'>
    readonly promptTokens: FieldRef<"TailoringAttempt", 'Int'>
    readonly goldenRuleFeedback: FieldRef<"TailoringAttempt", 'String'>
    readonly iteration: FieldRef<"TailoringAttempt", 'Int'>
    readonly modifiedSections: FieldRef<"TailoringAttempt", 'String'>
    readonly score: FieldRef<"TailoringAttempt", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TailoringAttempt findUnique
   */
  export type TailoringAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAttempt to fetch.
     */
    where: TailoringAttemptWhereUniqueInput
  }

  /**
   * TailoringAttempt findUniqueOrThrow
   */
  export type TailoringAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAttempt to fetch.
     */
    where: TailoringAttemptWhereUniqueInput
  }

  /**
   * TailoringAttempt findFirst
   */
  export type TailoringAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAttempt to fetch.
     */
    where?: TailoringAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringAttempts to fetch.
     */
    orderBy?: TailoringAttemptOrderByWithRelationInput | TailoringAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailoringAttempts.
     */
    cursor?: TailoringAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailoringAttempts.
     */
    distinct?: TailoringAttemptScalarFieldEnum | TailoringAttemptScalarFieldEnum[]
  }

  /**
   * TailoringAttempt findFirstOrThrow
   */
  export type TailoringAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAttempt to fetch.
     */
    where?: TailoringAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringAttempts to fetch.
     */
    orderBy?: TailoringAttemptOrderByWithRelationInput | TailoringAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailoringAttempts.
     */
    cursor?: TailoringAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailoringAttempts.
     */
    distinct?: TailoringAttemptScalarFieldEnum | TailoringAttemptScalarFieldEnum[]
  }

  /**
   * TailoringAttempt findMany
   */
  export type TailoringAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TailoringAttempts to fetch.
     */
    where?: TailoringAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailoringAttempts to fetch.
     */
    orderBy?: TailoringAttemptOrderByWithRelationInput | TailoringAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TailoringAttempts.
     */
    cursor?: TailoringAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailoringAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailoringAttempts.
     */
    skip?: number
    distinct?: TailoringAttemptScalarFieldEnum | TailoringAttemptScalarFieldEnum[]
  }

  /**
   * TailoringAttempt create
   */
  export type TailoringAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a TailoringAttempt.
     */
    data: XOR<TailoringAttemptCreateInput, TailoringAttemptUncheckedCreateInput>
  }

  /**
   * TailoringAttempt createMany
   */
  export type TailoringAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TailoringAttempts.
     */
    data: TailoringAttemptCreateManyInput | TailoringAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TailoringAttempt createManyAndReturn
   */
  export type TailoringAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many TailoringAttempts.
     */
    data: TailoringAttemptCreateManyInput | TailoringAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailoringAttempt update
   */
  export type TailoringAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a TailoringAttempt.
     */
    data: XOR<TailoringAttemptUpdateInput, TailoringAttemptUncheckedUpdateInput>
    /**
     * Choose, which TailoringAttempt to update.
     */
    where: TailoringAttemptWhereUniqueInput
  }

  /**
   * TailoringAttempt updateMany
   */
  export type TailoringAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TailoringAttempts.
     */
    data: XOR<TailoringAttemptUpdateManyMutationInput, TailoringAttemptUncheckedUpdateManyInput>
    /**
     * Filter which TailoringAttempts to update
     */
    where?: TailoringAttemptWhereInput
    /**
     * Limit how many TailoringAttempts to update.
     */
    limit?: number
  }

  /**
   * TailoringAttempt updateManyAndReturn
   */
  export type TailoringAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * The data used to update TailoringAttempts.
     */
    data: XOR<TailoringAttemptUpdateManyMutationInput, TailoringAttemptUncheckedUpdateManyInput>
    /**
     * Filter which TailoringAttempts to update
     */
    where?: TailoringAttemptWhereInput
    /**
     * Limit how many TailoringAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailoringAttempt upsert
   */
  export type TailoringAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the TailoringAttempt to update in case it exists.
     */
    where: TailoringAttemptWhereUniqueInput
    /**
     * In case the TailoringAttempt found by the `where` argument doesn't exist, create a new TailoringAttempt with this data.
     */
    create: XOR<TailoringAttemptCreateInput, TailoringAttemptUncheckedCreateInput>
    /**
     * In case the TailoringAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TailoringAttemptUpdateInput, TailoringAttemptUncheckedUpdateInput>
  }

  /**
   * TailoringAttempt delete
   */
  export type TailoringAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
    /**
     * Filter which TailoringAttempt to delete.
     */
    where: TailoringAttemptWhereUniqueInput
  }

  /**
   * TailoringAttempt deleteMany
   */
  export type TailoringAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailoringAttempts to delete
     */
    where?: TailoringAttemptWhereInput
    /**
     * Limit how many TailoringAttempts to delete.
     */
    limit?: number
  }

  /**
   * TailoringAttempt without action
   */
  export type TailoringAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailoringAttempt
     */
    select?: TailoringAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TailoringAttempt
     */
    omit?: TailoringAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailoringAttemptInclude<ExtArgs> | null
  }


  /**
   * Model ResumeFeedback
   */

  export type AggregateResumeFeedback = {
    _count: ResumeFeedbackCountAggregateOutputType | null
    _avg: ResumeFeedbackAvgAggregateOutputType | null
    _sum: ResumeFeedbackSumAggregateOutputType | null
    _min: ResumeFeedbackMinAggregateOutputType | null
    _max: ResumeFeedbackMaxAggregateOutputType | null
  }

  export type ResumeFeedbackAvgAggregateOutputType = {
    sourceVersion: number | null
  }

  export type ResumeFeedbackSumAggregateOutputType = {
    sourceVersion: number | null
  }

  export type ResumeFeedbackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    feedbackType: string | null
    sourceVersion: number | null
    createdAt: Date | null
  }

  export type ResumeFeedbackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    feedbackType: string | null
    sourceVersion: number | null
    createdAt: Date | null
  }

  export type ResumeFeedbackCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    feedbackType: number
    feedbackPoints: number
    sourceVersion: number
    createdAt: number
    _all: number
  }


  export type ResumeFeedbackAvgAggregateInputType = {
    sourceVersion?: true
  }

  export type ResumeFeedbackSumAggregateInputType = {
    sourceVersion?: true
  }

  export type ResumeFeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    feedbackType?: true
    sourceVersion?: true
    createdAt?: true
  }

  export type ResumeFeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    feedbackType?: true
    sourceVersion?: true
    createdAt?: true
  }

  export type ResumeFeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    feedbackType?: true
    feedbackPoints?: true
    sourceVersion?: true
    createdAt?: true
    _all?: true
  }

  export type ResumeFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeFeedback to aggregate.
     */
    where?: ResumeFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeFeedbacks to fetch.
     */
    orderBy?: ResumeFeedbackOrderByWithRelationInput | ResumeFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeFeedbacks
    **/
    _count?: true | ResumeFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumeFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumeFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeFeedbackMaxAggregateInputType
  }

  export type GetResumeFeedbackAggregateType<T extends ResumeFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeFeedback[P]>
      : GetScalarType<T[P], AggregateResumeFeedback[P]>
  }




  export type ResumeFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeFeedbackWhereInput
    orderBy?: ResumeFeedbackOrderByWithAggregationInput | ResumeFeedbackOrderByWithAggregationInput[]
    by: ResumeFeedbackScalarFieldEnum[] | ResumeFeedbackScalarFieldEnum
    having?: ResumeFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeFeedbackCountAggregateInputType | true
    _avg?: ResumeFeedbackAvgAggregateInputType
    _sum?: ResumeFeedbackSumAggregateInputType
    _min?: ResumeFeedbackMinAggregateInputType
    _max?: ResumeFeedbackMaxAggregateInputType
  }

  export type ResumeFeedbackGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    feedbackType: string
    feedbackPoints: string[]
    sourceVersion: number | null
    createdAt: Date
    _count: ResumeFeedbackCountAggregateOutputType | null
    _avg: ResumeFeedbackAvgAggregateOutputType | null
    _sum: ResumeFeedbackSumAggregateOutputType | null
    _min: ResumeFeedbackMinAggregateOutputType | null
    _max: ResumeFeedbackMaxAggregateOutputType | null
  }

  type GetResumeFeedbackGroupByPayload<T extends ResumeFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type ResumeFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    feedbackType?: boolean
    feedbackPoints?: boolean
    sourceVersion?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeFeedback"]>

  export type ResumeFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    feedbackType?: boolean
    feedbackPoints?: boolean
    sourceVersion?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeFeedback"]>

  export type ResumeFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    feedbackType?: boolean
    feedbackPoints?: boolean
    sourceVersion?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeFeedback"]>

  export type ResumeFeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    feedbackType?: boolean
    feedbackPoints?: boolean
    sourceVersion?: boolean
    createdAt?: boolean
  }

  export type ResumeFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "feedbackType" | "feedbackPoints" | "sourceVersion" | "createdAt", ExtArgs["result"]["resumeFeedback"]>
  export type ResumeFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ResumeFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeFeedback"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      feedbackType: string
      feedbackPoints: string[]
      sourceVersion: number | null
      createdAt: Date
    }, ExtArgs["result"]["resumeFeedback"]>
    composites: {}
  }

  type ResumeFeedbackGetPayload<S extends boolean | null | undefined | ResumeFeedbackDefaultArgs> = $Result.GetResult<Prisma.$ResumeFeedbackPayload, S>

  type ResumeFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeFeedbackCountAggregateInputType | true
    }

  export interface ResumeFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeFeedback'], meta: { name: 'ResumeFeedback' } }
    /**
     * Find zero or one ResumeFeedback that matches the filter.
     * @param {ResumeFeedbackFindUniqueArgs} args - Arguments to find a ResumeFeedback
     * @example
     * // Get one ResumeFeedback
     * const resumeFeedback = await prisma.resumeFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeFeedbackFindUniqueArgs>(args: SelectSubset<T, ResumeFeedbackFindUniqueArgs<ExtArgs>>): Prisma__ResumeFeedbackClient<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResumeFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeFeedbackFindUniqueOrThrowArgs} args - Arguments to find a ResumeFeedback
     * @example
     * // Get one ResumeFeedback
     * const resumeFeedback = await prisma.resumeFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeFeedbackClient<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFeedbackFindFirstArgs} args - Arguments to find a ResumeFeedback
     * @example
     * // Get one ResumeFeedback
     * const resumeFeedback = await prisma.resumeFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeFeedbackFindFirstArgs>(args?: SelectSubset<T, ResumeFeedbackFindFirstArgs<ExtArgs>>): Prisma__ResumeFeedbackClient<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFeedbackFindFirstOrThrowArgs} args - Arguments to find a ResumeFeedback
     * @example
     * // Get one ResumeFeedback
     * const resumeFeedback = await prisma.resumeFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeFeedbackClient<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResumeFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeFeedbacks
     * const resumeFeedbacks = await prisma.resumeFeedback.findMany()
     * 
     * // Get first 10 ResumeFeedbacks
     * const resumeFeedbacks = await prisma.resumeFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeFeedbackWithIdOnly = await prisma.resumeFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeFeedbackFindManyArgs>(args?: SelectSubset<T, ResumeFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResumeFeedback.
     * @param {ResumeFeedbackCreateArgs} args - Arguments to create a ResumeFeedback.
     * @example
     * // Create one ResumeFeedback
     * const ResumeFeedback = await prisma.resumeFeedback.create({
     *   data: {
     *     // ... data to create a ResumeFeedback
     *   }
     * })
     * 
     */
    create<T extends ResumeFeedbackCreateArgs>(args: SelectSubset<T, ResumeFeedbackCreateArgs<ExtArgs>>): Prisma__ResumeFeedbackClient<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResumeFeedbacks.
     * @param {ResumeFeedbackCreateManyArgs} args - Arguments to create many ResumeFeedbacks.
     * @example
     * // Create many ResumeFeedbacks
     * const resumeFeedback = await prisma.resumeFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeFeedbackCreateManyArgs>(args?: SelectSubset<T, ResumeFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResumeFeedbacks and returns the data saved in the database.
     * @param {ResumeFeedbackCreateManyAndReturnArgs} args - Arguments to create many ResumeFeedbacks.
     * @example
     * // Create many ResumeFeedbacks
     * const resumeFeedback = await prisma.resumeFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResumeFeedbacks and only return the `id`
     * const resumeFeedbackWithIdOnly = await prisma.resumeFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResumeFeedback.
     * @param {ResumeFeedbackDeleteArgs} args - Arguments to delete one ResumeFeedback.
     * @example
     * // Delete one ResumeFeedback
     * const ResumeFeedback = await prisma.resumeFeedback.delete({
     *   where: {
     *     // ... filter to delete one ResumeFeedback
     *   }
     * })
     * 
     */
    delete<T extends ResumeFeedbackDeleteArgs>(args: SelectSubset<T, ResumeFeedbackDeleteArgs<ExtArgs>>): Prisma__ResumeFeedbackClient<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResumeFeedback.
     * @param {ResumeFeedbackUpdateArgs} args - Arguments to update one ResumeFeedback.
     * @example
     * // Update one ResumeFeedback
     * const resumeFeedback = await prisma.resumeFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeFeedbackUpdateArgs>(args: SelectSubset<T, ResumeFeedbackUpdateArgs<ExtArgs>>): Prisma__ResumeFeedbackClient<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResumeFeedbacks.
     * @param {ResumeFeedbackDeleteManyArgs} args - Arguments to filter ResumeFeedbacks to delete.
     * @example
     * // Delete a few ResumeFeedbacks
     * const { count } = await prisma.resumeFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeFeedbackDeleteManyArgs>(args?: SelectSubset<T, ResumeFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeFeedbacks
     * const resumeFeedback = await prisma.resumeFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeFeedbackUpdateManyArgs>(args: SelectSubset<T, ResumeFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeFeedbacks and returns the data updated in the database.
     * @param {ResumeFeedbackUpdateManyAndReturnArgs} args - Arguments to update many ResumeFeedbacks.
     * @example
     * // Update many ResumeFeedbacks
     * const resumeFeedback = await prisma.resumeFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResumeFeedbacks and only return the `id`
     * const resumeFeedbackWithIdOnly = await prisma.resumeFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResumeFeedback.
     * @param {ResumeFeedbackUpsertArgs} args - Arguments to update or create a ResumeFeedback.
     * @example
     * // Update or create a ResumeFeedback
     * const resumeFeedback = await prisma.resumeFeedback.upsert({
     *   create: {
     *     // ... data to create a ResumeFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeFeedback we want to update
     *   }
     * })
     */
    upsert<T extends ResumeFeedbackUpsertArgs>(args: SelectSubset<T, ResumeFeedbackUpsertArgs<ExtArgs>>): Prisma__ResumeFeedbackClient<$Result.GetResult<Prisma.$ResumeFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResumeFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFeedbackCountArgs} args - Arguments to filter ResumeFeedbacks to count.
     * @example
     * // Count the number of ResumeFeedbacks
     * const count = await prisma.resumeFeedback.count({
     *   where: {
     *     // ... the filter for the ResumeFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends ResumeFeedbackCountArgs>(
      args?: Subset<T, ResumeFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeFeedbackAggregateArgs>(args: Subset<T, ResumeFeedbackAggregateArgs>): Prisma.PrismaPromise<GetResumeFeedbackAggregateType<T>>

    /**
     * Group by ResumeFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: ResumeFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeFeedback model
   */
  readonly fields: ResumeFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumeFeedback model
   */
  interface ResumeFeedbackFieldRefs {
    readonly id: FieldRef<"ResumeFeedback", 'String'>
    readonly userId: FieldRef<"ResumeFeedback", 'String'>
    readonly resumeId: FieldRef<"ResumeFeedback", 'String'>
    readonly feedbackType: FieldRef<"ResumeFeedback", 'String'>
    readonly feedbackPoints: FieldRef<"ResumeFeedback", 'String[]'>
    readonly sourceVersion: FieldRef<"ResumeFeedback", 'Int'>
    readonly createdAt: FieldRef<"ResumeFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResumeFeedback findUnique
   */
  export type ResumeFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ResumeFeedback to fetch.
     */
    where: ResumeFeedbackWhereUniqueInput
  }

  /**
   * ResumeFeedback findUniqueOrThrow
   */
  export type ResumeFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ResumeFeedback to fetch.
     */
    where: ResumeFeedbackWhereUniqueInput
  }

  /**
   * ResumeFeedback findFirst
   */
  export type ResumeFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ResumeFeedback to fetch.
     */
    where?: ResumeFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeFeedbacks to fetch.
     */
    orderBy?: ResumeFeedbackOrderByWithRelationInput | ResumeFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeFeedbacks.
     */
    cursor?: ResumeFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeFeedbacks.
     */
    distinct?: ResumeFeedbackScalarFieldEnum | ResumeFeedbackScalarFieldEnum[]
  }

  /**
   * ResumeFeedback findFirstOrThrow
   */
  export type ResumeFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ResumeFeedback to fetch.
     */
    where?: ResumeFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeFeedbacks to fetch.
     */
    orderBy?: ResumeFeedbackOrderByWithRelationInput | ResumeFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeFeedbacks.
     */
    cursor?: ResumeFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeFeedbacks.
     */
    distinct?: ResumeFeedbackScalarFieldEnum | ResumeFeedbackScalarFieldEnum[]
  }

  /**
   * ResumeFeedback findMany
   */
  export type ResumeFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ResumeFeedbacks to fetch.
     */
    where?: ResumeFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeFeedbacks to fetch.
     */
    orderBy?: ResumeFeedbackOrderByWithRelationInput | ResumeFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeFeedbacks.
     */
    cursor?: ResumeFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeFeedbacks.
     */
    skip?: number
    distinct?: ResumeFeedbackScalarFieldEnum | ResumeFeedbackScalarFieldEnum[]
  }

  /**
   * ResumeFeedback create
   */
  export type ResumeFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeFeedback.
     */
    data: XOR<ResumeFeedbackCreateInput, ResumeFeedbackUncheckedCreateInput>
  }

  /**
   * ResumeFeedback createMany
   */
  export type ResumeFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeFeedbacks.
     */
    data: ResumeFeedbackCreateManyInput | ResumeFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeFeedback createManyAndReturn
   */
  export type ResumeFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many ResumeFeedbacks.
     */
    data: ResumeFeedbackCreateManyInput | ResumeFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeFeedback update
   */
  export type ResumeFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeFeedback.
     */
    data: XOR<ResumeFeedbackUpdateInput, ResumeFeedbackUncheckedUpdateInput>
    /**
     * Choose, which ResumeFeedback to update.
     */
    where: ResumeFeedbackWhereUniqueInput
  }

  /**
   * ResumeFeedback updateMany
   */
  export type ResumeFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeFeedbacks.
     */
    data: XOR<ResumeFeedbackUpdateManyMutationInput, ResumeFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which ResumeFeedbacks to update
     */
    where?: ResumeFeedbackWhereInput
    /**
     * Limit how many ResumeFeedbacks to update.
     */
    limit?: number
  }

  /**
   * ResumeFeedback updateManyAndReturn
   */
  export type ResumeFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update ResumeFeedbacks.
     */
    data: XOR<ResumeFeedbackUpdateManyMutationInput, ResumeFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which ResumeFeedbacks to update
     */
    where?: ResumeFeedbackWhereInput
    /**
     * Limit how many ResumeFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeFeedback upsert
   */
  export type ResumeFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeFeedback to update in case it exists.
     */
    where: ResumeFeedbackWhereUniqueInput
    /**
     * In case the ResumeFeedback found by the `where` argument doesn't exist, create a new ResumeFeedback with this data.
     */
    create: XOR<ResumeFeedbackCreateInput, ResumeFeedbackUncheckedCreateInput>
    /**
     * In case the ResumeFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeFeedbackUpdateInput, ResumeFeedbackUncheckedUpdateInput>
  }

  /**
   * ResumeFeedback delete
   */
  export type ResumeFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
    /**
     * Filter which ResumeFeedback to delete.
     */
    where: ResumeFeedbackWhereUniqueInput
  }

  /**
   * ResumeFeedback deleteMany
   */
  export type ResumeFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeFeedbacks to delete
     */
    where?: ResumeFeedbackWhereInput
    /**
     * Limit how many ResumeFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * ResumeFeedback without action
   */
  export type ResumeFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeFeedback
     */
    select?: ResumeFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeFeedback
     */
    omit?: ResumeFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model ManualEdit
   */

  export type AggregateManualEdit = {
    _count: ManualEditCountAggregateOutputType | null
    _min: ManualEditMinAggregateOutputType | null
    _max: ManualEditMaxAggregateOutputType | null
  }

  export type ManualEditMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    editedText: string | null
    createdAt: Date | null
  }

  export type ManualEditMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    editedText: string | null
    createdAt: Date | null
  }

  export type ManualEditCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    editedText: number
    createdAt: number
    _all: number
  }


  export type ManualEditMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    editedText?: true
    createdAt?: true
  }

  export type ManualEditMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    editedText?: true
    createdAt?: true
  }

  export type ManualEditCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    editedText?: true
    createdAt?: true
    _all?: true
  }

  export type ManualEditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualEdit to aggregate.
     */
    where?: ManualEditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualEdits to fetch.
     */
    orderBy?: ManualEditOrderByWithRelationInput | ManualEditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManualEditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualEdits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualEdits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManualEdits
    **/
    _count?: true | ManualEditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManualEditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManualEditMaxAggregateInputType
  }

  export type GetManualEditAggregateType<T extends ManualEditAggregateArgs> = {
        [P in keyof T & keyof AggregateManualEdit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManualEdit[P]>
      : GetScalarType<T[P], AggregateManualEdit[P]>
  }




  export type ManualEditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualEditWhereInput
    orderBy?: ManualEditOrderByWithAggregationInput | ManualEditOrderByWithAggregationInput[]
    by: ManualEditScalarFieldEnum[] | ManualEditScalarFieldEnum
    having?: ManualEditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManualEditCountAggregateInputType | true
    _min?: ManualEditMinAggregateInputType
    _max?: ManualEditMaxAggregateInputType
  }

  export type ManualEditGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    editedText: string
    createdAt: Date
    _count: ManualEditCountAggregateOutputType | null
    _min: ManualEditMinAggregateOutputType | null
    _max: ManualEditMaxAggregateOutputType | null
  }

  type GetManualEditGroupByPayload<T extends ManualEditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManualEditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManualEditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManualEditGroupByOutputType[P]>
            : GetScalarType<T[P], ManualEditGroupByOutputType[P]>
        }
      >
    >


  export type ManualEditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    editedText?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualEdit"]>

  export type ManualEditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    editedText?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualEdit"]>

  export type ManualEditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    editedText?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualEdit"]>

  export type ManualEditSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    editedText?: boolean
    createdAt?: boolean
  }

  export type ManualEditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "editedText" | "createdAt", ExtArgs["result"]["manualEdit"]>
  export type ManualEditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ManualEditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ManualEditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ManualEditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManualEdit"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      editedText: string
      createdAt: Date
    }, ExtArgs["result"]["manualEdit"]>
    composites: {}
  }

  type ManualEditGetPayload<S extends boolean | null | undefined | ManualEditDefaultArgs> = $Result.GetResult<Prisma.$ManualEditPayload, S>

  type ManualEditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManualEditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManualEditCountAggregateInputType | true
    }

  export interface ManualEditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManualEdit'], meta: { name: 'ManualEdit' } }
    /**
     * Find zero or one ManualEdit that matches the filter.
     * @param {ManualEditFindUniqueArgs} args - Arguments to find a ManualEdit
     * @example
     * // Get one ManualEdit
     * const manualEdit = await prisma.manualEdit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManualEditFindUniqueArgs>(args: SelectSubset<T, ManualEditFindUniqueArgs<ExtArgs>>): Prisma__ManualEditClient<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManualEdit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManualEditFindUniqueOrThrowArgs} args - Arguments to find a ManualEdit
     * @example
     * // Get one ManualEdit
     * const manualEdit = await prisma.manualEdit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManualEditFindUniqueOrThrowArgs>(args: SelectSubset<T, ManualEditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManualEditClient<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualEdit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualEditFindFirstArgs} args - Arguments to find a ManualEdit
     * @example
     * // Get one ManualEdit
     * const manualEdit = await prisma.manualEdit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManualEditFindFirstArgs>(args?: SelectSubset<T, ManualEditFindFirstArgs<ExtArgs>>): Prisma__ManualEditClient<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualEdit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualEditFindFirstOrThrowArgs} args - Arguments to find a ManualEdit
     * @example
     * // Get one ManualEdit
     * const manualEdit = await prisma.manualEdit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManualEditFindFirstOrThrowArgs>(args?: SelectSubset<T, ManualEditFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManualEditClient<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManualEdits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualEditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManualEdits
     * const manualEdits = await prisma.manualEdit.findMany()
     * 
     * // Get first 10 ManualEdits
     * const manualEdits = await prisma.manualEdit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manualEditWithIdOnly = await prisma.manualEdit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManualEditFindManyArgs>(args?: SelectSubset<T, ManualEditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManualEdit.
     * @param {ManualEditCreateArgs} args - Arguments to create a ManualEdit.
     * @example
     * // Create one ManualEdit
     * const ManualEdit = await prisma.manualEdit.create({
     *   data: {
     *     // ... data to create a ManualEdit
     *   }
     * })
     * 
     */
    create<T extends ManualEditCreateArgs>(args: SelectSubset<T, ManualEditCreateArgs<ExtArgs>>): Prisma__ManualEditClient<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManualEdits.
     * @param {ManualEditCreateManyArgs} args - Arguments to create many ManualEdits.
     * @example
     * // Create many ManualEdits
     * const manualEdit = await prisma.manualEdit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManualEditCreateManyArgs>(args?: SelectSubset<T, ManualEditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ManualEdits and returns the data saved in the database.
     * @param {ManualEditCreateManyAndReturnArgs} args - Arguments to create many ManualEdits.
     * @example
     * // Create many ManualEdits
     * const manualEdit = await prisma.manualEdit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ManualEdits and only return the `id`
     * const manualEditWithIdOnly = await prisma.manualEdit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManualEditCreateManyAndReturnArgs>(args?: SelectSubset<T, ManualEditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ManualEdit.
     * @param {ManualEditDeleteArgs} args - Arguments to delete one ManualEdit.
     * @example
     * // Delete one ManualEdit
     * const ManualEdit = await prisma.manualEdit.delete({
     *   where: {
     *     // ... filter to delete one ManualEdit
     *   }
     * })
     * 
     */
    delete<T extends ManualEditDeleteArgs>(args: SelectSubset<T, ManualEditDeleteArgs<ExtArgs>>): Prisma__ManualEditClient<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManualEdit.
     * @param {ManualEditUpdateArgs} args - Arguments to update one ManualEdit.
     * @example
     * // Update one ManualEdit
     * const manualEdit = await prisma.manualEdit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManualEditUpdateArgs>(args: SelectSubset<T, ManualEditUpdateArgs<ExtArgs>>): Prisma__ManualEditClient<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManualEdits.
     * @param {ManualEditDeleteManyArgs} args - Arguments to filter ManualEdits to delete.
     * @example
     * // Delete a few ManualEdits
     * const { count } = await prisma.manualEdit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManualEditDeleteManyArgs>(args?: SelectSubset<T, ManualEditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualEdits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualEditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManualEdits
     * const manualEdit = await prisma.manualEdit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManualEditUpdateManyArgs>(args: SelectSubset<T, ManualEditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualEdits and returns the data updated in the database.
     * @param {ManualEditUpdateManyAndReturnArgs} args - Arguments to update many ManualEdits.
     * @example
     * // Update many ManualEdits
     * const manualEdit = await prisma.manualEdit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ManualEdits and only return the `id`
     * const manualEditWithIdOnly = await prisma.manualEdit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManualEditUpdateManyAndReturnArgs>(args: SelectSubset<T, ManualEditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ManualEdit.
     * @param {ManualEditUpsertArgs} args - Arguments to update or create a ManualEdit.
     * @example
     * // Update or create a ManualEdit
     * const manualEdit = await prisma.manualEdit.upsert({
     *   create: {
     *     // ... data to create a ManualEdit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManualEdit we want to update
     *   }
     * })
     */
    upsert<T extends ManualEditUpsertArgs>(args: SelectSubset<T, ManualEditUpsertArgs<ExtArgs>>): Prisma__ManualEditClient<$Result.GetResult<Prisma.$ManualEditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManualEdits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualEditCountArgs} args - Arguments to filter ManualEdits to count.
     * @example
     * // Count the number of ManualEdits
     * const count = await prisma.manualEdit.count({
     *   where: {
     *     // ... the filter for the ManualEdits we want to count
     *   }
     * })
    **/
    count<T extends ManualEditCountArgs>(
      args?: Subset<T, ManualEditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManualEditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManualEdit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualEditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManualEditAggregateArgs>(args: Subset<T, ManualEditAggregateArgs>): Prisma.PrismaPromise<GetManualEditAggregateType<T>>

    /**
     * Group by ManualEdit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualEditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManualEditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManualEditGroupByArgs['orderBy'] }
        : { orderBy?: ManualEditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManualEditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManualEditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManualEdit model
   */
  readonly fields: ManualEditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManualEdit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManualEditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManualEdit model
   */
  interface ManualEditFieldRefs {
    readonly id: FieldRef<"ManualEdit", 'String'>
    readonly userId: FieldRef<"ManualEdit", 'String'>
    readonly resumeId: FieldRef<"ManualEdit", 'String'>
    readonly editedText: FieldRef<"ManualEdit", 'String'>
    readonly createdAt: FieldRef<"ManualEdit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ManualEdit findUnique
   */
  export type ManualEditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * Filter, which ManualEdit to fetch.
     */
    where: ManualEditWhereUniqueInput
  }

  /**
   * ManualEdit findUniqueOrThrow
   */
  export type ManualEditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * Filter, which ManualEdit to fetch.
     */
    where: ManualEditWhereUniqueInput
  }

  /**
   * ManualEdit findFirst
   */
  export type ManualEditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * Filter, which ManualEdit to fetch.
     */
    where?: ManualEditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualEdits to fetch.
     */
    orderBy?: ManualEditOrderByWithRelationInput | ManualEditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualEdits.
     */
    cursor?: ManualEditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualEdits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualEdits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualEdits.
     */
    distinct?: ManualEditScalarFieldEnum | ManualEditScalarFieldEnum[]
  }

  /**
   * ManualEdit findFirstOrThrow
   */
  export type ManualEditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * Filter, which ManualEdit to fetch.
     */
    where?: ManualEditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualEdits to fetch.
     */
    orderBy?: ManualEditOrderByWithRelationInput | ManualEditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualEdits.
     */
    cursor?: ManualEditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualEdits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualEdits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualEdits.
     */
    distinct?: ManualEditScalarFieldEnum | ManualEditScalarFieldEnum[]
  }

  /**
   * ManualEdit findMany
   */
  export type ManualEditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * Filter, which ManualEdits to fetch.
     */
    where?: ManualEditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualEdits to fetch.
     */
    orderBy?: ManualEditOrderByWithRelationInput | ManualEditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManualEdits.
     */
    cursor?: ManualEditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualEdits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualEdits.
     */
    skip?: number
    distinct?: ManualEditScalarFieldEnum | ManualEditScalarFieldEnum[]
  }

  /**
   * ManualEdit create
   */
  export type ManualEditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * The data needed to create a ManualEdit.
     */
    data: XOR<ManualEditCreateInput, ManualEditUncheckedCreateInput>
  }

  /**
   * ManualEdit createMany
   */
  export type ManualEditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManualEdits.
     */
    data: ManualEditCreateManyInput | ManualEditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManualEdit createManyAndReturn
   */
  export type ManualEditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * The data used to create many ManualEdits.
     */
    data: ManualEditCreateManyInput | ManualEditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManualEdit update
   */
  export type ManualEditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * The data needed to update a ManualEdit.
     */
    data: XOR<ManualEditUpdateInput, ManualEditUncheckedUpdateInput>
    /**
     * Choose, which ManualEdit to update.
     */
    where: ManualEditWhereUniqueInput
  }

  /**
   * ManualEdit updateMany
   */
  export type ManualEditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManualEdits.
     */
    data: XOR<ManualEditUpdateManyMutationInput, ManualEditUncheckedUpdateManyInput>
    /**
     * Filter which ManualEdits to update
     */
    where?: ManualEditWhereInput
    /**
     * Limit how many ManualEdits to update.
     */
    limit?: number
  }

  /**
   * ManualEdit updateManyAndReturn
   */
  export type ManualEditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * The data used to update ManualEdits.
     */
    data: XOR<ManualEditUpdateManyMutationInput, ManualEditUncheckedUpdateManyInput>
    /**
     * Filter which ManualEdits to update
     */
    where?: ManualEditWhereInput
    /**
     * Limit how many ManualEdits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManualEdit upsert
   */
  export type ManualEditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * The filter to search for the ManualEdit to update in case it exists.
     */
    where: ManualEditWhereUniqueInput
    /**
     * In case the ManualEdit found by the `where` argument doesn't exist, create a new ManualEdit with this data.
     */
    create: XOR<ManualEditCreateInput, ManualEditUncheckedCreateInput>
    /**
     * In case the ManualEdit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManualEditUpdateInput, ManualEditUncheckedUpdateInput>
  }

  /**
   * ManualEdit delete
   */
  export type ManualEditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
    /**
     * Filter which ManualEdit to delete.
     */
    where: ManualEditWhereUniqueInput
  }

  /**
   * ManualEdit deleteMany
   */
  export type ManualEditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualEdits to delete
     */
    where?: ManualEditWhereInput
    /**
     * Limit how many ManualEdits to delete.
     */
    limit?: number
  }

  /**
   * ManualEdit without action
   */
  export type ManualEditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualEdit
     */
    select?: ManualEditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualEdit
     */
    omit?: ManualEditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualEditInclude<ExtArgs> | null
  }


  /**
   * Model ManualScoring
   */

  export type AggregateManualScoring = {
    _count: ManualScoringCountAggregateOutputType | null
    _avg: ManualScoringAvgAggregateOutputType | null
    _sum: ManualScoringSumAggregateOutputType | null
    _min: ManualScoringMinAggregateOutputType | null
    _max: ManualScoringMaxAggregateOutputType | null
  }

  export type ManualScoringAvgAggregateOutputType = {
    atsScore: number | null
    jdScore: number | null
  }

  export type ManualScoringSumAggregateOutputType = {
    atsScore: number | null
    jdScore: number | null
  }

  export type ManualScoringMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    atsScore: number | null
    jdScore: number | null
    atsFeedback: string | null
    jdFeedback: string | null
    createdAt: Date | null
  }

  export type ManualScoringMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    atsScore: number | null
    jdScore: number | null
    atsFeedback: string | null
    jdFeedback: string | null
    createdAt: Date | null
  }

  export type ManualScoringCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    atsScore: number
    jdScore: number
    atsFeedback: number
    jdFeedback: number
    createdAt: number
    _all: number
  }


  export type ManualScoringAvgAggregateInputType = {
    atsScore?: true
    jdScore?: true
  }

  export type ManualScoringSumAggregateInputType = {
    atsScore?: true
    jdScore?: true
  }

  export type ManualScoringMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    atsScore?: true
    jdScore?: true
    atsFeedback?: true
    jdFeedback?: true
    createdAt?: true
  }

  export type ManualScoringMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    atsScore?: true
    jdScore?: true
    atsFeedback?: true
    jdFeedback?: true
    createdAt?: true
  }

  export type ManualScoringCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    atsScore?: true
    jdScore?: true
    atsFeedback?: true
    jdFeedback?: true
    createdAt?: true
    _all?: true
  }

  export type ManualScoringAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualScoring to aggregate.
     */
    where?: ManualScoringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualScorings to fetch.
     */
    orderBy?: ManualScoringOrderByWithRelationInput | ManualScoringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManualScoringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualScorings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualScorings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManualScorings
    **/
    _count?: true | ManualScoringCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManualScoringAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManualScoringSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManualScoringMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManualScoringMaxAggregateInputType
  }

  export type GetManualScoringAggregateType<T extends ManualScoringAggregateArgs> = {
        [P in keyof T & keyof AggregateManualScoring]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManualScoring[P]>
      : GetScalarType<T[P], AggregateManualScoring[P]>
  }




  export type ManualScoringGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualScoringWhereInput
    orderBy?: ManualScoringOrderByWithAggregationInput | ManualScoringOrderByWithAggregationInput[]
    by: ManualScoringScalarFieldEnum[] | ManualScoringScalarFieldEnum
    having?: ManualScoringScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManualScoringCountAggregateInputType | true
    _avg?: ManualScoringAvgAggregateInputType
    _sum?: ManualScoringSumAggregateInputType
    _min?: ManualScoringMinAggregateInputType
    _max?: ManualScoringMaxAggregateInputType
  }

  export type ManualScoringGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    atsScore: number
    jdScore: number
    atsFeedback: string | null
    jdFeedback: string | null
    createdAt: Date
    _count: ManualScoringCountAggregateOutputType | null
    _avg: ManualScoringAvgAggregateOutputType | null
    _sum: ManualScoringSumAggregateOutputType | null
    _min: ManualScoringMinAggregateOutputType | null
    _max: ManualScoringMaxAggregateOutputType | null
  }

  type GetManualScoringGroupByPayload<T extends ManualScoringGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManualScoringGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManualScoringGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManualScoringGroupByOutputType[P]>
            : GetScalarType<T[P], ManualScoringGroupByOutputType[P]>
        }
      >
    >


  export type ManualScoringSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    atsScore?: boolean
    jdScore?: boolean
    atsFeedback?: boolean
    jdFeedback?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualScoring"]>

  export type ManualScoringSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    atsScore?: boolean
    jdScore?: boolean
    atsFeedback?: boolean
    jdFeedback?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualScoring"]>

  export type ManualScoringSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    atsScore?: boolean
    jdScore?: boolean
    atsFeedback?: boolean
    jdFeedback?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualScoring"]>

  export type ManualScoringSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    atsScore?: boolean
    jdScore?: boolean
    atsFeedback?: boolean
    jdFeedback?: boolean
    createdAt?: boolean
  }

  export type ManualScoringOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "atsScore" | "jdScore" | "atsFeedback" | "jdFeedback" | "createdAt", ExtArgs["result"]["manualScoring"]>
  export type ManualScoringInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ManualScoringIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ManualScoringIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ManualScoringPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManualScoring"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      atsScore: number
      jdScore: number
      atsFeedback: string | null
      jdFeedback: string | null
      createdAt: Date
    }, ExtArgs["result"]["manualScoring"]>
    composites: {}
  }

  type ManualScoringGetPayload<S extends boolean | null | undefined | ManualScoringDefaultArgs> = $Result.GetResult<Prisma.$ManualScoringPayload, S>

  type ManualScoringCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManualScoringFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManualScoringCountAggregateInputType | true
    }

  export interface ManualScoringDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManualScoring'], meta: { name: 'ManualScoring' } }
    /**
     * Find zero or one ManualScoring that matches the filter.
     * @param {ManualScoringFindUniqueArgs} args - Arguments to find a ManualScoring
     * @example
     * // Get one ManualScoring
     * const manualScoring = await prisma.manualScoring.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManualScoringFindUniqueArgs>(args: SelectSubset<T, ManualScoringFindUniqueArgs<ExtArgs>>): Prisma__ManualScoringClient<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManualScoring that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManualScoringFindUniqueOrThrowArgs} args - Arguments to find a ManualScoring
     * @example
     * // Get one ManualScoring
     * const manualScoring = await prisma.manualScoring.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManualScoringFindUniqueOrThrowArgs>(args: SelectSubset<T, ManualScoringFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManualScoringClient<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualScoring that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualScoringFindFirstArgs} args - Arguments to find a ManualScoring
     * @example
     * // Get one ManualScoring
     * const manualScoring = await prisma.manualScoring.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManualScoringFindFirstArgs>(args?: SelectSubset<T, ManualScoringFindFirstArgs<ExtArgs>>): Prisma__ManualScoringClient<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualScoring that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualScoringFindFirstOrThrowArgs} args - Arguments to find a ManualScoring
     * @example
     * // Get one ManualScoring
     * const manualScoring = await prisma.manualScoring.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManualScoringFindFirstOrThrowArgs>(args?: SelectSubset<T, ManualScoringFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManualScoringClient<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManualScorings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualScoringFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManualScorings
     * const manualScorings = await prisma.manualScoring.findMany()
     * 
     * // Get first 10 ManualScorings
     * const manualScorings = await prisma.manualScoring.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manualScoringWithIdOnly = await prisma.manualScoring.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManualScoringFindManyArgs>(args?: SelectSubset<T, ManualScoringFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManualScoring.
     * @param {ManualScoringCreateArgs} args - Arguments to create a ManualScoring.
     * @example
     * // Create one ManualScoring
     * const ManualScoring = await prisma.manualScoring.create({
     *   data: {
     *     // ... data to create a ManualScoring
     *   }
     * })
     * 
     */
    create<T extends ManualScoringCreateArgs>(args: SelectSubset<T, ManualScoringCreateArgs<ExtArgs>>): Prisma__ManualScoringClient<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManualScorings.
     * @param {ManualScoringCreateManyArgs} args - Arguments to create many ManualScorings.
     * @example
     * // Create many ManualScorings
     * const manualScoring = await prisma.manualScoring.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManualScoringCreateManyArgs>(args?: SelectSubset<T, ManualScoringCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ManualScorings and returns the data saved in the database.
     * @param {ManualScoringCreateManyAndReturnArgs} args - Arguments to create many ManualScorings.
     * @example
     * // Create many ManualScorings
     * const manualScoring = await prisma.manualScoring.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ManualScorings and only return the `id`
     * const manualScoringWithIdOnly = await prisma.manualScoring.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManualScoringCreateManyAndReturnArgs>(args?: SelectSubset<T, ManualScoringCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ManualScoring.
     * @param {ManualScoringDeleteArgs} args - Arguments to delete one ManualScoring.
     * @example
     * // Delete one ManualScoring
     * const ManualScoring = await prisma.manualScoring.delete({
     *   where: {
     *     // ... filter to delete one ManualScoring
     *   }
     * })
     * 
     */
    delete<T extends ManualScoringDeleteArgs>(args: SelectSubset<T, ManualScoringDeleteArgs<ExtArgs>>): Prisma__ManualScoringClient<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManualScoring.
     * @param {ManualScoringUpdateArgs} args - Arguments to update one ManualScoring.
     * @example
     * // Update one ManualScoring
     * const manualScoring = await prisma.manualScoring.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManualScoringUpdateArgs>(args: SelectSubset<T, ManualScoringUpdateArgs<ExtArgs>>): Prisma__ManualScoringClient<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManualScorings.
     * @param {ManualScoringDeleteManyArgs} args - Arguments to filter ManualScorings to delete.
     * @example
     * // Delete a few ManualScorings
     * const { count } = await prisma.manualScoring.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManualScoringDeleteManyArgs>(args?: SelectSubset<T, ManualScoringDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualScorings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualScoringUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManualScorings
     * const manualScoring = await prisma.manualScoring.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManualScoringUpdateManyArgs>(args: SelectSubset<T, ManualScoringUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualScorings and returns the data updated in the database.
     * @param {ManualScoringUpdateManyAndReturnArgs} args - Arguments to update many ManualScorings.
     * @example
     * // Update many ManualScorings
     * const manualScoring = await prisma.manualScoring.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ManualScorings and only return the `id`
     * const manualScoringWithIdOnly = await prisma.manualScoring.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManualScoringUpdateManyAndReturnArgs>(args: SelectSubset<T, ManualScoringUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ManualScoring.
     * @param {ManualScoringUpsertArgs} args - Arguments to update or create a ManualScoring.
     * @example
     * // Update or create a ManualScoring
     * const manualScoring = await prisma.manualScoring.upsert({
     *   create: {
     *     // ... data to create a ManualScoring
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManualScoring we want to update
     *   }
     * })
     */
    upsert<T extends ManualScoringUpsertArgs>(args: SelectSubset<T, ManualScoringUpsertArgs<ExtArgs>>): Prisma__ManualScoringClient<$Result.GetResult<Prisma.$ManualScoringPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManualScorings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualScoringCountArgs} args - Arguments to filter ManualScorings to count.
     * @example
     * // Count the number of ManualScorings
     * const count = await prisma.manualScoring.count({
     *   where: {
     *     // ... the filter for the ManualScorings we want to count
     *   }
     * })
    **/
    count<T extends ManualScoringCountArgs>(
      args?: Subset<T, ManualScoringCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManualScoringCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManualScoring.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualScoringAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManualScoringAggregateArgs>(args: Subset<T, ManualScoringAggregateArgs>): Prisma.PrismaPromise<GetManualScoringAggregateType<T>>

    /**
     * Group by ManualScoring.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualScoringGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManualScoringGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManualScoringGroupByArgs['orderBy'] }
        : { orderBy?: ManualScoringGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManualScoringGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManualScoringGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManualScoring model
   */
  readonly fields: ManualScoringFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManualScoring.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManualScoringClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManualScoring model
   */
  interface ManualScoringFieldRefs {
    readonly id: FieldRef<"ManualScoring", 'String'>
    readonly userId: FieldRef<"ManualScoring", 'String'>
    readonly resumeId: FieldRef<"ManualScoring", 'String'>
    readonly atsScore: FieldRef<"ManualScoring", 'Int'>
    readonly jdScore: FieldRef<"ManualScoring", 'Int'>
    readonly atsFeedback: FieldRef<"ManualScoring", 'String'>
    readonly jdFeedback: FieldRef<"ManualScoring", 'String'>
    readonly createdAt: FieldRef<"ManualScoring", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ManualScoring findUnique
   */
  export type ManualScoringFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * Filter, which ManualScoring to fetch.
     */
    where: ManualScoringWhereUniqueInput
  }

  /**
   * ManualScoring findUniqueOrThrow
   */
  export type ManualScoringFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * Filter, which ManualScoring to fetch.
     */
    where: ManualScoringWhereUniqueInput
  }

  /**
   * ManualScoring findFirst
   */
  export type ManualScoringFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * Filter, which ManualScoring to fetch.
     */
    where?: ManualScoringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualScorings to fetch.
     */
    orderBy?: ManualScoringOrderByWithRelationInput | ManualScoringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualScorings.
     */
    cursor?: ManualScoringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualScorings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualScorings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualScorings.
     */
    distinct?: ManualScoringScalarFieldEnum | ManualScoringScalarFieldEnum[]
  }

  /**
   * ManualScoring findFirstOrThrow
   */
  export type ManualScoringFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * Filter, which ManualScoring to fetch.
     */
    where?: ManualScoringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualScorings to fetch.
     */
    orderBy?: ManualScoringOrderByWithRelationInput | ManualScoringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualScorings.
     */
    cursor?: ManualScoringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualScorings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualScorings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualScorings.
     */
    distinct?: ManualScoringScalarFieldEnum | ManualScoringScalarFieldEnum[]
  }

  /**
   * ManualScoring findMany
   */
  export type ManualScoringFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * Filter, which ManualScorings to fetch.
     */
    where?: ManualScoringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualScorings to fetch.
     */
    orderBy?: ManualScoringOrderByWithRelationInput | ManualScoringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManualScorings.
     */
    cursor?: ManualScoringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualScorings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualScorings.
     */
    skip?: number
    distinct?: ManualScoringScalarFieldEnum | ManualScoringScalarFieldEnum[]
  }

  /**
   * ManualScoring create
   */
  export type ManualScoringCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * The data needed to create a ManualScoring.
     */
    data: XOR<ManualScoringCreateInput, ManualScoringUncheckedCreateInput>
  }

  /**
   * ManualScoring createMany
   */
  export type ManualScoringCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManualScorings.
     */
    data: ManualScoringCreateManyInput | ManualScoringCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManualScoring createManyAndReturn
   */
  export type ManualScoringCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * The data used to create many ManualScorings.
     */
    data: ManualScoringCreateManyInput | ManualScoringCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManualScoring update
   */
  export type ManualScoringUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * The data needed to update a ManualScoring.
     */
    data: XOR<ManualScoringUpdateInput, ManualScoringUncheckedUpdateInput>
    /**
     * Choose, which ManualScoring to update.
     */
    where: ManualScoringWhereUniqueInput
  }

  /**
   * ManualScoring updateMany
   */
  export type ManualScoringUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManualScorings.
     */
    data: XOR<ManualScoringUpdateManyMutationInput, ManualScoringUncheckedUpdateManyInput>
    /**
     * Filter which ManualScorings to update
     */
    where?: ManualScoringWhereInput
    /**
     * Limit how many ManualScorings to update.
     */
    limit?: number
  }

  /**
   * ManualScoring updateManyAndReturn
   */
  export type ManualScoringUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * The data used to update ManualScorings.
     */
    data: XOR<ManualScoringUpdateManyMutationInput, ManualScoringUncheckedUpdateManyInput>
    /**
     * Filter which ManualScorings to update
     */
    where?: ManualScoringWhereInput
    /**
     * Limit how many ManualScorings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManualScoring upsert
   */
  export type ManualScoringUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * The filter to search for the ManualScoring to update in case it exists.
     */
    where: ManualScoringWhereUniqueInput
    /**
     * In case the ManualScoring found by the `where` argument doesn't exist, create a new ManualScoring with this data.
     */
    create: XOR<ManualScoringCreateInput, ManualScoringUncheckedCreateInput>
    /**
     * In case the ManualScoring was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManualScoringUpdateInput, ManualScoringUncheckedUpdateInput>
  }

  /**
   * ManualScoring delete
   */
  export type ManualScoringDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
    /**
     * Filter which ManualScoring to delete.
     */
    where: ManualScoringWhereUniqueInput
  }

  /**
   * ManualScoring deleteMany
   */
  export type ManualScoringDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualScorings to delete
     */
    where?: ManualScoringWhereInput
    /**
     * Limit how many ManualScorings to delete.
     */
    limit?: number
  }

  /**
   * ManualScoring without action
   */
  export type ManualScoringDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualScoring
     */
    select?: ManualScoringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualScoring
     */
    omit?: ManualScoringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualScoringInclude<ExtArgs> | null
  }


  /**
   * Model CoverLetter
   */

  export type AggregateCoverLetter = {
    _count: CoverLetterCountAggregateOutputType | null
    _avg: CoverLetterAvgAggregateOutputType | null
    _sum: CoverLetterSumAggregateOutputType | null
    _min: CoverLetterMinAggregateOutputType | null
    _max: CoverLetterMaxAggregateOutputType | null
  }

  export type CoverLetterAvgAggregateOutputType = {
    atsScore: number | null
    jdScore: number | null
    version: number | null
  }

  export type CoverLetterSumAggregateOutputType = {
    atsScore: number | null
    jdScore: number | null
    version: number | null
  }

  export type CoverLetterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    jobDescription: string | null
    content: string | null
    tone: string | null
    atsScore: number | null
    jdScore: number | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoverLetterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    jobDescription: string | null
    content: string | null
    tone: string | null
    atsScore: number | null
    jdScore: number | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoverLetterCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    jobDescription: number
    content: number
    tone: number
    atsScore: number
    jdScore: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoverLetterAvgAggregateInputType = {
    atsScore?: true
    jdScore?: true
    version?: true
  }

  export type CoverLetterSumAggregateInputType = {
    atsScore?: true
    jdScore?: true
    version?: true
  }

  export type CoverLetterMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    jobDescription?: true
    content?: true
    tone?: true
    atsScore?: true
    jdScore?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoverLetterMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    jobDescription?: true
    content?: true
    tone?: true
    atsScore?: true
    jdScore?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoverLetterCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    jobDescription?: true
    content?: true
    tone?: true
    atsScore?: true
    jdScore?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoverLetterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoverLetter to aggregate.
     */
    where?: CoverLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverLetters to fetch.
     */
    orderBy?: CoverLetterOrderByWithRelationInput | CoverLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoverLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoverLetters
    **/
    _count?: true | CoverLetterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoverLetterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoverLetterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoverLetterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoverLetterMaxAggregateInputType
  }

  export type GetCoverLetterAggregateType<T extends CoverLetterAggregateArgs> = {
        [P in keyof T & keyof AggregateCoverLetter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoverLetter[P]>
      : GetScalarType<T[P], AggregateCoverLetter[P]>
  }




  export type CoverLetterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoverLetterWhereInput
    orderBy?: CoverLetterOrderByWithAggregationInput | CoverLetterOrderByWithAggregationInput[]
    by: CoverLetterScalarFieldEnum[] | CoverLetterScalarFieldEnum
    having?: CoverLetterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoverLetterCountAggregateInputType | true
    _avg?: CoverLetterAvgAggregateInputType
    _sum?: CoverLetterSumAggregateInputType
    _min?: CoverLetterMinAggregateInputType
    _max?: CoverLetterMaxAggregateInputType
  }

  export type CoverLetterGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    jobDescription: string
    content: string
    tone: string
    atsScore: number | null
    jdScore: number | null
    version: number
    createdAt: Date
    updatedAt: Date
    _count: CoverLetterCountAggregateOutputType | null
    _avg: CoverLetterAvgAggregateOutputType | null
    _sum: CoverLetterSumAggregateOutputType | null
    _min: CoverLetterMinAggregateOutputType | null
    _max: CoverLetterMaxAggregateOutputType | null
  }

  type GetCoverLetterGroupByPayload<T extends CoverLetterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoverLetterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoverLetterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoverLetterGroupByOutputType[P]>
            : GetScalarType<T[P], CoverLetterGroupByOutputType[P]>
        }
      >
    >


  export type CoverLetterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    jobDescription?: boolean
    content?: boolean
    tone?: boolean
    atsScore?: boolean
    jdScore?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coverLetter"]>

  export type CoverLetterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    jobDescription?: boolean
    content?: boolean
    tone?: boolean
    atsScore?: boolean
    jdScore?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coverLetter"]>

  export type CoverLetterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    jobDescription?: boolean
    content?: boolean
    tone?: boolean
    atsScore?: boolean
    jdScore?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coverLetter"]>

  export type CoverLetterSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    jobDescription?: boolean
    content?: boolean
    tone?: boolean
    atsScore?: boolean
    jdScore?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoverLetterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "jobDescription" | "content" | "tone" | "atsScore" | "jdScore" | "version" | "createdAt" | "updatedAt", ExtArgs["result"]["coverLetter"]>
  export type CoverLetterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type CoverLetterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type CoverLetterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $CoverLetterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoverLetter"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      jobDescription: string
      content: string
      tone: string
      atsScore: number | null
      jdScore: number | null
      version: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coverLetter"]>
    composites: {}
  }

  type CoverLetterGetPayload<S extends boolean | null | undefined | CoverLetterDefaultArgs> = $Result.GetResult<Prisma.$CoverLetterPayload, S>

  type CoverLetterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoverLetterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoverLetterCountAggregateInputType | true
    }

  export interface CoverLetterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoverLetter'], meta: { name: 'CoverLetter' } }
    /**
     * Find zero or one CoverLetter that matches the filter.
     * @param {CoverLetterFindUniqueArgs} args - Arguments to find a CoverLetter
     * @example
     * // Get one CoverLetter
     * const coverLetter = await prisma.coverLetter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoverLetterFindUniqueArgs>(args: SelectSubset<T, CoverLetterFindUniqueArgs<ExtArgs>>): Prisma__CoverLetterClient<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoverLetter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoverLetterFindUniqueOrThrowArgs} args - Arguments to find a CoverLetter
     * @example
     * // Get one CoverLetter
     * const coverLetter = await prisma.coverLetter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoverLetterFindUniqueOrThrowArgs>(args: SelectSubset<T, CoverLetterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoverLetterClient<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoverLetter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverLetterFindFirstArgs} args - Arguments to find a CoverLetter
     * @example
     * // Get one CoverLetter
     * const coverLetter = await prisma.coverLetter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoverLetterFindFirstArgs>(args?: SelectSubset<T, CoverLetterFindFirstArgs<ExtArgs>>): Prisma__CoverLetterClient<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoverLetter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverLetterFindFirstOrThrowArgs} args - Arguments to find a CoverLetter
     * @example
     * // Get one CoverLetter
     * const coverLetter = await prisma.coverLetter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoverLetterFindFirstOrThrowArgs>(args?: SelectSubset<T, CoverLetterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoverLetterClient<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoverLetters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverLetterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoverLetters
     * const coverLetters = await prisma.coverLetter.findMany()
     * 
     * // Get first 10 CoverLetters
     * const coverLetters = await prisma.coverLetter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coverLetterWithIdOnly = await prisma.coverLetter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoverLetterFindManyArgs>(args?: SelectSubset<T, CoverLetterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoverLetter.
     * @param {CoverLetterCreateArgs} args - Arguments to create a CoverLetter.
     * @example
     * // Create one CoverLetter
     * const CoverLetter = await prisma.coverLetter.create({
     *   data: {
     *     // ... data to create a CoverLetter
     *   }
     * })
     * 
     */
    create<T extends CoverLetterCreateArgs>(args: SelectSubset<T, CoverLetterCreateArgs<ExtArgs>>): Prisma__CoverLetterClient<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoverLetters.
     * @param {CoverLetterCreateManyArgs} args - Arguments to create many CoverLetters.
     * @example
     * // Create many CoverLetters
     * const coverLetter = await prisma.coverLetter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoverLetterCreateManyArgs>(args?: SelectSubset<T, CoverLetterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoverLetters and returns the data saved in the database.
     * @param {CoverLetterCreateManyAndReturnArgs} args - Arguments to create many CoverLetters.
     * @example
     * // Create many CoverLetters
     * const coverLetter = await prisma.coverLetter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoverLetters and only return the `id`
     * const coverLetterWithIdOnly = await prisma.coverLetter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoverLetterCreateManyAndReturnArgs>(args?: SelectSubset<T, CoverLetterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoverLetter.
     * @param {CoverLetterDeleteArgs} args - Arguments to delete one CoverLetter.
     * @example
     * // Delete one CoverLetter
     * const CoverLetter = await prisma.coverLetter.delete({
     *   where: {
     *     // ... filter to delete one CoverLetter
     *   }
     * })
     * 
     */
    delete<T extends CoverLetterDeleteArgs>(args: SelectSubset<T, CoverLetterDeleteArgs<ExtArgs>>): Prisma__CoverLetterClient<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoverLetter.
     * @param {CoverLetterUpdateArgs} args - Arguments to update one CoverLetter.
     * @example
     * // Update one CoverLetter
     * const coverLetter = await prisma.coverLetter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoverLetterUpdateArgs>(args: SelectSubset<T, CoverLetterUpdateArgs<ExtArgs>>): Prisma__CoverLetterClient<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoverLetters.
     * @param {CoverLetterDeleteManyArgs} args - Arguments to filter CoverLetters to delete.
     * @example
     * // Delete a few CoverLetters
     * const { count } = await prisma.coverLetter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoverLetterDeleteManyArgs>(args?: SelectSubset<T, CoverLetterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoverLetters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverLetterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoverLetters
     * const coverLetter = await prisma.coverLetter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoverLetterUpdateManyArgs>(args: SelectSubset<T, CoverLetterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoverLetters and returns the data updated in the database.
     * @param {CoverLetterUpdateManyAndReturnArgs} args - Arguments to update many CoverLetters.
     * @example
     * // Update many CoverLetters
     * const coverLetter = await prisma.coverLetter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoverLetters and only return the `id`
     * const coverLetterWithIdOnly = await prisma.coverLetter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoverLetterUpdateManyAndReturnArgs>(args: SelectSubset<T, CoverLetterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoverLetter.
     * @param {CoverLetterUpsertArgs} args - Arguments to update or create a CoverLetter.
     * @example
     * // Update or create a CoverLetter
     * const coverLetter = await prisma.coverLetter.upsert({
     *   create: {
     *     // ... data to create a CoverLetter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoverLetter we want to update
     *   }
     * })
     */
    upsert<T extends CoverLetterUpsertArgs>(args: SelectSubset<T, CoverLetterUpsertArgs<ExtArgs>>): Prisma__CoverLetterClient<$Result.GetResult<Prisma.$CoverLetterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoverLetters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverLetterCountArgs} args - Arguments to filter CoverLetters to count.
     * @example
     * // Count the number of CoverLetters
     * const count = await prisma.coverLetter.count({
     *   where: {
     *     // ... the filter for the CoverLetters we want to count
     *   }
     * })
    **/
    count<T extends CoverLetterCountArgs>(
      args?: Subset<T, CoverLetterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoverLetterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoverLetter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverLetterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoverLetterAggregateArgs>(args: Subset<T, CoverLetterAggregateArgs>): Prisma.PrismaPromise<GetCoverLetterAggregateType<T>>

    /**
     * Group by CoverLetter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoverLetterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoverLetterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoverLetterGroupByArgs['orderBy'] }
        : { orderBy?: CoverLetterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoverLetterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoverLetterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoverLetter model
   */
  readonly fields: CoverLetterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoverLetter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoverLetterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoverLetter model
   */
  interface CoverLetterFieldRefs {
    readonly id: FieldRef<"CoverLetter", 'String'>
    readonly userId: FieldRef<"CoverLetter", 'String'>
    readonly resumeId: FieldRef<"CoverLetter", 'String'>
    readonly jobDescription: FieldRef<"CoverLetter", 'String'>
    readonly content: FieldRef<"CoverLetter", 'String'>
    readonly tone: FieldRef<"CoverLetter", 'String'>
    readonly atsScore: FieldRef<"CoverLetter", 'Int'>
    readonly jdScore: FieldRef<"CoverLetter", 'Int'>
    readonly version: FieldRef<"CoverLetter", 'Int'>
    readonly createdAt: FieldRef<"CoverLetter", 'DateTime'>
    readonly updatedAt: FieldRef<"CoverLetter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoverLetter findUnique
   */
  export type CoverLetterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which CoverLetter to fetch.
     */
    where: CoverLetterWhereUniqueInput
  }

  /**
   * CoverLetter findUniqueOrThrow
   */
  export type CoverLetterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which CoverLetter to fetch.
     */
    where: CoverLetterWhereUniqueInput
  }

  /**
   * CoverLetter findFirst
   */
  export type CoverLetterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which CoverLetter to fetch.
     */
    where?: CoverLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverLetters to fetch.
     */
    orderBy?: CoverLetterOrderByWithRelationInput | CoverLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoverLetters.
     */
    cursor?: CoverLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoverLetters.
     */
    distinct?: CoverLetterScalarFieldEnum | CoverLetterScalarFieldEnum[]
  }

  /**
   * CoverLetter findFirstOrThrow
   */
  export type CoverLetterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which CoverLetter to fetch.
     */
    where?: CoverLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverLetters to fetch.
     */
    orderBy?: CoverLetterOrderByWithRelationInput | CoverLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoverLetters.
     */
    cursor?: CoverLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoverLetters.
     */
    distinct?: CoverLetterScalarFieldEnum | CoverLetterScalarFieldEnum[]
  }

  /**
   * CoverLetter findMany
   */
  export type CoverLetterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which CoverLetters to fetch.
     */
    where?: CoverLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoverLetters to fetch.
     */
    orderBy?: CoverLetterOrderByWithRelationInput | CoverLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoverLetters.
     */
    cursor?: CoverLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoverLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoverLetters.
     */
    skip?: number
    distinct?: CoverLetterScalarFieldEnum | CoverLetterScalarFieldEnum[]
  }

  /**
   * CoverLetter create
   */
  export type CoverLetterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * The data needed to create a CoverLetter.
     */
    data: XOR<CoverLetterCreateInput, CoverLetterUncheckedCreateInput>
  }

  /**
   * CoverLetter createMany
   */
  export type CoverLetterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoverLetters.
     */
    data: CoverLetterCreateManyInput | CoverLetterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoverLetter createManyAndReturn
   */
  export type CoverLetterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * The data used to create many CoverLetters.
     */
    data: CoverLetterCreateManyInput | CoverLetterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoverLetter update
   */
  export type CoverLetterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * The data needed to update a CoverLetter.
     */
    data: XOR<CoverLetterUpdateInput, CoverLetterUncheckedUpdateInput>
    /**
     * Choose, which CoverLetter to update.
     */
    where: CoverLetterWhereUniqueInput
  }

  /**
   * CoverLetter updateMany
   */
  export type CoverLetterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoverLetters.
     */
    data: XOR<CoverLetterUpdateManyMutationInput, CoverLetterUncheckedUpdateManyInput>
    /**
     * Filter which CoverLetters to update
     */
    where?: CoverLetterWhereInput
    /**
     * Limit how many CoverLetters to update.
     */
    limit?: number
  }

  /**
   * CoverLetter updateManyAndReturn
   */
  export type CoverLetterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * The data used to update CoverLetters.
     */
    data: XOR<CoverLetterUpdateManyMutationInput, CoverLetterUncheckedUpdateManyInput>
    /**
     * Filter which CoverLetters to update
     */
    where?: CoverLetterWhereInput
    /**
     * Limit how many CoverLetters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoverLetter upsert
   */
  export type CoverLetterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * The filter to search for the CoverLetter to update in case it exists.
     */
    where: CoverLetterWhereUniqueInput
    /**
     * In case the CoverLetter found by the `where` argument doesn't exist, create a new CoverLetter with this data.
     */
    create: XOR<CoverLetterCreateInput, CoverLetterUncheckedCreateInput>
    /**
     * In case the CoverLetter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoverLetterUpdateInput, CoverLetterUncheckedUpdateInput>
  }

  /**
   * CoverLetter delete
   */
  export type CoverLetterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
    /**
     * Filter which CoverLetter to delete.
     */
    where: CoverLetterWhereUniqueInput
  }

  /**
   * CoverLetter deleteMany
   */
  export type CoverLetterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoverLetters to delete
     */
    where?: CoverLetterWhereInput
    /**
     * Limit how many CoverLetters to delete.
     */
    limit?: number
  }

  /**
   * CoverLetter without action
   */
  export type CoverLetterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoverLetter
     */
    select?: CoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoverLetter
     */
    omit?: CoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoverLetterInclude<ExtArgs> | null
  }


  /**
   * Model LinkedInOptimization
   */

  export type AggregateLinkedInOptimization = {
    _count: LinkedInOptimizationCountAggregateOutputType | null
    _min: LinkedInOptimizationMinAggregateOutputType | null
    _max: LinkedInOptimizationMaxAggregateOutputType | null
  }

  export type LinkedInOptimizationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    jobDescription: string | null
    originalAbout: string | null
    optimizedAbout: string | null
    tone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkedInOptimizationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    jobDescription: string | null
    originalAbout: string | null
    optimizedAbout: string | null
    tone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkedInOptimizationCountAggregateOutputType = {
    id: number
    userId: number
    jobDescription: number
    originalAbout: number
    optimizedAbout: number
    tone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LinkedInOptimizationMinAggregateInputType = {
    id?: true
    userId?: true
    jobDescription?: true
    originalAbout?: true
    optimizedAbout?: true
    tone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkedInOptimizationMaxAggregateInputType = {
    id?: true
    userId?: true
    jobDescription?: true
    originalAbout?: true
    optimizedAbout?: true
    tone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkedInOptimizationCountAggregateInputType = {
    id?: true
    userId?: true
    jobDescription?: true
    originalAbout?: true
    optimizedAbout?: true
    tone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LinkedInOptimizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkedInOptimization to aggregate.
     */
    where?: LinkedInOptimizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedInOptimizations to fetch.
     */
    orderBy?: LinkedInOptimizationOrderByWithRelationInput | LinkedInOptimizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkedInOptimizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedInOptimizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedInOptimizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkedInOptimizations
    **/
    _count?: true | LinkedInOptimizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkedInOptimizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkedInOptimizationMaxAggregateInputType
  }

  export type GetLinkedInOptimizationAggregateType<T extends LinkedInOptimizationAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkedInOptimization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkedInOptimization[P]>
      : GetScalarType<T[P], AggregateLinkedInOptimization[P]>
  }




  export type LinkedInOptimizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkedInOptimizationWhereInput
    orderBy?: LinkedInOptimizationOrderByWithAggregationInput | LinkedInOptimizationOrderByWithAggregationInput[]
    by: LinkedInOptimizationScalarFieldEnum[] | LinkedInOptimizationScalarFieldEnum
    having?: LinkedInOptimizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkedInOptimizationCountAggregateInputType | true
    _min?: LinkedInOptimizationMinAggregateInputType
    _max?: LinkedInOptimizationMaxAggregateInputType
  }

  export type LinkedInOptimizationGroupByOutputType = {
    id: string
    userId: string
    jobDescription: string
    originalAbout: string
    optimizedAbout: string
    tone: string
    createdAt: Date
    updatedAt: Date
    _count: LinkedInOptimizationCountAggregateOutputType | null
    _min: LinkedInOptimizationMinAggregateOutputType | null
    _max: LinkedInOptimizationMaxAggregateOutputType | null
  }

  type GetLinkedInOptimizationGroupByPayload<T extends LinkedInOptimizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkedInOptimizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkedInOptimizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkedInOptimizationGroupByOutputType[P]>
            : GetScalarType<T[P], LinkedInOptimizationGroupByOutputType[P]>
        }
      >
    >


  export type LinkedInOptimizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobDescription?: boolean
    originalAbout?: boolean
    optimizedAbout?: boolean
    tone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedInOptimization"]>

  export type LinkedInOptimizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobDescription?: boolean
    originalAbout?: boolean
    optimizedAbout?: boolean
    tone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedInOptimization"]>

  export type LinkedInOptimizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobDescription?: boolean
    originalAbout?: boolean
    optimizedAbout?: boolean
    tone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedInOptimization"]>

  export type LinkedInOptimizationSelectScalar = {
    id?: boolean
    userId?: boolean
    jobDescription?: boolean
    originalAbout?: boolean
    optimizedAbout?: boolean
    tone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LinkedInOptimizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "jobDescription" | "originalAbout" | "optimizedAbout" | "tone" | "createdAt" | "updatedAt", ExtArgs["result"]["linkedInOptimization"]>
  export type LinkedInOptimizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LinkedInOptimizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LinkedInOptimizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LinkedInOptimizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkedInOptimization"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      jobDescription: string
      originalAbout: string
      optimizedAbout: string
      tone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["linkedInOptimization"]>
    composites: {}
  }

  type LinkedInOptimizationGetPayload<S extends boolean | null | undefined | LinkedInOptimizationDefaultArgs> = $Result.GetResult<Prisma.$LinkedInOptimizationPayload, S>

  type LinkedInOptimizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkedInOptimizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkedInOptimizationCountAggregateInputType | true
    }

  export interface LinkedInOptimizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkedInOptimization'], meta: { name: 'LinkedInOptimization' } }
    /**
     * Find zero or one LinkedInOptimization that matches the filter.
     * @param {LinkedInOptimizationFindUniqueArgs} args - Arguments to find a LinkedInOptimization
     * @example
     * // Get one LinkedInOptimization
     * const linkedInOptimization = await prisma.linkedInOptimization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkedInOptimizationFindUniqueArgs>(args: SelectSubset<T, LinkedInOptimizationFindUniqueArgs<ExtArgs>>): Prisma__LinkedInOptimizationClient<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LinkedInOptimization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkedInOptimizationFindUniqueOrThrowArgs} args - Arguments to find a LinkedInOptimization
     * @example
     * // Get one LinkedInOptimization
     * const linkedInOptimization = await prisma.linkedInOptimization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkedInOptimizationFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkedInOptimizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkedInOptimizationClient<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkedInOptimization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedInOptimizationFindFirstArgs} args - Arguments to find a LinkedInOptimization
     * @example
     * // Get one LinkedInOptimization
     * const linkedInOptimization = await prisma.linkedInOptimization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkedInOptimizationFindFirstArgs>(args?: SelectSubset<T, LinkedInOptimizationFindFirstArgs<ExtArgs>>): Prisma__LinkedInOptimizationClient<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkedInOptimization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedInOptimizationFindFirstOrThrowArgs} args - Arguments to find a LinkedInOptimization
     * @example
     * // Get one LinkedInOptimization
     * const linkedInOptimization = await prisma.linkedInOptimization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkedInOptimizationFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkedInOptimizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkedInOptimizationClient<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LinkedInOptimizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedInOptimizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkedInOptimizations
     * const linkedInOptimizations = await prisma.linkedInOptimization.findMany()
     * 
     * // Get first 10 LinkedInOptimizations
     * const linkedInOptimizations = await prisma.linkedInOptimization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkedInOptimizationWithIdOnly = await prisma.linkedInOptimization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkedInOptimizationFindManyArgs>(args?: SelectSubset<T, LinkedInOptimizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LinkedInOptimization.
     * @param {LinkedInOptimizationCreateArgs} args - Arguments to create a LinkedInOptimization.
     * @example
     * // Create one LinkedInOptimization
     * const LinkedInOptimization = await prisma.linkedInOptimization.create({
     *   data: {
     *     // ... data to create a LinkedInOptimization
     *   }
     * })
     * 
     */
    create<T extends LinkedInOptimizationCreateArgs>(args: SelectSubset<T, LinkedInOptimizationCreateArgs<ExtArgs>>): Prisma__LinkedInOptimizationClient<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LinkedInOptimizations.
     * @param {LinkedInOptimizationCreateManyArgs} args - Arguments to create many LinkedInOptimizations.
     * @example
     * // Create many LinkedInOptimizations
     * const linkedInOptimization = await prisma.linkedInOptimization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkedInOptimizationCreateManyArgs>(args?: SelectSubset<T, LinkedInOptimizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkedInOptimizations and returns the data saved in the database.
     * @param {LinkedInOptimizationCreateManyAndReturnArgs} args - Arguments to create many LinkedInOptimizations.
     * @example
     * // Create many LinkedInOptimizations
     * const linkedInOptimization = await prisma.linkedInOptimization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkedInOptimizations and only return the `id`
     * const linkedInOptimizationWithIdOnly = await prisma.linkedInOptimization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkedInOptimizationCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkedInOptimizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LinkedInOptimization.
     * @param {LinkedInOptimizationDeleteArgs} args - Arguments to delete one LinkedInOptimization.
     * @example
     * // Delete one LinkedInOptimization
     * const LinkedInOptimization = await prisma.linkedInOptimization.delete({
     *   where: {
     *     // ... filter to delete one LinkedInOptimization
     *   }
     * })
     * 
     */
    delete<T extends LinkedInOptimizationDeleteArgs>(args: SelectSubset<T, LinkedInOptimizationDeleteArgs<ExtArgs>>): Prisma__LinkedInOptimizationClient<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LinkedInOptimization.
     * @param {LinkedInOptimizationUpdateArgs} args - Arguments to update one LinkedInOptimization.
     * @example
     * // Update one LinkedInOptimization
     * const linkedInOptimization = await prisma.linkedInOptimization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkedInOptimizationUpdateArgs>(args: SelectSubset<T, LinkedInOptimizationUpdateArgs<ExtArgs>>): Prisma__LinkedInOptimizationClient<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LinkedInOptimizations.
     * @param {LinkedInOptimizationDeleteManyArgs} args - Arguments to filter LinkedInOptimizations to delete.
     * @example
     * // Delete a few LinkedInOptimizations
     * const { count } = await prisma.linkedInOptimization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkedInOptimizationDeleteManyArgs>(args?: SelectSubset<T, LinkedInOptimizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkedInOptimizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedInOptimizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkedInOptimizations
     * const linkedInOptimization = await prisma.linkedInOptimization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkedInOptimizationUpdateManyArgs>(args: SelectSubset<T, LinkedInOptimizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkedInOptimizations and returns the data updated in the database.
     * @param {LinkedInOptimizationUpdateManyAndReturnArgs} args - Arguments to update many LinkedInOptimizations.
     * @example
     * // Update many LinkedInOptimizations
     * const linkedInOptimization = await prisma.linkedInOptimization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinkedInOptimizations and only return the `id`
     * const linkedInOptimizationWithIdOnly = await prisma.linkedInOptimization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinkedInOptimizationUpdateManyAndReturnArgs>(args: SelectSubset<T, LinkedInOptimizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LinkedInOptimization.
     * @param {LinkedInOptimizationUpsertArgs} args - Arguments to update or create a LinkedInOptimization.
     * @example
     * // Update or create a LinkedInOptimization
     * const linkedInOptimization = await prisma.linkedInOptimization.upsert({
     *   create: {
     *     // ... data to create a LinkedInOptimization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkedInOptimization we want to update
     *   }
     * })
     */
    upsert<T extends LinkedInOptimizationUpsertArgs>(args: SelectSubset<T, LinkedInOptimizationUpsertArgs<ExtArgs>>): Prisma__LinkedInOptimizationClient<$Result.GetResult<Prisma.$LinkedInOptimizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LinkedInOptimizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedInOptimizationCountArgs} args - Arguments to filter LinkedInOptimizations to count.
     * @example
     * // Count the number of LinkedInOptimizations
     * const count = await prisma.linkedInOptimization.count({
     *   where: {
     *     // ... the filter for the LinkedInOptimizations we want to count
     *   }
     * })
    **/
    count<T extends LinkedInOptimizationCountArgs>(
      args?: Subset<T, LinkedInOptimizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkedInOptimizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkedInOptimization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedInOptimizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkedInOptimizationAggregateArgs>(args: Subset<T, LinkedInOptimizationAggregateArgs>): Prisma.PrismaPromise<GetLinkedInOptimizationAggregateType<T>>

    /**
     * Group by LinkedInOptimization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedInOptimizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkedInOptimizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkedInOptimizationGroupByArgs['orderBy'] }
        : { orderBy?: LinkedInOptimizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkedInOptimizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkedInOptimizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkedInOptimization model
   */
  readonly fields: LinkedInOptimizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkedInOptimization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkedInOptimizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkedInOptimization model
   */
  interface LinkedInOptimizationFieldRefs {
    readonly id: FieldRef<"LinkedInOptimization", 'String'>
    readonly userId: FieldRef<"LinkedInOptimization", 'String'>
    readonly jobDescription: FieldRef<"LinkedInOptimization", 'String'>
    readonly originalAbout: FieldRef<"LinkedInOptimization", 'String'>
    readonly optimizedAbout: FieldRef<"LinkedInOptimization", 'String'>
    readonly tone: FieldRef<"LinkedInOptimization", 'String'>
    readonly createdAt: FieldRef<"LinkedInOptimization", 'DateTime'>
    readonly updatedAt: FieldRef<"LinkedInOptimization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LinkedInOptimization findUnique
   */
  export type LinkedInOptimizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * Filter, which LinkedInOptimization to fetch.
     */
    where: LinkedInOptimizationWhereUniqueInput
  }

  /**
   * LinkedInOptimization findUniqueOrThrow
   */
  export type LinkedInOptimizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * Filter, which LinkedInOptimization to fetch.
     */
    where: LinkedInOptimizationWhereUniqueInput
  }

  /**
   * LinkedInOptimization findFirst
   */
  export type LinkedInOptimizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * Filter, which LinkedInOptimization to fetch.
     */
    where?: LinkedInOptimizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedInOptimizations to fetch.
     */
    orderBy?: LinkedInOptimizationOrderByWithRelationInput | LinkedInOptimizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkedInOptimizations.
     */
    cursor?: LinkedInOptimizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedInOptimizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedInOptimizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkedInOptimizations.
     */
    distinct?: LinkedInOptimizationScalarFieldEnum | LinkedInOptimizationScalarFieldEnum[]
  }

  /**
   * LinkedInOptimization findFirstOrThrow
   */
  export type LinkedInOptimizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * Filter, which LinkedInOptimization to fetch.
     */
    where?: LinkedInOptimizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedInOptimizations to fetch.
     */
    orderBy?: LinkedInOptimizationOrderByWithRelationInput | LinkedInOptimizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkedInOptimizations.
     */
    cursor?: LinkedInOptimizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedInOptimizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedInOptimizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkedInOptimizations.
     */
    distinct?: LinkedInOptimizationScalarFieldEnum | LinkedInOptimizationScalarFieldEnum[]
  }

  /**
   * LinkedInOptimization findMany
   */
  export type LinkedInOptimizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * Filter, which LinkedInOptimizations to fetch.
     */
    where?: LinkedInOptimizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedInOptimizations to fetch.
     */
    orderBy?: LinkedInOptimizationOrderByWithRelationInput | LinkedInOptimizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkedInOptimizations.
     */
    cursor?: LinkedInOptimizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedInOptimizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedInOptimizations.
     */
    skip?: number
    distinct?: LinkedInOptimizationScalarFieldEnum | LinkedInOptimizationScalarFieldEnum[]
  }

  /**
   * LinkedInOptimization create
   */
  export type LinkedInOptimizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkedInOptimization.
     */
    data: XOR<LinkedInOptimizationCreateInput, LinkedInOptimizationUncheckedCreateInput>
  }

  /**
   * LinkedInOptimization createMany
   */
  export type LinkedInOptimizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkedInOptimizations.
     */
    data: LinkedInOptimizationCreateManyInput | LinkedInOptimizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkedInOptimization createManyAndReturn
   */
  export type LinkedInOptimizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * The data used to create many LinkedInOptimizations.
     */
    data: LinkedInOptimizationCreateManyInput | LinkedInOptimizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkedInOptimization update
   */
  export type LinkedInOptimizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkedInOptimization.
     */
    data: XOR<LinkedInOptimizationUpdateInput, LinkedInOptimizationUncheckedUpdateInput>
    /**
     * Choose, which LinkedInOptimization to update.
     */
    where: LinkedInOptimizationWhereUniqueInput
  }

  /**
   * LinkedInOptimization updateMany
   */
  export type LinkedInOptimizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkedInOptimizations.
     */
    data: XOR<LinkedInOptimizationUpdateManyMutationInput, LinkedInOptimizationUncheckedUpdateManyInput>
    /**
     * Filter which LinkedInOptimizations to update
     */
    where?: LinkedInOptimizationWhereInput
    /**
     * Limit how many LinkedInOptimizations to update.
     */
    limit?: number
  }

  /**
   * LinkedInOptimization updateManyAndReturn
   */
  export type LinkedInOptimizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * The data used to update LinkedInOptimizations.
     */
    data: XOR<LinkedInOptimizationUpdateManyMutationInput, LinkedInOptimizationUncheckedUpdateManyInput>
    /**
     * Filter which LinkedInOptimizations to update
     */
    where?: LinkedInOptimizationWhereInput
    /**
     * Limit how many LinkedInOptimizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkedInOptimization upsert
   */
  export type LinkedInOptimizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkedInOptimization to update in case it exists.
     */
    where: LinkedInOptimizationWhereUniqueInput
    /**
     * In case the LinkedInOptimization found by the `where` argument doesn't exist, create a new LinkedInOptimization with this data.
     */
    create: XOR<LinkedInOptimizationCreateInput, LinkedInOptimizationUncheckedCreateInput>
    /**
     * In case the LinkedInOptimization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkedInOptimizationUpdateInput, LinkedInOptimizationUncheckedUpdateInput>
  }

  /**
   * LinkedInOptimization delete
   */
  export type LinkedInOptimizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
    /**
     * Filter which LinkedInOptimization to delete.
     */
    where: LinkedInOptimizationWhereUniqueInput
  }

  /**
   * LinkedInOptimization deleteMany
   */
  export type LinkedInOptimizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkedInOptimizations to delete
     */
    where?: LinkedInOptimizationWhereInput
    /**
     * Limit how many LinkedInOptimizations to delete.
     */
    limit?: number
  }

  /**
   * LinkedInOptimization without action
   */
  export type LinkedInOptimizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedInOptimization
     */
    select?: LinkedInOptimizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedInOptimization
     */
    omit?: LinkedInOptimizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedInOptimizationInclude<ExtArgs> | null
  }


  /**
   * Model InterviewSession
   */

  export type AggregateInterviewSession = {
    _count: InterviewSessionCountAggregateOutputType | null
    _min: InterviewSessionMinAggregateOutputType | null
    _max: InterviewSessionMaxAggregateOutputType | null
  }

  export type InterviewSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    jobDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    jobDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewSessionCountAggregateOutputType = {
    id: number
    userId: number
    jobDescription: number
    selectedTypes: number
    questions: number
    answers: number
    needsReview: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterviewSessionMinAggregateInputType = {
    id?: true
    userId?: true
    jobDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    jobDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewSessionCountAggregateInputType = {
    id?: true
    userId?: true
    jobDescription?: true
    selectedTypes?: true
    questions?: true
    answers?: true
    needsReview?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterviewSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewSession to aggregate.
     */
    where?: InterviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSessions to fetch.
     */
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewSessions
    **/
    _count?: true | InterviewSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewSessionMaxAggregateInputType
  }

  export type GetInterviewSessionAggregateType<T extends InterviewSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewSession[P]>
      : GetScalarType<T[P], AggregateInterviewSession[P]>
  }




  export type InterviewSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSessionWhereInput
    orderBy?: InterviewSessionOrderByWithAggregationInput | InterviewSessionOrderByWithAggregationInput[]
    by: InterviewSessionScalarFieldEnum[] | InterviewSessionScalarFieldEnum
    having?: InterviewSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewSessionCountAggregateInputType | true
    _min?: InterviewSessionMinAggregateInputType
    _max?: InterviewSessionMaxAggregateInputType
  }

  export type InterviewSessionGroupByOutputType = {
    id: string
    userId: string
    jobDescription: string
    selectedTypes: string[]
    questions: JsonValue
    answers: JsonValue | null
    needsReview: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InterviewSessionCountAggregateOutputType | null
    _min: InterviewSessionMinAggregateOutputType | null
    _max: InterviewSessionMaxAggregateOutputType | null
  }

  type GetInterviewSessionGroupByPayload<T extends InterviewSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewSessionGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewSessionGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobDescription?: boolean
    selectedTypes?: boolean
    questions?: boolean
    answers?: boolean
    needsReview?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewSession"]>

  export type InterviewSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobDescription?: boolean
    selectedTypes?: boolean
    questions?: boolean
    answers?: boolean
    needsReview?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewSession"]>

  export type InterviewSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobDescription?: boolean
    selectedTypes?: boolean
    questions?: boolean
    answers?: boolean
    needsReview?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewSession"]>

  export type InterviewSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    jobDescription?: boolean
    selectedTypes?: boolean
    questions?: boolean
    answers?: boolean
    needsReview?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InterviewSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "jobDescription" | "selectedTypes" | "questions" | "answers" | "needsReview" | "createdAt" | "updatedAt", ExtArgs["result"]["interviewSession"]>
  export type InterviewSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InterviewSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InterviewSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InterviewSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      jobDescription: string
      selectedTypes: string[]
      questions: Prisma.JsonValue
      answers: Prisma.JsonValue | null
      needsReview: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interviewSession"]>
    composites: {}
  }

  type InterviewSessionGetPayload<S extends boolean | null | undefined | InterviewSessionDefaultArgs> = $Result.GetResult<Prisma.$InterviewSessionPayload, S>

  type InterviewSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterviewSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewSessionCountAggregateInputType | true
    }

  export interface InterviewSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewSession'], meta: { name: 'InterviewSession' } }
    /**
     * Find zero or one InterviewSession that matches the filter.
     * @param {InterviewSessionFindUniqueArgs} args - Arguments to find a InterviewSession
     * @example
     * // Get one InterviewSession
     * const interviewSession = await prisma.interviewSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewSessionFindUniqueArgs>(args: SelectSubset<T, InterviewSessionFindUniqueArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterviewSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterviewSessionFindUniqueOrThrowArgs} args - Arguments to find a InterviewSession
     * @example
     * // Get one InterviewSession
     * const interviewSession = await prisma.interviewSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionFindFirstArgs} args - Arguments to find a InterviewSession
     * @example
     * // Get one InterviewSession
     * const interviewSession = await prisma.interviewSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewSessionFindFirstArgs>(args?: SelectSubset<T, InterviewSessionFindFirstArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionFindFirstOrThrowArgs} args - Arguments to find a InterviewSession
     * @example
     * // Get one InterviewSession
     * const interviewSession = await prisma.interviewSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterviewSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewSessions
     * const interviewSessions = await prisma.interviewSession.findMany()
     * 
     * // Get first 10 InterviewSessions
     * const interviewSessions = await prisma.interviewSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewSessionWithIdOnly = await prisma.interviewSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewSessionFindManyArgs>(args?: SelectSubset<T, InterviewSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterviewSession.
     * @param {InterviewSessionCreateArgs} args - Arguments to create a InterviewSession.
     * @example
     * // Create one InterviewSession
     * const InterviewSession = await prisma.interviewSession.create({
     *   data: {
     *     // ... data to create a InterviewSession
     *   }
     * })
     * 
     */
    create<T extends InterviewSessionCreateArgs>(args: SelectSubset<T, InterviewSessionCreateArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterviewSessions.
     * @param {InterviewSessionCreateManyArgs} args - Arguments to create many InterviewSessions.
     * @example
     * // Create many InterviewSessions
     * const interviewSession = await prisma.interviewSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewSessionCreateManyArgs>(args?: SelectSubset<T, InterviewSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterviewSessions and returns the data saved in the database.
     * @param {InterviewSessionCreateManyAndReturnArgs} args - Arguments to create many InterviewSessions.
     * @example
     * // Create many InterviewSessions
     * const interviewSession = await prisma.interviewSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterviewSessions and only return the `id`
     * const interviewSessionWithIdOnly = await prisma.interviewSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterviewSession.
     * @param {InterviewSessionDeleteArgs} args - Arguments to delete one InterviewSession.
     * @example
     * // Delete one InterviewSession
     * const InterviewSession = await prisma.interviewSession.delete({
     *   where: {
     *     // ... filter to delete one InterviewSession
     *   }
     * })
     * 
     */
    delete<T extends InterviewSessionDeleteArgs>(args: SelectSubset<T, InterviewSessionDeleteArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterviewSession.
     * @param {InterviewSessionUpdateArgs} args - Arguments to update one InterviewSession.
     * @example
     * // Update one InterviewSession
     * const interviewSession = await prisma.interviewSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewSessionUpdateArgs>(args: SelectSubset<T, InterviewSessionUpdateArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterviewSessions.
     * @param {InterviewSessionDeleteManyArgs} args - Arguments to filter InterviewSessions to delete.
     * @example
     * // Delete a few InterviewSessions
     * const { count } = await prisma.interviewSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewSessionDeleteManyArgs>(args?: SelectSubset<T, InterviewSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewSessions
     * const interviewSession = await prisma.interviewSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewSessionUpdateManyArgs>(args: SelectSubset<T, InterviewSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewSessions and returns the data updated in the database.
     * @param {InterviewSessionUpdateManyAndReturnArgs} args - Arguments to update many InterviewSessions.
     * @example
     * // Update many InterviewSessions
     * const interviewSession = await prisma.interviewSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterviewSessions and only return the `id`
     * const interviewSessionWithIdOnly = await prisma.interviewSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterviewSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, InterviewSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterviewSession.
     * @param {InterviewSessionUpsertArgs} args - Arguments to update or create a InterviewSession.
     * @example
     * // Update or create a InterviewSession
     * const interviewSession = await prisma.interviewSession.upsert({
     *   create: {
     *     // ... data to create a InterviewSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewSession we want to update
     *   }
     * })
     */
    upsert<T extends InterviewSessionUpsertArgs>(args: SelectSubset<T, InterviewSessionUpsertArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterviewSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionCountArgs} args - Arguments to filter InterviewSessions to count.
     * @example
     * // Count the number of InterviewSessions
     * const count = await prisma.interviewSession.count({
     *   where: {
     *     // ... the filter for the InterviewSessions we want to count
     *   }
     * })
    **/
    count<T extends InterviewSessionCountArgs>(
      args?: Subset<T, InterviewSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewSessionAggregateArgs>(args: Subset<T, InterviewSessionAggregateArgs>): Prisma.PrismaPromise<GetInterviewSessionAggregateType<T>>

    /**
     * Group by InterviewSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewSessionGroupByArgs['orderBy'] }
        : { orderBy?: InterviewSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewSession model
   */
  readonly fields: InterviewSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewSession model
   */
  interface InterviewSessionFieldRefs {
    readonly id: FieldRef<"InterviewSession", 'String'>
    readonly userId: FieldRef<"InterviewSession", 'String'>
    readonly jobDescription: FieldRef<"InterviewSession", 'String'>
    readonly selectedTypes: FieldRef<"InterviewSession", 'String[]'>
    readonly questions: FieldRef<"InterviewSession", 'Json'>
    readonly answers: FieldRef<"InterviewSession", 'Json'>
    readonly needsReview: FieldRef<"InterviewSession", 'Json'>
    readonly createdAt: FieldRef<"InterviewSession", 'DateTime'>
    readonly updatedAt: FieldRef<"InterviewSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewSession findUnique
   */
  export type InterviewSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSession to fetch.
     */
    where: InterviewSessionWhereUniqueInput
  }

  /**
   * InterviewSession findUniqueOrThrow
   */
  export type InterviewSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSession to fetch.
     */
    where: InterviewSessionWhereUniqueInput
  }

  /**
   * InterviewSession findFirst
   */
  export type InterviewSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSession to fetch.
     */
    where?: InterviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSessions to fetch.
     */
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSessions.
     */
    cursor?: InterviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSessions.
     */
    distinct?: InterviewSessionScalarFieldEnum | InterviewSessionScalarFieldEnum[]
  }

  /**
   * InterviewSession findFirstOrThrow
   */
  export type InterviewSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSession to fetch.
     */
    where?: InterviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSessions to fetch.
     */
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSessions.
     */
    cursor?: InterviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSessions.
     */
    distinct?: InterviewSessionScalarFieldEnum | InterviewSessionScalarFieldEnum[]
  }

  /**
   * InterviewSession findMany
   */
  export type InterviewSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSessions to fetch.
     */
    where?: InterviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSessions to fetch.
     */
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewSessions.
     */
    cursor?: InterviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSessions.
     */
    skip?: number
    distinct?: InterviewSessionScalarFieldEnum | InterviewSessionScalarFieldEnum[]
  }

  /**
   * InterviewSession create
   */
  export type InterviewSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewSession.
     */
    data: XOR<InterviewSessionCreateInput, InterviewSessionUncheckedCreateInput>
  }

  /**
   * InterviewSession createMany
   */
  export type InterviewSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewSessions.
     */
    data: InterviewSessionCreateManyInput | InterviewSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewSession createManyAndReturn
   */
  export type InterviewSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * The data used to create many InterviewSessions.
     */
    data: InterviewSessionCreateManyInput | InterviewSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewSession update
   */
  export type InterviewSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewSession.
     */
    data: XOR<InterviewSessionUpdateInput, InterviewSessionUncheckedUpdateInput>
    /**
     * Choose, which InterviewSession to update.
     */
    where: InterviewSessionWhereUniqueInput
  }

  /**
   * InterviewSession updateMany
   */
  export type InterviewSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewSessions.
     */
    data: XOR<InterviewSessionUpdateManyMutationInput, InterviewSessionUncheckedUpdateManyInput>
    /**
     * Filter which InterviewSessions to update
     */
    where?: InterviewSessionWhereInput
    /**
     * Limit how many InterviewSessions to update.
     */
    limit?: number
  }

  /**
   * InterviewSession updateManyAndReturn
   */
  export type InterviewSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * The data used to update InterviewSessions.
     */
    data: XOR<InterviewSessionUpdateManyMutationInput, InterviewSessionUncheckedUpdateManyInput>
    /**
     * Filter which InterviewSessions to update
     */
    where?: InterviewSessionWhereInput
    /**
     * Limit how many InterviewSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewSession upsert
   */
  export type InterviewSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewSession to update in case it exists.
     */
    where: InterviewSessionWhereUniqueInput
    /**
     * In case the InterviewSession found by the `where` argument doesn't exist, create a new InterviewSession with this data.
     */
    create: XOR<InterviewSessionCreateInput, InterviewSessionUncheckedCreateInput>
    /**
     * In case the InterviewSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewSessionUpdateInput, InterviewSessionUncheckedUpdateInput>
  }

  /**
   * InterviewSession delete
   */
  export type InterviewSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter which InterviewSession to delete.
     */
    where: InterviewSessionWhereUniqueInput
  }

  /**
   * InterviewSession deleteMany
   */
  export type InterviewSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewSessions to delete
     */
    where?: InterviewSessionWhereInput
    /**
     * Limit how many InterviewSessions to delete.
     */
    limit?: number
  }

  /**
   * InterviewSession without action
   */
  export type InterviewSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewSession
     */
    omit?: InterviewSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
  }


  /**
   * Model ResumeExport
   */

  export type AggregateResumeExport = {
    _count: ResumeExportCountAggregateOutputType | null
    _min: ResumeExportMinAggregateOutputType | null
    _max: ResumeExportMaxAggregateOutputType | null
  }

  export type ResumeExportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    templateId: string | null
    format: string | null
    createdAt: Date | null
  }

  export type ResumeExportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    templateId: string | null
    format: string | null
    createdAt: Date | null
  }

  export type ResumeExportCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    templateId: number
    format: number
    createdAt: number
    _all: number
  }


  export type ResumeExportMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    templateId?: true
    format?: true
    createdAt?: true
  }

  export type ResumeExportMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    templateId?: true
    format?: true
    createdAt?: true
  }

  export type ResumeExportCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    templateId?: true
    format?: true
    createdAt?: true
    _all?: true
  }

  export type ResumeExportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeExport to aggregate.
     */
    where?: ResumeExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeExports to fetch.
     */
    orderBy?: ResumeExportOrderByWithRelationInput | ResumeExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeExports
    **/
    _count?: true | ResumeExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeExportMaxAggregateInputType
  }

  export type GetResumeExportAggregateType<T extends ResumeExportAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeExport[P]>
      : GetScalarType<T[P], AggregateResumeExport[P]>
  }




  export type ResumeExportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeExportWhereInput
    orderBy?: ResumeExportOrderByWithAggregationInput | ResumeExportOrderByWithAggregationInput[]
    by: ResumeExportScalarFieldEnum[] | ResumeExportScalarFieldEnum
    having?: ResumeExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeExportCountAggregateInputType | true
    _min?: ResumeExportMinAggregateInputType
    _max?: ResumeExportMaxAggregateInputType
  }

  export type ResumeExportGroupByOutputType = {
    id: string
    userId: string
    resumeId: string
    templateId: string
    format: string
    createdAt: Date
    _count: ResumeExportCountAggregateOutputType | null
    _min: ResumeExportMinAggregateOutputType | null
    _max: ResumeExportMaxAggregateOutputType | null
  }

  type GetResumeExportGroupByPayload<T extends ResumeExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeExportGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeExportGroupByOutputType[P]>
        }
      >
    >


  export type ResumeExportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    templateId?: boolean
    format?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeExport"]>

  export type ResumeExportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    templateId?: boolean
    format?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeExport"]>

  export type ResumeExportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    templateId?: boolean
    format?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeExport"]>

  export type ResumeExportSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    templateId?: boolean
    format?: boolean
    createdAt?: boolean
  }

  export type ResumeExportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "templateId" | "format" | "createdAt", ExtArgs["result"]["resumeExport"]>
  export type ResumeExportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeExportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeExportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ResumeExportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeExport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string
      templateId: string
      format: string
      createdAt: Date
    }, ExtArgs["result"]["resumeExport"]>
    composites: {}
  }

  type ResumeExportGetPayload<S extends boolean | null | undefined | ResumeExportDefaultArgs> = $Result.GetResult<Prisma.$ResumeExportPayload, S>

  type ResumeExportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeExportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeExportCountAggregateInputType | true
    }

  export interface ResumeExportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeExport'], meta: { name: 'ResumeExport' } }
    /**
     * Find zero or one ResumeExport that matches the filter.
     * @param {ResumeExportFindUniqueArgs} args - Arguments to find a ResumeExport
     * @example
     * // Get one ResumeExport
     * const resumeExport = await prisma.resumeExport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeExportFindUniqueArgs>(args: SelectSubset<T, ResumeExportFindUniqueArgs<ExtArgs>>): Prisma__ResumeExportClient<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResumeExport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeExportFindUniqueOrThrowArgs} args - Arguments to find a ResumeExport
     * @example
     * // Get one ResumeExport
     * const resumeExport = await prisma.resumeExport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeExportFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeExportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeExportClient<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeExport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeExportFindFirstArgs} args - Arguments to find a ResumeExport
     * @example
     * // Get one ResumeExport
     * const resumeExport = await prisma.resumeExport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeExportFindFirstArgs>(args?: SelectSubset<T, ResumeExportFindFirstArgs<ExtArgs>>): Prisma__ResumeExportClient<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeExport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeExportFindFirstOrThrowArgs} args - Arguments to find a ResumeExport
     * @example
     * // Get one ResumeExport
     * const resumeExport = await prisma.resumeExport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeExportFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeExportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeExportClient<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResumeExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeExportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeExports
     * const resumeExports = await prisma.resumeExport.findMany()
     * 
     * // Get first 10 ResumeExports
     * const resumeExports = await prisma.resumeExport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeExportWithIdOnly = await prisma.resumeExport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeExportFindManyArgs>(args?: SelectSubset<T, ResumeExportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResumeExport.
     * @param {ResumeExportCreateArgs} args - Arguments to create a ResumeExport.
     * @example
     * // Create one ResumeExport
     * const ResumeExport = await prisma.resumeExport.create({
     *   data: {
     *     // ... data to create a ResumeExport
     *   }
     * })
     * 
     */
    create<T extends ResumeExportCreateArgs>(args: SelectSubset<T, ResumeExportCreateArgs<ExtArgs>>): Prisma__ResumeExportClient<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResumeExports.
     * @param {ResumeExportCreateManyArgs} args - Arguments to create many ResumeExports.
     * @example
     * // Create many ResumeExports
     * const resumeExport = await prisma.resumeExport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeExportCreateManyArgs>(args?: SelectSubset<T, ResumeExportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResumeExports and returns the data saved in the database.
     * @param {ResumeExportCreateManyAndReturnArgs} args - Arguments to create many ResumeExports.
     * @example
     * // Create many ResumeExports
     * const resumeExport = await prisma.resumeExport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResumeExports and only return the `id`
     * const resumeExportWithIdOnly = await prisma.resumeExport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeExportCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeExportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResumeExport.
     * @param {ResumeExportDeleteArgs} args - Arguments to delete one ResumeExport.
     * @example
     * // Delete one ResumeExport
     * const ResumeExport = await prisma.resumeExport.delete({
     *   where: {
     *     // ... filter to delete one ResumeExport
     *   }
     * })
     * 
     */
    delete<T extends ResumeExportDeleteArgs>(args: SelectSubset<T, ResumeExportDeleteArgs<ExtArgs>>): Prisma__ResumeExportClient<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResumeExport.
     * @param {ResumeExportUpdateArgs} args - Arguments to update one ResumeExport.
     * @example
     * // Update one ResumeExport
     * const resumeExport = await prisma.resumeExport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeExportUpdateArgs>(args: SelectSubset<T, ResumeExportUpdateArgs<ExtArgs>>): Prisma__ResumeExportClient<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResumeExports.
     * @param {ResumeExportDeleteManyArgs} args - Arguments to filter ResumeExports to delete.
     * @example
     * // Delete a few ResumeExports
     * const { count } = await prisma.resumeExport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeExportDeleteManyArgs>(args?: SelectSubset<T, ResumeExportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeExports
     * const resumeExport = await prisma.resumeExport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeExportUpdateManyArgs>(args: SelectSubset<T, ResumeExportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeExports and returns the data updated in the database.
     * @param {ResumeExportUpdateManyAndReturnArgs} args - Arguments to update many ResumeExports.
     * @example
     * // Update many ResumeExports
     * const resumeExport = await prisma.resumeExport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResumeExports and only return the `id`
     * const resumeExportWithIdOnly = await prisma.resumeExport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeExportUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeExportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResumeExport.
     * @param {ResumeExportUpsertArgs} args - Arguments to update or create a ResumeExport.
     * @example
     * // Update or create a ResumeExport
     * const resumeExport = await prisma.resumeExport.upsert({
     *   create: {
     *     // ... data to create a ResumeExport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeExport we want to update
     *   }
     * })
     */
    upsert<T extends ResumeExportUpsertArgs>(args: SelectSubset<T, ResumeExportUpsertArgs<ExtArgs>>): Prisma__ResumeExportClient<$Result.GetResult<Prisma.$ResumeExportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResumeExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeExportCountArgs} args - Arguments to filter ResumeExports to count.
     * @example
     * // Count the number of ResumeExports
     * const count = await prisma.resumeExport.count({
     *   where: {
     *     // ... the filter for the ResumeExports we want to count
     *   }
     * })
    **/
    count<T extends ResumeExportCountArgs>(
      args?: Subset<T, ResumeExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeExportAggregateArgs>(args: Subset<T, ResumeExportAggregateArgs>): Prisma.PrismaPromise<GetResumeExportAggregateType<T>>

    /**
     * Group by ResumeExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeExportGroupByArgs['orderBy'] }
        : { orderBy?: ResumeExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeExport model
   */
  readonly fields: ResumeExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeExport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeExportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumeExport model
   */
  interface ResumeExportFieldRefs {
    readonly id: FieldRef<"ResumeExport", 'String'>
    readonly userId: FieldRef<"ResumeExport", 'String'>
    readonly resumeId: FieldRef<"ResumeExport", 'String'>
    readonly templateId: FieldRef<"ResumeExport", 'String'>
    readonly format: FieldRef<"ResumeExport", 'String'>
    readonly createdAt: FieldRef<"ResumeExport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResumeExport findUnique
   */
  export type ResumeExportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * Filter, which ResumeExport to fetch.
     */
    where: ResumeExportWhereUniqueInput
  }

  /**
   * ResumeExport findUniqueOrThrow
   */
  export type ResumeExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * Filter, which ResumeExport to fetch.
     */
    where: ResumeExportWhereUniqueInput
  }

  /**
   * ResumeExport findFirst
   */
  export type ResumeExportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * Filter, which ResumeExport to fetch.
     */
    where?: ResumeExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeExports to fetch.
     */
    orderBy?: ResumeExportOrderByWithRelationInput | ResumeExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeExports.
     */
    cursor?: ResumeExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeExports.
     */
    distinct?: ResumeExportScalarFieldEnum | ResumeExportScalarFieldEnum[]
  }

  /**
   * ResumeExport findFirstOrThrow
   */
  export type ResumeExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * Filter, which ResumeExport to fetch.
     */
    where?: ResumeExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeExports to fetch.
     */
    orderBy?: ResumeExportOrderByWithRelationInput | ResumeExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeExports.
     */
    cursor?: ResumeExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeExports.
     */
    distinct?: ResumeExportScalarFieldEnum | ResumeExportScalarFieldEnum[]
  }

  /**
   * ResumeExport findMany
   */
  export type ResumeExportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * Filter, which ResumeExports to fetch.
     */
    where?: ResumeExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeExports to fetch.
     */
    orderBy?: ResumeExportOrderByWithRelationInput | ResumeExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeExports.
     */
    cursor?: ResumeExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeExports.
     */
    skip?: number
    distinct?: ResumeExportScalarFieldEnum | ResumeExportScalarFieldEnum[]
  }

  /**
   * ResumeExport create
   */
  export type ResumeExportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeExport.
     */
    data: XOR<ResumeExportCreateInput, ResumeExportUncheckedCreateInput>
  }

  /**
   * ResumeExport createMany
   */
  export type ResumeExportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeExports.
     */
    data: ResumeExportCreateManyInput | ResumeExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeExport createManyAndReturn
   */
  export type ResumeExportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * The data used to create many ResumeExports.
     */
    data: ResumeExportCreateManyInput | ResumeExportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeExport update
   */
  export type ResumeExportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeExport.
     */
    data: XOR<ResumeExportUpdateInput, ResumeExportUncheckedUpdateInput>
    /**
     * Choose, which ResumeExport to update.
     */
    where: ResumeExportWhereUniqueInput
  }

  /**
   * ResumeExport updateMany
   */
  export type ResumeExportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeExports.
     */
    data: XOR<ResumeExportUpdateManyMutationInput, ResumeExportUncheckedUpdateManyInput>
    /**
     * Filter which ResumeExports to update
     */
    where?: ResumeExportWhereInput
    /**
     * Limit how many ResumeExports to update.
     */
    limit?: number
  }

  /**
   * ResumeExport updateManyAndReturn
   */
  export type ResumeExportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * The data used to update ResumeExports.
     */
    data: XOR<ResumeExportUpdateManyMutationInput, ResumeExportUncheckedUpdateManyInput>
    /**
     * Filter which ResumeExports to update
     */
    where?: ResumeExportWhereInput
    /**
     * Limit how many ResumeExports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeExport upsert
   */
  export type ResumeExportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeExport to update in case it exists.
     */
    where: ResumeExportWhereUniqueInput
    /**
     * In case the ResumeExport found by the `where` argument doesn't exist, create a new ResumeExport with this data.
     */
    create: XOR<ResumeExportCreateInput, ResumeExportUncheckedCreateInput>
    /**
     * In case the ResumeExport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeExportUpdateInput, ResumeExportUncheckedUpdateInput>
  }

  /**
   * ResumeExport delete
   */
  export type ResumeExportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
    /**
     * Filter which ResumeExport to delete.
     */
    where: ResumeExportWhereUniqueInput
  }

  /**
   * ResumeExport deleteMany
   */
  export type ResumeExportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeExports to delete
     */
    where?: ResumeExportWhereInput
    /**
     * Limit how many ResumeExports to delete.
     */
    limit?: number
  }

  /**
   * ResumeExport without action
   */
  export type ResumeExportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeExport
     */
    select?: ResumeExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeExport
     */
    omit?: ResumeExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeExportInclude<ExtArgs> | null
  }


  /**
   * Model JobDescriptionIntelligence
   */

  export type AggregateJobDescriptionIntelligence = {
    _count: JobDescriptionIntelligenceCountAggregateOutputType | null
    _min: JobDescriptionIntelligenceMinAggregateOutputType | null
    _max: JobDescriptionIntelligenceMaxAggregateOutputType | null
  }

  export type JobDescriptionIntelligenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    role: string | null
    seniority: string | null
    createdAt: Date | null
  }

  export type JobDescriptionIntelligenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    role: string | null
    seniority: string | null
    createdAt: Date | null
  }

  export type JobDescriptionIntelligenceCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    role: number
    seniority: number
    keywords: number
    responsibilities: number
    qualifications: number
    categories: number
    createdAt: number
    _all: number
  }


  export type JobDescriptionIntelligenceMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    role?: true
    seniority?: true
    createdAt?: true
  }

  export type JobDescriptionIntelligenceMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    role?: true
    seniority?: true
    createdAt?: true
  }

  export type JobDescriptionIntelligenceCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    role?: true
    seniority?: true
    keywords?: true
    responsibilities?: true
    qualifications?: true
    categories?: true
    createdAt?: true
    _all?: true
  }

  export type JobDescriptionIntelligenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobDescriptionIntelligence to aggregate.
     */
    where?: JobDescriptionIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDescriptionIntelligences to fetch.
     */
    orderBy?: JobDescriptionIntelligenceOrderByWithRelationInput | JobDescriptionIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobDescriptionIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDescriptionIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDescriptionIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobDescriptionIntelligences
    **/
    _count?: true | JobDescriptionIntelligenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobDescriptionIntelligenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobDescriptionIntelligenceMaxAggregateInputType
  }

  export type GetJobDescriptionIntelligenceAggregateType<T extends JobDescriptionIntelligenceAggregateArgs> = {
        [P in keyof T & keyof AggregateJobDescriptionIntelligence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobDescriptionIntelligence[P]>
      : GetScalarType<T[P], AggregateJobDescriptionIntelligence[P]>
  }




  export type JobDescriptionIntelligenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobDescriptionIntelligenceWhereInput
    orderBy?: JobDescriptionIntelligenceOrderByWithAggregationInput | JobDescriptionIntelligenceOrderByWithAggregationInput[]
    by: JobDescriptionIntelligenceScalarFieldEnum[] | JobDescriptionIntelligenceScalarFieldEnum
    having?: JobDescriptionIntelligenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobDescriptionIntelligenceCountAggregateInputType | true
    _min?: JobDescriptionIntelligenceMinAggregateInputType
    _max?: JobDescriptionIntelligenceMaxAggregateInputType
  }

  export type JobDescriptionIntelligenceGroupByOutputType = {
    id: string
    userId: string
    resumeId: string | null
    role: string
    seniority: string
    keywords: string[]
    responsibilities: string[]
    qualifications: string[]
    categories: JsonValue
    createdAt: Date
    _count: JobDescriptionIntelligenceCountAggregateOutputType | null
    _min: JobDescriptionIntelligenceMinAggregateOutputType | null
    _max: JobDescriptionIntelligenceMaxAggregateOutputType | null
  }

  type GetJobDescriptionIntelligenceGroupByPayload<T extends JobDescriptionIntelligenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobDescriptionIntelligenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobDescriptionIntelligenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobDescriptionIntelligenceGroupByOutputType[P]>
            : GetScalarType<T[P], JobDescriptionIntelligenceGroupByOutputType[P]>
        }
      >
    >


  export type JobDescriptionIntelligenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    role?: boolean
    seniority?: boolean
    keywords?: boolean
    responsibilities?: boolean
    qualifications?: boolean
    categories?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobDescriptionIntelligence"]>

  export type JobDescriptionIntelligenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    role?: boolean
    seniority?: boolean
    keywords?: boolean
    responsibilities?: boolean
    qualifications?: boolean
    categories?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobDescriptionIntelligence"]>

  export type JobDescriptionIntelligenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    role?: boolean
    seniority?: boolean
    keywords?: boolean
    responsibilities?: boolean
    qualifications?: boolean
    categories?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobDescriptionIntelligence"]>

  export type JobDescriptionIntelligenceSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    role?: boolean
    seniority?: boolean
    keywords?: boolean
    responsibilities?: boolean
    qualifications?: boolean
    categories?: boolean
    createdAt?: boolean
  }

  export type JobDescriptionIntelligenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "role" | "seniority" | "keywords" | "responsibilities" | "qualifications" | "categories" | "createdAt", ExtArgs["result"]["jobDescriptionIntelligence"]>
  export type JobDescriptionIntelligenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobDescriptionIntelligenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobDescriptionIntelligenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JobDescriptionIntelligencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobDescriptionIntelligence"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      resumeId: string | null
      role: string
      seniority: string
      keywords: string[]
      responsibilities: string[]
      qualifications: string[]
      categories: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["jobDescriptionIntelligence"]>
    composites: {}
  }

  type JobDescriptionIntelligenceGetPayload<S extends boolean | null | undefined | JobDescriptionIntelligenceDefaultArgs> = $Result.GetResult<Prisma.$JobDescriptionIntelligencePayload, S>

  type JobDescriptionIntelligenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobDescriptionIntelligenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobDescriptionIntelligenceCountAggregateInputType | true
    }

  export interface JobDescriptionIntelligenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobDescriptionIntelligence'], meta: { name: 'JobDescriptionIntelligence' } }
    /**
     * Find zero or one JobDescriptionIntelligence that matches the filter.
     * @param {JobDescriptionIntelligenceFindUniqueArgs} args - Arguments to find a JobDescriptionIntelligence
     * @example
     * // Get one JobDescriptionIntelligence
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobDescriptionIntelligenceFindUniqueArgs>(args: SelectSubset<T, JobDescriptionIntelligenceFindUniqueArgs<ExtArgs>>): Prisma__JobDescriptionIntelligenceClient<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobDescriptionIntelligence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobDescriptionIntelligenceFindUniqueOrThrowArgs} args - Arguments to find a JobDescriptionIntelligence
     * @example
     * // Get one JobDescriptionIntelligence
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobDescriptionIntelligenceFindUniqueOrThrowArgs>(args: SelectSubset<T, JobDescriptionIntelligenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobDescriptionIntelligenceClient<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobDescriptionIntelligence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDescriptionIntelligenceFindFirstArgs} args - Arguments to find a JobDescriptionIntelligence
     * @example
     * // Get one JobDescriptionIntelligence
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobDescriptionIntelligenceFindFirstArgs>(args?: SelectSubset<T, JobDescriptionIntelligenceFindFirstArgs<ExtArgs>>): Prisma__JobDescriptionIntelligenceClient<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobDescriptionIntelligence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDescriptionIntelligenceFindFirstOrThrowArgs} args - Arguments to find a JobDescriptionIntelligence
     * @example
     * // Get one JobDescriptionIntelligence
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobDescriptionIntelligenceFindFirstOrThrowArgs>(args?: SelectSubset<T, JobDescriptionIntelligenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobDescriptionIntelligenceClient<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobDescriptionIntelligences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDescriptionIntelligenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobDescriptionIntelligences
     * const jobDescriptionIntelligences = await prisma.jobDescriptionIntelligence.findMany()
     * 
     * // Get first 10 JobDescriptionIntelligences
     * const jobDescriptionIntelligences = await prisma.jobDescriptionIntelligence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobDescriptionIntelligenceWithIdOnly = await prisma.jobDescriptionIntelligence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobDescriptionIntelligenceFindManyArgs>(args?: SelectSubset<T, JobDescriptionIntelligenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobDescriptionIntelligence.
     * @param {JobDescriptionIntelligenceCreateArgs} args - Arguments to create a JobDescriptionIntelligence.
     * @example
     * // Create one JobDescriptionIntelligence
     * const JobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.create({
     *   data: {
     *     // ... data to create a JobDescriptionIntelligence
     *   }
     * })
     * 
     */
    create<T extends JobDescriptionIntelligenceCreateArgs>(args: SelectSubset<T, JobDescriptionIntelligenceCreateArgs<ExtArgs>>): Prisma__JobDescriptionIntelligenceClient<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobDescriptionIntelligences.
     * @param {JobDescriptionIntelligenceCreateManyArgs} args - Arguments to create many JobDescriptionIntelligences.
     * @example
     * // Create many JobDescriptionIntelligences
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobDescriptionIntelligenceCreateManyArgs>(args?: SelectSubset<T, JobDescriptionIntelligenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobDescriptionIntelligences and returns the data saved in the database.
     * @param {JobDescriptionIntelligenceCreateManyAndReturnArgs} args - Arguments to create many JobDescriptionIntelligences.
     * @example
     * // Create many JobDescriptionIntelligences
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobDescriptionIntelligences and only return the `id`
     * const jobDescriptionIntelligenceWithIdOnly = await prisma.jobDescriptionIntelligence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobDescriptionIntelligenceCreateManyAndReturnArgs>(args?: SelectSubset<T, JobDescriptionIntelligenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobDescriptionIntelligence.
     * @param {JobDescriptionIntelligenceDeleteArgs} args - Arguments to delete one JobDescriptionIntelligence.
     * @example
     * // Delete one JobDescriptionIntelligence
     * const JobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.delete({
     *   where: {
     *     // ... filter to delete one JobDescriptionIntelligence
     *   }
     * })
     * 
     */
    delete<T extends JobDescriptionIntelligenceDeleteArgs>(args: SelectSubset<T, JobDescriptionIntelligenceDeleteArgs<ExtArgs>>): Prisma__JobDescriptionIntelligenceClient<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobDescriptionIntelligence.
     * @param {JobDescriptionIntelligenceUpdateArgs} args - Arguments to update one JobDescriptionIntelligence.
     * @example
     * // Update one JobDescriptionIntelligence
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobDescriptionIntelligenceUpdateArgs>(args: SelectSubset<T, JobDescriptionIntelligenceUpdateArgs<ExtArgs>>): Prisma__JobDescriptionIntelligenceClient<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobDescriptionIntelligences.
     * @param {JobDescriptionIntelligenceDeleteManyArgs} args - Arguments to filter JobDescriptionIntelligences to delete.
     * @example
     * // Delete a few JobDescriptionIntelligences
     * const { count } = await prisma.jobDescriptionIntelligence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDescriptionIntelligenceDeleteManyArgs>(args?: SelectSubset<T, JobDescriptionIntelligenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobDescriptionIntelligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDescriptionIntelligenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobDescriptionIntelligences
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobDescriptionIntelligenceUpdateManyArgs>(args: SelectSubset<T, JobDescriptionIntelligenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobDescriptionIntelligences and returns the data updated in the database.
     * @param {JobDescriptionIntelligenceUpdateManyAndReturnArgs} args - Arguments to update many JobDescriptionIntelligences.
     * @example
     * // Update many JobDescriptionIntelligences
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobDescriptionIntelligences and only return the `id`
     * const jobDescriptionIntelligenceWithIdOnly = await prisma.jobDescriptionIntelligence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobDescriptionIntelligenceUpdateManyAndReturnArgs>(args: SelectSubset<T, JobDescriptionIntelligenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobDescriptionIntelligence.
     * @param {JobDescriptionIntelligenceUpsertArgs} args - Arguments to update or create a JobDescriptionIntelligence.
     * @example
     * // Update or create a JobDescriptionIntelligence
     * const jobDescriptionIntelligence = await prisma.jobDescriptionIntelligence.upsert({
     *   create: {
     *     // ... data to create a JobDescriptionIntelligence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobDescriptionIntelligence we want to update
     *   }
     * })
     */
    upsert<T extends JobDescriptionIntelligenceUpsertArgs>(args: SelectSubset<T, JobDescriptionIntelligenceUpsertArgs<ExtArgs>>): Prisma__JobDescriptionIntelligenceClient<$Result.GetResult<Prisma.$JobDescriptionIntelligencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobDescriptionIntelligences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDescriptionIntelligenceCountArgs} args - Arguments to filter JobDescriptionIntelligences to count.
     * @example
     * // Count the number of JobDescriptionIntelligences
     * const count = await prisma.jobDescriptionIntelligence.count({
     *   where: {
     *     // ... the filter for the JobDescriptionIntelligences we want to count
     *   }
     * })
    **/
    count<T extends JobDescriptionIntelligenceCountArgs>(
      args?: Subset<T, JobDescriptionIntelligenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobDescriptionIntelligenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobDescriptionIntelligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDescriptionIntelligenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobDescriptionIntelligenceAggregateArgs>(args: Subset<T, JobDescriptionIntelligenceAggregateArgs>): Prisma.PrismaPromise<GetJobDescriptionIntelligenceAggregateType<T>>

    /**
     * Group by JobDescriptionIntelligence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDescriptionIntelligenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobDescriptionIntelligenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobDescriptionIntelligenceGroupByArgs['orderBy'] }
        : { orderBy?: JobDescriptionIntelligenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobDescriptionIntelligenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobDescriptionIntelligenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobDescriptionIntelligence model
   */
  readonly fields: JobDescriptionIntelligenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobDescriptionIntelligence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobDescriptionIntelligenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobDescriptionIntelligence model
   */
  interface JobDescriptionIntelligenceFieldRefs {
    readonly id: FieldRef<"JobDescriptionIntelligence", 'String'>
    readonly userId: FieldRef<"JobDescriptionIntelligence", 'String'>
    readonly resumeId: FieldRef<"JobDescriptionIntelligence", 'String'>
    readonly role: FieldRef<"JobDescriptionIntelligence", 'String'>
    readonly seniority: FieldRef<"JobDescriptionIntelligence", 'String'>
    readonly keywords: FieldRef<"JobDescriptionIntelligence", 'String[]'>
    readonly responsibilities: FieldRef<"JobDescriptionIntelligence", 'String[]'>
    readonly qualifications: FieldRef<"JobDescriptionIntelligence", 'String[]'>
    readonly categories: FieldRef<"JobDescriptionIntelligence", 'Json'>
    readonly createdAt: FieldRef<"JobDescriptionIntelligence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobDescriptionIntelligence findUnique
   */
  export type JobDescriptionIntelligenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which JobDescriptionIntelligence to fetch.
     */
    where: JobDescriptionIntelligenceWhereUniqueInput
  }

  /**
   * JobDescriptionIntelligence findUniqueOrThrow
   */
  export type JobDescriptionIntelligenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which JobDescriptionIntelligence to fetch.
     */
    where: JobDescriptionIntelligenceWhereUniqueInput
  }

  /**
   * JobDescriptionIntelligence findFirst
   */
  export type JobDescriptionIntelligenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which JobDescriptionIntelligence to fetch.
     */
    where?: JobDescriptionIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDescriptionIntelligences to fetch.
     */
    orderBy?: JobDescriptionIntelligenceOrderByWithRelationInput | JobDescriptionIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobDescriptionIntelligences.
     */
    cursor?: JobDescriptionIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDescriptionIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDescriptionIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobDescriptionIntelligences.
     */
    distinct?: JobDescriptionIntelligenceScalarFieldEnum | JobDescriptionIntelligenceScalarFieldEnum[]
  }

  /**
   * JobDescriptionIntelligence findFirstOrThrow
   */
  export type JobDescriptionIntelligenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which JobDescriptionIntelligence to fetch.
     */
    where?: JobDescriptionIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDescriptionIntelligences to fetch.
     */
    orderBy?: JobDescriptionIntelligenceOrderByWithRelationInput | JobDescriptionIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobDescriptionIntelligences.
     */
    cursor?: JobDescriptionIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDescriptionIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDescriptionIntelligences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobDescriptionIntelligences.
     */
    distinct?: JobDescriptionIntelligenceScalarFieldEnum | JobDescriptionIntelligenceScalarFieldEnum[]
  }

  /**
   * JobDescriptionIntelligence findMany
   */
  export type JobDescriptionIntelligenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * Filter, which JobDescriptionIntelligences to fetch.
     */
    where?: JobDescriptionIntelligenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDescriptionIntelligences to fetch.
     */
    orderBy?: JobDescriptionIntelligenceOrderByWithRelationInput | JobDescriptionIntelligenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobDescriptionIntelligences.
     */
    cursor?: JobDescriptionIntelligenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDescriptionIntelligences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDescriptionIntelligences.
     */
    skip?: number
    distinct?: JobDescriptionIntelligenceScalarFieldEnum | JobDescriptionIntelligenceScalarFieldEnum[]
  }

  /**
   * JobDescriptionIntelligence create
   */
  export type JobDescriptionIntelligenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * The data needed to create a JobDescriptionIntelligence.
     */
    data: XOR<JobDescriptionIntelligenceCreateInput, JobDescriptionIntelligenceUncheckedCreateInput>
  }

  /**
   * JobDescriptionIntelligence createMany
   */
  export type JobDescriptionIntelligenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobDescriptionIntelligences.
     */
    data: JobDescriptionIntelligenceCreateManyInput | JobDescriptionIntelligenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobDescriptionIntelligence createManyAndReturn
   */
  export type JobDescriptionIntelligenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * The data used to create many JobDescriptionIntelligences.
     */
    data: JobDescriptionIntelligenceCreateManyInput | JobDescriptionIntelligenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobDescriptionIntelligence update
   */
  export type JobDescriptionIntelligenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * The data needed to update a JobDescriptionIntelligence.
     */
    data: XOR<JobDescriptionIntelligenceUpdateInput, JobDescriptionIntelligenceUncheckedUpdateInput>
    /**
     * Choose, which JobDescriptionIntelligence to update.
     */
    where: JobDescriptionIntelligenceWhereUniqueInput
  }

  /**
   * JobDescriptionIntelligence updateMany
   */
  export type JobDescriptionIntelligenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobDescriptionIntelligences.
     */
    data: XOR<JobDescriptionIntelligenceUpdateManyMutationInput, JobDescriptionIntelligenceUncheckedUpdateManyInput>
    /**
     * Filter which JobDescriptionIntelligences to update
     */
    where?: JobDescriptionIntelligenceWhereInput
    /**
     * Limit how many JobDescriptionIntelligences to update.
     */
    limit?: number
  }

  /**
   * JobDescriptionIntelligence updateManyAndReturn
   */
  export type JobDescriptionIntelligenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * The data used to update JobDescriptionIntelligences.
     */
    data: XOR<JobDescriptionIntelligenceUpdateManyMutationInput, JobDescriptionIntelligenceUncheckedUpdateManyInput>
    /**
     * Filter which JobDescriptionIntelligences to update
     */
    where?: JobDescriptionIntelligenceWhereInput
    /**
     * Limit how many JobDescriptionIntelligences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobDescriptionIntelligence upsert
   */
  export type JobDescriptionIntelligenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * The filter to search for the JobDescriptionIntelligence to update in case it exists.
     */
    where: JobDescriptionIntelligenceWhereUniqueInput
    /**
     * In case the JobDescriptionIntelligence found by the `where` argument doesn't exist, create a new JobDescriptionIntelligence with this data.
     */
    create: XOR<JobDescriptionIntelligenceCreateInput, JobDescriptionIntelligenceUncheckedCreateInput>
    /**
     * In case the JobDescriptionIntelligence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobDescriptionIntelligenceUpdateInput, JobDescriptionIntelligenceUncheckedUpdateInput>
  }

  /**
   * JobDescriptionIntelligence delete
   */
  export type JobDescriptionIntelligenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
    /**
     * Filter which JobDescriptionIntelligence to delete.
     */
    where: JobDescriptionIntelligenceWhereUniqueInput
  }

  /**
   * JobDescriptionIntelligence deleteMany
   */
  export type JobDescriptionIntelligenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobDescriptionIntelligences to delete
     */
    where?: JobDescriptionIntelligenceWhereInput
    /**
     * Limit how many JobDescriptionIntelligences to delete.
     */
    limit?: number
  }

  /**
   * JobDescriptionIntelligence without action
   */
  export type JobDescriptionIntelligenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobDescriptionIntelligence
     */
    select?: JobDescriptionIntelligenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobDescriptionIntelligence
     */
    omit?: JobDescriptionIntelligenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobDescriptionIntelligenceInclude<ExtArgs> | null
  }


  /**
   * Model ResumeSectionRationale
   */

  export type AggregateResumeSectionRationale = {
    _count: ResumeSectionRationaleCountAggregateOutputType | null
    _min: ResumeSectionRationaleMinAggregateOutputType | null
    _max: ResumeSectionRationaleMaxAggregateOutputType | null
  }

  export type ResumeSectionRationaleMinAggregateOutputType = {
    id: string | null
    resumeId: string | null
    userId: string | null
    sectionName: string | null
    rationale: string | null
    createdAt: Date | null
  }

  export type ResumeSectionRationaleMaxAggregateOutputType = {
    id: string | null
    resumeId: string | null
    userId: string | null
    sectionName: string | null
    rationale: string | null
    createdAt: Date | null
  }

  export type ResumeSectionRationaleCountAggregateOutputType = {
    id: number
    resumeId: number
    userId: number
    sectionName: number
    rationale: number
    createdAt: number
    _all: number
  }


  export type ResumeSectionRationaleMinAggregateInputType = {
    id?: true
    resumeId?: true
    userId?: true
    sectionName?: true
    rationale?: true
    createdAt?: true
  }

  export type ResumeSectionRationaleMaxAggregateInputType = {
    id?: true
    resumeId?: true
    userId?: true
    sectionName?: true
    rationale?: true
    createdAt?: true
  }

  export type ResumeSectionRationaleCountAggregateInputType = {
    id?: true
    resumeId?: true
    userId?: true
    sectionName?: true
    rationale?: true
    createdAt?: true
    _all?: true
  }

  export type ResumeSectionRationaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeSectionRationale to aggregate.
     */
    where?: ResumeSectionRationaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeSectionRationales to fetch.
     */
    orderBy?: ResumeSectionRationaleOrderByWithRelationInput | ResumeSectionRationaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeSectionRationaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeSectionRationales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeSectionRationales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeSectionRationales
    **/
    _count?: true | ResumeSectionRationaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeSectionRationaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeSectionRationaleMaxAggregateInputType
  }

  export type GetResumeSectionRationaleAggregateType<T extends ResumeSectionRationaleAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeSectionRationale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeSectionRationale[P]>
      : GetScalarType<T[P], AggregateResumeSectionRationale[P]>
  }




  export type ResumeSectionRationaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeSectionRationaleWhereInput
    orderBy?: ResumeSectionRationaleOrderByWithAggregationInput | ResumeSectionRationaleOrderByWithAggregationInput[]
    by: ResumeSectionRationaleScalarFieldEnum[] | ResumeSectionRationaleScalarFieldEnum
    having?: ResumeSectionRationaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeSectionRationaleCountAggregateInputType | true
    _min?: ResumeSectionRationaleMinAggregateInputType
    _max?: ResumeSectionRationaleMaxAggregateInputType
  }

  export type ResumeSectionRationaleGroupByOutputType = {
    id: string
    resumeId: string
    userId: string
    sectionName: string
    rationale: string
    createdAt: Date
    _count: ResumeSectionRationaleCountAggregateOutputType | null
    _min: ResumeSectionRationaleMinAggregateOutputType | null
    _max: ResumeSectionRationaleMaxAggregateOutputType | null
  }

  type GetResumeSectionRationaleGroupByPayload<T extends ResumeSectionRationaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeSectionRationaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeSectionRationaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeSectionRationaleGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeSectionRationaleGroupByOutputType[P]>
        }
      >
    >


  export type ResumeSectionRationaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    userId?: boolean
    sectionName?: boolean
    rationale?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeSectionRationale"]>

  export type ResumeSectionRationaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    userId?: boolean
    sectionName?: boolean
    rationale?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeSectionRationale"]>

  export type ResumeSectionRationaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    userId?: boolean
    sectionName?: boolean
    rationale?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeSectionRationale"]>

  export type ResumeSectionRationaleSelectScalar = {
    id?: boolean
    resumeId?: boolean
    userId?: boolean
    sectionName?: boolean
    rationale?: boolean
    createdAt?: boolean
  }

  export type ResumeSectionRationaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resumeId" | "userId" | "sectionName" | "rationale" | "createdAt", ExtArgs["result"]["resumeSectionRationale"]>
  export type ResumeSectionRationaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResumeSectionRationaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResumeSectionRationaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResumeSectionRationalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeSectionRationale"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resumeId: string
      userId: string
      sectionName: string
      rationale: string
      createdAt: Date
    }, ExtArgs["result"]["resumeSectionRationale"]>
    composites: {}
  }

  type ResumeSectionRationaleGetPayload<S extends boolean | null | undefined | ResumeSectionRationaleDefaultArgs> = $Result.GetResult<Prisma.$ResumeSectionRationalePayload, S>

  type ResumeSectionRationaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeSectionRationaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeSectionRationaleCountAggregateInputType | true
    }

  export interface ResumeSectionRationaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeSectionRationale'], meta: { name: 'ResumeSectionRationale' } }
    /**
     * Find zero or one ResumeSectionRationale that matches the filter.
     * @param {ResumeSectionRationaleFindUniqueArgs} args - Arguments to find a ResumeSectionRationale
     * @example
     * // Get one ResumeSectionRationale
     * const resumeSectionRationale = await prisma.resumeSectionRationale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeSectionRationaleFindUniqueArgs>(args: SelectSubset<T, ResumeSectionRationaleFindUniqueArgs<ExtArgs>>): Prisma__ResumeSectionRationaleClient<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResumeSectionRationale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeSectionRationaleFindUniqueOrThrowArgs} args - Arguments to find a ResumeSectionRationale
     * @example
     * // Get one ResumeSectionRationale
     * const resumeSectionRationale = await prisma.resumeSectionRationale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeSectionRationaleFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeSectionRationaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeSectionRationaleClient<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeSectionRationale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSectionRationaleFindFirstArgs} args - Arguments to find a ResumeSectionRationale
     * @example
     * // Get one ResumeSectionRationale
     * const resumeSectionRationale = await prisma.resumeSectionRationale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeSectionRationaleFindFirstArgs>(args?: SelectSubset<T, ResumeSectionRationaleFindFirstArgs<ExtArgs>>): Prisma__ResumeSectionRationaleClient<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeSectionRationale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSectionRationaleFindFirstOrThrowArgs} args - Arguments to find a ResumeSectionRationale
     * @example
     * // Get one ResumeSectionRationale
     * const resumeSectionRationale = await prisma.resumeSectionRationale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeSectionRationaleFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeSectionRationaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeSectionRationaleClient<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResumeSectionRationales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSectionRationaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeSectionRationales
     * const resumeSectionRationales = await prisma.resumeSectionRationale.findMany()
     * 
     * // Get first 10 ResumeSectionRationales
     * const resumeSectionRationales = await prisma.resumeSectionRationale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeSectionRationaleWithIdOnly = await prisma.resumeSectionRationale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeSectionRationaleFindManyArgs>(args?: SelectSubset<T, ResumeSectionRationaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResumeSectionRationale.
     * @param {ResumeSectionRationaleCreateArgs} args - Arguments to create a ResumeSectionRationale.
     * @example
     * // Create one ResumeSectionRationale
     * const ResumeSectionRationale = await prisma.resumeSectionRationale.create({
     *   data: {
     *     // ... data to create a ResumeSectionRationale
     *   }
     * })
     * 
     */
    create<T extends ResumeSectionRationaleCreateArgs>(args: SelectSubset<T, ResumeSectionRationaleCreateArgs<ExtArgs>>): Prisma__ResumeSectionRationaleClient<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResumeSectionRationales.
     * @param {ResumeSectionRationaleCreateManyArgs} args - Arguments to create many ResumeSectionRationales.
     * @example
     * // Create many ResumeSectionRationales
     * const resumeSectionRationale = await prisma.resumeSectionRationale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeSectionRationaleCreateManyArgs>(args?: SelectSubset<T, ResumeSectionRationaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResumeSectionRationales and returns the data saved in the database.
     * @param {ResumeSectionRationaleCreateManyAndReturnArgs} args - Arguments to create many ResumeSectionRationales.
     * @example
     * // Create many ResumeSectionRationales
     * const resumeSectionRationale = await prisma.resumeSectionRationale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResumeSectionRationales and only return the `id`
     * const resumeSectionRationaleWithIdOnly = await prisma.resumeSectionRationale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeSectionRationaleCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeSectionRationaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResumeSectionRationale.
     * @param {ResumeSectionRationaleDeleteArgs} args - Arguments to delete one ResumeSectionRationale.
     * @example
     * // Delete one ResumeSectionRationale
     * const ResumeSectionRationale = await prisma.resumeSectionRationale.delete({
     *   where: {
     *     // ... filter to delete one ResumeSectionRationale
     *   }
     * })
     * 
     */
    delete<T extends ResumeSectionRationaleDeleteArgs>(args: SelectSubset<T, ResumeSectionRationaleDeleteArgs<ExtArgs>>): Prisma__ResumeSectionRationaleClient<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResumeSectionRationale.
     * @param {ResumeSectionRationaleUpdateArgs} args - Arguments to update one ResumeSectionRationale.
     * @example
     * // Update one ResumeSectionRationale
     * const resumeSectionRationale = await prisma.resumeSectionRationale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeSectionRationaleUpdateArgs>(args: SelectSubset<T, ResumeSectionRationaleUpdateArgs<ExtArgs>>): Prisma__ResumeSectionRationaleClient<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResumeSectionRationales.
     * @param {ResumeSectionRationaleDeleteManyArgs} args - Arguments to filter ResumeSectionRationales to delete.
     * @example
     * // Delete a few ResumeSectionRationales
     * const { count } = await prisma.resumeSectionRationale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeSectionRationaleDeleteManyArgs>(args?: SelectSubset<T, ResumeSectionRationaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeSectionRationales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSectionRationaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeSectionRationales
     * const resumeSectionRationale = await prisma.resumeSectionRationale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeSectionRationaleUpdateManyArgs>(args: SelectSubset<T, ResumeSectionRationaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeSectionRationales and returns the data updated in the database.
     * @param {ResumeSectionRationaleUpdateManyAndReturnArgs} args - Arguments to update many ResumeSectionRationales.
     * @example
     * // Update many ResumeSectionRationales
     * const resumeSectionRationale = await prisma.resumeSectionRationale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResumeSectionRationales and only return the `id`
     * const resumeSectionRationaleWithIdOnly = await prisma.resumeSectionRationale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeSectionRationaleUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeSectionRationaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResumeSectionRationale.
     * @param {ResumeSectionRationaleUpsertArgs} args - Arguments to update or create a ResumeSectionRationale.
     * @example
     * // Update or create a ResumeSectionRationale
     * const resumeSectionRationale = await prisma.resumeSectionRationale.upsert({
     *   create: {
     *     // ... data to create a ResumeSectionRationale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeSectionRationale we want to update
     *   }
     * })
     */
    upsert<T extends ResumeSectionRationaleUpsertArgs>(args: SelectSubset<T, ResumeSectionRationaleUpsertArgs<ExtArgs>>): Prisma__ResumeSectionRationaleClient<$Result.GetResult<Prisma.$ResumeSectionRationalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResumeSectionRationales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSectionRationaleCountArgs} args - Arguments to filter ResumeSectionRationales to count.
     * @example
     * // Count the number of ResumeSectionRationales
     * const count = await prisma.resumeSectionRationale.count({
     *   where: {
     *     // ... the filter for the ResumeSectionRationales we want to count
     *   }
     * })
    **/
    count<T extends ResumeSectionRationaleCountArgs>(
      args?: Subset<T, ResumeSectionRationaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeSectionRationaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeSectionRationale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSectionRationaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeSectionRationaleAggregateArgs>(args: Subset<T, ResumeSectionRationaleAggregateArgs>): Prisma.PrismaPromise<GetResumeSectionRationaleAggregateType<T>>

    /**
     * Group by ResumeSectionRationale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeSectionRationaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeSectionRationaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeSectionRationaleGroupByArgs['orderBy'] }
        : { orderBy?: ResumeSectionRationaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeSectionRationaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeSectionRationaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeSectionRationale model
   */
  readonly fields: ResumeSectionRationaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeSectionRationale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeSectionRationaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumeSectionRationale model
   */
  interface ResumeSectionRationaleFieldRefs {
    readonly id: FieldRef<"ResumeSectionRationale", 'String'>
    readonly resumeId: FieldRef<"ResumeSectionRationale", 'String'>
    readonly userId: FieldRef<"ResumeSectionRationale", 'String'>
    readonly sectionName: FieldRef<"ResumeSectionRationale", 'String'>
    readonly rationale: FieldRef<"ResumeSectionRationale", 'String'>
    readonly createdAt: FieldRef<"ResumeSectionRationale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResumeSectionRationale findUnique
   */
  export type ResumeSectionRationaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSectionRationale to fetch.
     */
    where: ResumeSectionRationaleWhereUniqueInput
  }

  /**
   * ResumeSectionRationale findUniqueOrThrow
   */
  export type ResumeSectionRationaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSectionRationale to fetch.
     */
    where: ResumeSectionRationaleWhereUniqueInput
  }

  /**
   * ResumeSectionRationale findFirst
   */
  export type ResumeSectionRationaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSectionRationale to fetch.
     */
    where?: ResumeSectionRationaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeSectionRationales to fetch.
     */
    orderBy?: ResumeSectionRationaleOrderByWithRelationInput | ResumeSectionRationaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeSectionRationales.
     */
    cursor?: ResumeSectionRationaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeSectionRationales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeSectionRationales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeSectionRationales.
     */
    distinct?: ResumeSectionRationaleScalarFieldEnum | ResumeSectionRationaleScalarFieldEnum[]
  }

  /**
   * ResumeSectionRationale findFirstOrThrow
   */
  export type ResumeSectionRationaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSectionRationale to fetch.
     */
    where?: ResumeSectionRationaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeSectionRationales to fetch.
     */
    orderBy?: ResumeSectionRationaleOrderByWithRelationInput | ResumeSectionRationaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeSectionRationales.
     */
    cursor?: ResumeSectionRationaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeSectionRationales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeSectionRationales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeSectionRationales.
     */
    distinct?: ResumeSectionRationaleScalarFieldEnum | ResumeSectionRationaleScalarFieldEnum[]
  }

  /**
   * ResumeSectionRationale findMany
   */
  export type ResumeSectionRationaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * Filter, which ResumeSectionRationales to fetch.
     */
    where?: ResumeSectionRationaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeSectionRationales to fetch.
     */
    orderBy?: ResumeSectionRationaleOrderByWithRelationInput | ResumeSectionRationaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeSectionRationales.
     */
    cursor?: ResumeSectionRationaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeSectionRationales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeSectionRationales.
     */
    skip?: number
    distinct?: ResumeSectionRationaleScalarFieldEnum | ResumeSectionRationaleScalarFieldEnum[]
  }

  /**
   * ResumeSectionRationale create
   */
  export type ResumeSectionRationaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeSectionRationale.
     */
    data: XOR<ResumeSectionRationaleCreateInput, ResumeSectionRationaleUncheckedCreateInput>
  }

  /**
   * ResumeSectionRationale createMany
   */
  export type ResumeSectionRationaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeSectionRationales.
     */
    data: ResumeSectionRationaleCreateManyInput | ResumeSectionRationaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeSectionRationale createManyAndReturn
   */
  export type ResumeSectionRationaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * The data used to create many ResumeSectionRationales.
     */
    data: ResumeSectionRationaleCreateManyInput | ResumeSectionRationaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeSectionRationale update
   */
  export type ResumeSectionRationaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeSectionRationale.
     */
    data: XOR<ResumeSectionRationaleUpdateInput, ResumeSectionRationaleUncheckedUpdateInput>
    /**
     * Choose, which ResumeSectionRationale to update.
     */
    where: ResumeSectionRationaleWhereUniqueInput
  }

  /**
   * ResumeSectionRationale updateMany
   */
  export type ResumeSectionRationaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeSectionRationales.
     */
    data: XOR<ResumeSectionRationaleUpdateManyMutationInput, ResumeSectionRationaleUncheckedUpdateManyInput>
    /**
     * Filter which ResumeSectionRationales to update
     */
    where?: ResumeSectionRationaleWhereInput
    /**
     * Limit how many ResumeSectionRationales to update.
     */
    limit?: number
  }

  /**
   * ResumeSectionRationale updateManyAndReturn
   */
  export type ResumeSectionRationaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * The data used to update ResumeSectionRationales.
     */
    data: XOR<ResumeSectionRationaleUpdateManyMutationInput, ResumeSectionRationaleUncheckedUpdateManyInput>
    /**
     * Filter which ResumeSectionRationales to update
     */
    where?: ResumeSectionRationaleWhereInput
    /**
     * Limit how many ResumeSectionRationales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeSectionRationale upsert
   */
  export type ResumeSectionRationaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeSectionRationale to update in case it exists.
     */
    where: ResumeSectionRationaleWhereUniqueInput
    /**
     * In case the ResumeSectionRationale found by the `where` argument doesn't exist, create a new ResumeSectionRationale with this data.
     */
    create: XOR<ResumeSectionRationaleCreateInput, ResumeSectionRationaleUncheckedCreateInput>
    /**
     * In case the ResumeSectionRationale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeSectionRationaleUpdateInput, ResumeSectionRationaleUncheckedUpdateInput>
  }

  /**
   * ResumeSectionRationale delete
   */
  export type ResumeSectionRationaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
    /**
     * Filter which ResumeSectionRationale to delete.
     */
    where: ResumeSectionRationaleWhereUniqueInput
  }

  /**
   * ResumeSectionRationale deleteMany
   */
  export type ResumeSectionRationaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeSectionRationales to delete
     */
    where?: ResumeSectionRationaleWhereInput
    /**
     * Limit how many ResumeSectionRationales to delete.
     */
    limit?: number
  }

  /**
   * ResumeSectionRationale without action
   */
  export type ResumeSectionRationaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeSectionRationale
     */
    select?: ResumeSectionRationaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeSectionRationale
     */
    omit?: ResumeSectionRationaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeSectionRationaleInclude<ExtArgs> | null
  }


  /**
   * Model ContactSubmission
   */

  export type AggregateContactSubmission = {
    _count: ContactSubmissionCountAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  export type ContactSubmissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type ContactSubmissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type ContactSubmissionCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subject: number
    message: number
    createdAt: number
    isRead: number
    _all: number
  }


  export type ContactSubmissionMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    isRead?: true
  }

  export type ContactSubmissionMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    isRead?: true
  }

  export type ContactSubmissionCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    isRead?: true
    _all?: true
  }

  export type ContactSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmission to aggregate.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactSubmissions
    **/
    _count?: true | ContactSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type GetContactSubmissionAggregateType<T extends ContactSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateContactSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactSubmission[P]>
      : GetScalarType<T[P], AggregateContactSubmission[P]>
  }




  export type ContactSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactSubmissionWhereInput
    orderBy?: ContactSubmissionOrderByWithAggregationInput | ContactSubmissionOrderByWithAggregationInput[]
    by: ContactSubmissionScalarFieldEnum[] | ContactSubmissionScalarFieldEnum
    having?: ContactSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactSubmissionCountAggregateInputType | true
    _min?: ContactSubmissionMinAggregateInputType
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type ContactSubmissionGroupByOutputType = {
    id: string
    name: string
    email: string
    subject: string
    message: string
    createdAt: Date
    isRead: boolean
    _count: ContactSubmissionCountAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  type GetContactSubmissionGroupByPayload<T extends ContactSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type ContactSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    isRead?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    isRead?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    isRead?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    isRead?: boolean
  }

  export type ContactSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "subject" | "message" | "createdAt" | "isRead", ExtArgs["result"]["contactSubmission"]>

  export type $ContactSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactSubmission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      subject: string
      message: string
      createdAt: Date
      isRead: boolean
    }, ExtArgs["result"]["contactSubmission"]>
    composites: {}
  }

  type ContactSubmissionGetPayload<S extends boolean | null | undefined | ContactSubmissionDefaultArgs> = $Result.GetResult<Prisma.$ContactSubmissionPayload, S>

  type ContactSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactSubmissionCountAggregateInputType | true
    }

  export interface ContactSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactSubmission'], meta: { name: 'ContactSubmission' } }
    /**
     * Find zero or one ContactSubmission that matches the filter.
     * @param {ContactSubmissionFindUniqueArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactSubmissionFindUniqueArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactSubmissionFindFirstArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany()
     * 
     * // Get first 10 ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactSubmissionFindManyArgs>(args?: SelectSubset<T, ContactSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactSubmission.
     * @param {ContactSubmissionCreateArgs} args - Arguments to create a ContactSubmission.
     * @example
     * // Create one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.create({
     *   data: {
     *     // ... data to create a ContactSubmission
     *   }
     * })
     * 
     */
    create<T extends ContactSubmissionCreateArgs>(args: SelectSubset<T, ContactSubmissionCreateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactSubmissions.
     * @param {ContactSubmissionCreateManyArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactSubmissionCreateManyArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactSubmissions and returns the data saved in the database.
     * @param {ContactSubmissionCreateManyAndReturnArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactSubmission.
     * @param {ContactSubmissionDeleteArgs} args - Arguments to delete one ContactSubmission.
     * @example
     * // Delete one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.delete({
     *   where: {
     *     // ... filter to delete one ContactSubmission
     *   }
     * })
     * 
     */
    delete<T extends ContactSubmissionDeleteArgs>(args: SelectSubset<T, ContactSubmissionDeleteArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactSubmission.
     * @param {ContactSubmissionUpdateArgs} args - Arguments to update one ContactSubmission.
     * @example
     * // Update one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactSubmissionUpdateArgs>(args: SelectSubset<T, ContactSubmissionUpdateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactSubmissions.
     * @param {ContactSubmissionDeleteManyArgs} args - Arguments to filter ContactSubmissions to delete.
     * @example
     * // Delete a few ContactSubmissions
     * const { count } = await prisma.contactSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactSubmissionDeleteManyArgs>(args?: SelectSubset<T, ContactSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactSubmissionUpdateManyArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions and returns the data updated in the database.
     * @param {ContactSubmissionUpdateManyAndReturnArgs} args - Arguments to update many ContactSubmissions.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactSubmission.
     * @param {ContactSubmissionUpsertArgs} args - Arguments to update or create a ContactSubmission.
     * @example
     * // Update or create a ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.upsert({
     *   create: {
     *     // ... data to create a ContactSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactSubmission we want to update
     *   }
     * })
     */
    upsert<T extends ContactSubmissionUpsertArgs>(args: SelectSubset<T, ContactSubmissionUpsertArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionCountArgs} args - Arguments to filter ContactSubmissions to count.
     * @example
     * // Count the number of ContactSubmissions
     * const count = await prisma.contactSubmission.count({
     *   where: {
     *     // ... the filter for the ContactSubmissions we want to count
     *   }
     * })
    **/
    count<T extends ContactSubmissionCountArgs>(
      args?: Subset<T, ContactSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactSubmissionAggregateArgs>(args: Subset<T, ContactSubmissionAggregateArgs>): Prisma.PrismaPromise<GetContactSubmissionAggregateType<T>>

    /**
     * Group by ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ContactSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactSubmission model
   */
  readonly fields: ContactSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactSubmission model
   */
  interface ContactSubmissionFieldRefs {
    readonly id: FieldRef<"ContactSubmission", 'String'>
    readonly name: FieldRef<"ContactSubmission", 'String'>
    readonly email: FieldRef<"ContactSubmission", 'String'>
    readonly subject: FieldRef<"ContactSubmission", 'String'>
    readonly message: FieldRef<"ContactSubmission", 'String'>
    readonly createdAt: FieldRef<"ContactSubmission", 'DateTime'>
    readonly isRead: FieldRef<"ContactSubmission", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ContactSubmission findUnique
   */
  export type ContactSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findUniqueOrThrow
   */
  export type ContactSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findFirst
   */
  export type ContactSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findFirstOrThrow
   */
  export type ContactSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findMany
   */
  export type ContactSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmissions to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission create
   */
  export type ContactSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactSubmission.
     */
    data: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
  }

  /**
   * ContactSubmission createMany
   */
  export type ContactSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission createManyAndReturn
   */
  export type ContactSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission update
   */
  export type ContactSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactSubmission.
     */
    data: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
    /**
     * Choose, which ContactSubmission to update.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission updateMany
   */
  export type ContactSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission updateManyAndReturn
   */
  export type ContactSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission upsert
   */
  export type ContactSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactSubmission to update in case it exists.
     */
    where: ContactSubmissionWhereUniqueInput
    /**
     * In case the ContactSubmission found by the `where` argument doesn't exist, create a new ContactSubmission with this data.
     */
    create: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
    /**
     * In case the ContactSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
  }

  /**
   * ContactSubmission delete
   */
  export type ContactSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter which ContactSubmission to delete.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission deleteMany
   */
  export type ContactSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmissions to delete
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to delete.
     */
    limit?: number
  }

  /**
   * ContactSubmission without action
   */
  export type ContactSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    fullName: 'fullName',
    isPremium: 'isPremium',
    dailyResetDate: 'dailyResetDate',
    dailyBasicTailoringsUsed: 'dailyBasicTailoringsUsed',
    dailyPersonalizedTailoringsUsed: 'dailyPersonalizedTailoringsUsed',
    dailyAggressiveTailoringsUsed: 'dailyAggressiveTailoringsUsed',
    dailyCoverLettersUsed: 'dailyCoverLettersUsed',
    dailyLinkedinOptimizationsUsed: 'dailyLinkedinOptimizationsUsed',
    dailyInterviewSessionsUsed: 'dailyInterviewSessionsUsed',
    analyticsTimeRange: 'analyticsTimeRange',
    analyticsViewMode: 'analyticsViewMode',
    resumeTemplate: 'resumeTemplate',
    preferredTailoringMode: 'preferredTailoringMode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ResumeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeText: 'resumeText',
    jobDescription: 'jobDescription',
    modifiedResume: 'modifiedResume',
    tailoringMode: 'tailoringMode',
    version: 'version',
    label: 'label',
    atsScore: 'atsScore',
    jdScore: 'jdScore',
    goldenPassed: 'goldenPassed',
    isRefinement: 'isRefinement',
    isSaved: 'isSaved',
    originalResumeId: 'originalResumeId',
    wasManuallyEdited: 'wasManuallyEdited',
    scoresStale: 'scoresStale',
    finalModifiedSections: 'finalModifiedSections',
    atsWarnings: 'atsWarnings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResumeScalarFieldEnum = (typeof ResumeScalarFieldEnum)[keyof typeof ResumeScalarFieldEnum]


  export const ResumeEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    eventType: 'eventType',
    resumeText: 'resumeText',
    jobDescription: 'jobDescription',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ResumeEventScalarFieldEnum = (typeof ResumeEventScalarFieldEnum)[keyof typeof ResumeEventScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const TailoringAnalyticsScalarFieldEnum: {
    id: 'id',
    resumeId: 'resumeId',
    userId: 'userId',
    tailoringMode: 'tailoringMode',
    iterations: 'iterations',
    atsScore: 'atsScore',
    jdScore: 'jdScore',
    goldenPassed: 'goldenPassed',
    isRefinement: 'isRefinement',
    createdAt: 'createdAt',
    modifiedSections: 'modifiedSections'
  };

  export type TailoringAnalyticsScalarFieldEnum = (typeof TailoringAnalyticsScalarFieldEnum)[keyof typeof TailoringAnalyticsScalarFieldEnum]


  export const ScrubbedResumeScalarFieldEnum: {
    id: 'id',
    resumeId: 'resumeId',
    cleanText: 'cleanText',
    createdAt: 'createdAt'
  };

  export type ScrubbedResumeScalarFieldEnum = (typeof ScrubbedResumeScalarFieldEnum)[keyof typeof ScrubbedResumeScalarFieldEnum]


  export const PromptArchiveScalarFieldEnum: {
    id: 'id',
    resumeId: 'resumeId',
    content: 'content',
    response: 'response',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type PromptArchiveScalarFieldEnum = (typeof PromptArchiveScalarFieldEnum)[keyof typeof PromptArchiveScalarFieldEnum]


  export const ResumeInteractionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    action: 'action',
    createdAt: 'createdAt'
  };

  export type ResumeInteractionScalarFieldEnum = (typeof ResumeInteractionScalarFieldEnum)[keyof typeof ResumeInteractionScalarFieldEnum]


  export const ResumeTagScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    tag: 'tag'
  };

  export type ResumeTagScalarFieldEnum = (typeof ResumeTagScalarFieldEnum)[keyof typeof ResumeTagScalarFieldEnum]


  export const ResumeMetadataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    contentSnippet: 'contentSnippet',
    tailoringMode: 'tailoringMode',
    iterations: 'iterations',
    passedRules: 'passedRules',
    atsScore: 'atsScore',
    jdScore: 'jdScore',
    createdAt: 'createdAt'
  };

  export type ResumeMetadataScalarFieldEnum = (typeof ResumeMetadataScalarFieldEnum)[keyof typeof ResumeMetadataScalarFieldEnum]


  export const TailoringPromptScalarFieldEnum: {
    id: 'id',
    resumeId: 'resumeId',
    tailoringMode: 'tailoringMode',
    prompt: 'prompt',
    attempt: 'attempt',
    version: 'version',
    createdAt: 'createdAt'
  };

  export type TailoringPromptScalarFieldEnum = (typeof TailoringPromptScalarFieldEnum)[keyof typeof TailoringPromptScalarFieldEnum]


  export const TailoringProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    status: 'status',
    progress: 'progress',
    currentAttempt: 'currentAttempt',
    maxAttempts: 'maxAttempts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TailoringProgressScalarFieldEnum = (typeof TailoringProgressScalarFieldEnum)[keyof typeof TailoringProgressScalarFieldEnum]


  export const TailoringAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    attemptNumber: 'attemptNumber',
    atsScore: 'atsScore',
    jdScore: 'jdScore',
    goldenPassed: 'goldenPassed',
    feedback: 'feedback',
    suggestions: 'suggestions',
    atsFeedback: 'atsFeedback',
    jdFeedback: 'jdFeedback',
    createdAt: 'createdAt',
    modifiedSectionsSent: 'modifiedSectionsSent',
    modifiedSectionsReceived: 'modifiedSectionsReceived',
    promptTokens: 'promptTokens',
    goldenRuleFeedback: 'goldenRuleFeedback',
    iteration: 'iteration',
    modifiedSections: 'modifiedSections',
    score: 'score'
  };

  export type TailoringAttemptScalarFieldEnum = (typeof TailoringAttemptScalarFieldEnum)[keyof typeof TailoringAttemptScalarFieldEnum]


  export const ResumeFeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    feedbackType: 'feedbackType',
    feedbackPoints: 'feedbackPoints',
    sourceVersion: 'sourceVersion',
    createdAt: 'createdAt'
  };

  export type ResumeFeedbackScalarFieldEnum = (typeof ResumeFeedbackScalarFieldEnum)[keyof typeof ResumeFeedbackScalarFieldEnum]


  export const ManualEditScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    editedText: 'editedText',
    createdAt: 'createdAt'
  };

  export type ManualEditScalarFieldEnum = (typeof ManualEditScalarFieldEnum)[keyof typeof ManualEditScalarFieldEnum]


  export const ManualScoringScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    atsScore: 'atsScore',
    jdScore: 'jdScore',
    atsFeedback: 'atsFeedback',
    jdFeedback: 'jdFeedback',
    createdAt: 'createdAt'
  };

  export type ManualScoringScalarFieldEnum = (typeof ManualScoringScalarFieldEnum)[keyof typeof ManualScoringScalarFieldEnum]


  export const CoverLetterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    jobDescription: 'jobDescription',
    content: 'content',
    tone: 'tone',
    atsScore: 'atsScore',
    jdScore: 'jdScore',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoverLetterScalarFieldEnum = (typeof CoverLetterScalarFieldEnum)[keyof typeof CoverLetterScalarFieldEnum]


  export const LinkedInOptimizationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    jobDescription: 'jobDescription',
    originalAbout: 'originalAbout',
    optimizedAbout: 'optimizedAbout',
    tone: 'tone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LinkedInOptimizationScalarFieldEnum = (typeof LinkedInOptimizationScalarFieldEnum)[keyof typeof LinkedInOptimizationScalarFieldEnum]


  export const InterviewSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    jobDescription: 'jobDescription',
    selectedTypes: 'selectedTypes',
    questions: 'questions',
    answers: 'answers',
    needsReview: 'needsReview',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterviewSessionScalarFieldEnum = (typeof InterviewSessionScalarFieldEnum)[keyof typeof InterviewSessionScalarFieldEnum]


  export const ResumeExportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    templateId: 'templateId',
    format: 'format',
    createdAt: 'createdAt'
  };

  export type ResumeExportScalarFieldEnum = (typeof ResumeExportScalarFieldEnum)[keyof typeof ResumeExportScalarFieldEnum]


  export const JobDescriptionIntelligenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    role: 'role',
    seniority: 'seniority',
    keywords: 'keywords',
    responsibilities: 'responsibilities',
    qualifications: 'qualifications',
    categories: 'categories',
    createdAt: 'createdAt'
  };

  export type JobDescriptionIntelligenceScalarFieldEnum = (typeof JobDescriptionIntelligenceScalarFieldEnum)[keyof typeof JobDescriptionIntelligenceScalarFieldEnum]


  export const ResumeSectionRationaleScalarFieldEnum: {
    id: 'id',
    resumeId: 'resumeId',
    userId: 'userId',
    sectionName: 'sectionName',
    rationale: 'rationale',
    createdAt: 'createdAt'
  };

  export type ResumeSectionRationaleScalarFieldEnum = (typeof ResumeSectionRationaleScalarFieldEnum)[keyof typeof ResumeSectionRationaleScalarFieldEnum]


  export const ContactSubmissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    createdAt: 'createdAt',
    isRead: 'isRead'
  };

  export type ContactSubmissionScalarFieldEnum = (typeof ContactSubmissionScalarFieldEnum)[keyof typeof ContactSubmissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    isPremium?: BoolFilter<"User"> | boolean
    dailyResetDate?: DateTimeNullableFilter<"User"> | Date | string | null
    dailyBasicTailoringsUsed?: IntFilter<"User"> | number
    dailyPersonalizedTailoringsUsed?: IntFilter<"User"> | number
    dailyAggressiveTailoringsUsed?: IntFilter<"User"> | number
    dailyCoverLettersUsed?: IntFilter<"User"> | number
    dailyLinkedinOptimizationsUsed?: IntFilter<"User"> | number
    dailyInterviewSessionsUsed?: IntFilter<"User"> | number
    analyticsTimeRange?: StringNullableFilter<"User"> | string | null
    analyticsViewMode?: StringNullableFilter<"User"> | string | null
    resumeTemplate?: StringNullableFilter<"User"> | string | null
    preferredTailoringMode?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    resumes?: ResumeListRelationFilter
    analytics?: TailoringAnalyticsListRelationFilter
    interactions?: ResumeInteractionListRelationFilter
    coverLetters?: CoverLetterListRelationFilter
    linkedInOptimizations?: LinkedInOptimizationListRelationFilter
    interviewSessions?: InterviewSessionListRelationFilter
    resumeExports?: ResumeExportListRelationFilter
    jdIntelligence?: JobDescriptionIntelligenceListRelationFilter
    ResumeTag?: ResumeTagListRelationFilter
    ResumeMetadata?: ResumeMetadataListRelationFilter
    ResumeSectionRationale?: ResumeSectionRationaleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrderInput | SortOrder
    isPremium?: SortOrder
    dailyResetDate?: SortOrderInput | SortOrder
    dailyBasicTailoringsUsed?: SortOrder
    dailyPersonalizedTailoringsUsed?: SortOrder
    dailyAggressiveTailoringsUsed?: SortOrder
    dailyCoverLettersUsed?: SortOrder
    dailyLinkedinOptimizationsUsed?: SortOrder
    dailyInterviewSessionsUsed?: SortOrder
    analyticsTimeRange?: SortOrderInput | SortOrder
    analyticsViewMode?: SortOrderInput | SortOrder
    resumeTemplate?: SortOrderInput | SortOrder
    preferredTailoringMode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resumes?: ResumeOrderByRelationAggregateInput
    analytics?: TailoringAnalyticsOrderByRelationAggregateInput
    interactions?: ResumeInteractionOrderByRelationAggregateInput
    coverLetters?: CoverLetterOrderByRelationAggregateInput
    linkedInOptimizations?: LinkedInOptimizationOrderByRelationAggregateInput
    interviewSessions?: InterviewSessionOrderByRelationAggregateInput
    resumeExports?: ResumeExportOrderByRelationAggregateInput
    jdIntelligence?: JobDescriptionIntelligenceOrderByRelationAggregateInput
    ResumeTag?: ResumeTagOrderByRelationAggregateInput
    ResumeMetadata?: ResumeMetadataOrderByRelationAggregateInput
    ResumeSectionRationale?: ResumeSectionRationaleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringNullableFilter<"User"> | string | null
    isPremium?: BoolFilter<"User"> | boolean
    dailyResetDate?: DateTimeNullableFilter<"User"> | Date | string | null
    dailyBasicTailoringsUsed?: IntFilter<"User"> | number
    dailyPersonalizedTailoringsUsed?: IntFilter<"User"> | number
    dailyAggressiveTailoringsUsed?: IntFilter<"User"> | number
    dailyCoverLettersUsed?: IntFilter<"User"> | number
    dailyLinkedinOptimizationsUsed?: IntFilter<"User"> | number
    dailyInterviewSessionsUsed?: IntFilter<"User"> | number
    analyticsTimeRange?: StringNullableFilter<"User"> | string | null
    analyticsViewMode?: StringNullableFilter<"User"> | string | null
    resumeTemplate?: StringNullableFilter<"User"> | string | null
    preferredTailoringMode?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    resumes?: ResumeListRelationFilter
    analytics?: TailoringAnalyticsListRelationFilter
    interactions?: ResumeInteractionListRelationFilter
    coverLetters?: CoverLetterListRelationFilter
    linkedInOptimizations?: LinkedInOptimizationListRelationFilter
    interviewSessions?: InterviewSessionListRelationFilter
    resumeExports?: ResumeExportListRelationFilter
    jdIntelligence?: JobDescriptionIntelligenceListRelationFilter
    ResumeTag?: ResumeTagListRelationFilter
    ResumeMetadata?: ResumeMetadataListRelationFilter
    ResumeSectionRationale?: ResumeSectionRationaleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrderInput | SortOrder
    isPremium?: SortOrder
    dailyResetDate?: SortOrderInput | SortOrder
    dailyBasicTailoringsUsed?: SortOrder
    dailyPersonalizedTailoringsUsed?: SortOrder
    dailyAggressiveTailoringsUsed?: SortOrder
    dailyCoverLettersUsed?: SortOrder
    dailyLinkedinOptimizationsUsed?: SortOrder
    dailyInterviewSessionsUsed?: SortOrder
    analyticsTimeRange?: SortOrderInput | SortOrder
    analyticsViewMode?: SortOrderInput | SortOrder
    resumeTemplate?: SortOrderInput | SortOrder
    preferredTailoringMode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    isPremium?: BoolWithAggregatesFilter<"User"> | boolean
    dailyResetDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    dailyBasicTailoringsUsed?: IntWithAggregatesFilter<"User"> | number
    dailyPersonalizedTailoringsUsed?: IntWithAggregatesFilter<"User"> | number
    dailyAggressiveTailoringsUsed?: IntWithAggregatesFilter<"User"> | number
    dailyCoverLettersUsed?: IntWithAggregatesFilter<"User"> | number
    dailyLinkedinOptimizationsUsed?: IntWithAggregatesFilter<"User"> | number
    dailyInterviewSessionsUsed?: IntWithAggregatesFilter<"User"> | number
    analyticsTimeRange?: StringNullableWithAggregatesFilter<"User"> | string | null
    analyticsViewMode?: StringNullableWithAggregatesFilter<"User"> | string | null
    resumeTemplate?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredTailoringMode?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ResumeWhereInput = {
    AND?: ResumeWhereInput | ResumeWhereInput[]
    OR?: ResumeWhereInput[]
    NOT?: ResumeWhereInput | ResumeWhereInput[]
    id?: StringFilter<"Resume"> | string
    userId?: StringFilter<"Resume"> | string
    resumeText?: StringFilter<"Resume"> | string
    jobDescription?: StringFilter<"Resume"> | string
    modifiedResume?: StringNullableFilter<"Resume"> | string | null
    tailoringMode?: StringFilter<"Resume"> | string
    version?: IntFilter<"Resume"> | number
    label?: StringNullableFilter<"Resume"> | string | null
    atsScore?: IntNullableFilter<"Resume"> | number | null
    jdScore?: IntNullableFilter<"Resume"> | number | null
    goldenPassed?: BoolFilter<"Resume"> | boolean
    isRefinement?: BoolFilter<"Resume"> | boolean
    isSaved?: BoolFilter<"Resume"> | boolean
    originalResumeId?: StringNullableFilter<"Resume"> | string | null
    wasManuallyEdited?: BoolFilter<"Resume"> | boolean
    scoresStale?: BoolFilter<"Resume"> | boolean
    finalModifiedSections?: StringNullableFilter<"Resume"> | string | null
    atsWarnings?: StringNullableFilter<"Resume"> | string | null
    createdAt?: DateTimeFilter<"Resume"> | Date | string
    updatedAt?: DateTimeFilter<"Resume"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    analytics?: TailoringAnalyticsListRelationFilter
    scrubbedResume?: XOR<ScrubbedResumeNullableScalarRelationFilter, ScrubbedResumeWhereInput> | null
    promptArchives?: PromptArchiveListRelationFilter
    interactions?: ResumeInteractionListRelationFilter
    tags?: ResumeTagListRelationFilter
    metadata?: XOR<ResumeMetadataNullableScalarRelationFilter, ResumeMetadataWhereInput> | null
    tailoringPrompts?: TailoringPromptListRelationFilter
    coverLetters?: CoverLetterListRelationFilter
    exports?: ResumeExportListRelationFilter
    tailoringProgress?: TailoringProgressListRelationFilter
    tailoringAttempts?: TailoringAttemptListRelationFilter
    manualEdits?: ManualEditListRelationFilter
    manualScorings?: ManualScoringListRelationFilter
    resumeFeedback?: ResumeFeedbackListRelationFilter
    ResumeSectionRationale?: ResumeSectionRationaleListRelationFilter
  }

  export type ResumeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    modifiedResume?: SortOrderInput | SortOrder
    tailoringMode?: SortOrder
    version?: SortOrder
    label?: SortOrderInput | SortOrder
    atsScore?: SortOrderInput | SortOrder
    jdScore?: SortOrderInput | SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    isSaved?: SortOrder
    originalResumeId?: SortOrderInput | SortOrder
    wasManuallyEdited?: SortOrder
    scoresStale?: SortOrder
    finalModifiedSections?: SortOrderInput | SortOrder
    atsWarnings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    analytics?: TailoringAnalyticsOrderByRelationAggregateInput
    scrubbedResume?: ScrubbedResumeOrderByWithRelationInput
    promptArchives?: PromptArchiveOrderByRelationAggregateInput
    interactions?: ResumeInteractionOrderByRelationAggregateInput
    tags?: ResumeTagOrderByRelationAggregateInput
    metadata?: ResumeMetadataOrderByWithRelationInput
    tailoringPrompts?: TailoringPromptOrderByRelationAggregateInput
    coverLetters?: CoverLetterOrderByRelationAggregateInput
    exports?: ResumeExportOrderByRelationAggregateInput
    tailoringProgress?: TailoringProgressOrderByRelationAggregateInput
    tailoringAttempts?: TailoringAttemptOrderByRelationAggregateInput
    manualEdits?: ManualEditOrderByRelationAggregateInput
    manualScorings?: ManualScoringOrderByRelationAggregateInput
    resumeFeedback?: ResumeFeedbackOrderByRelationAggregateInput
    ResumeSectionRationale?: ResumeSectionRationaleOrderByRelationAggregateInput
  }

  export type ResumeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResumeWhereInput | ResumeWhereInput[]
    OR?: ResumeWhereInput[]
    NOT?: ResumeWhereInput | ResumeWhereInput[]
    userId?: StringFilter<"Resume"> | string
    resumeText?: StringFilter<"Resume"> | string
    jobDescription?: StringFilter<"Resume"> | string
    modifiedResume?: StringNullableFilter<"Resume"> | string | null
    tailoringMode?: StringFilter<"Resume"> | string
    version?: IntFilter<"Resume"> | number
    label?: StringNullableFilter<"Resume"> | string | null
    atsScore?: IntNullableFilter<"Resume"> | number | null
    jdScore?: IntNullableFilter<"Resume"> | number | null
    goldenPassed?: BoolFilter<"Resume"> | boolean
    isRefinement?: BoolFilter<"Resume"> | boolean
    isSaved?: BoolFilter<"Resume"> | boolean
    originalResumeId?: StringNullableFilter<"Resume"> | string | null
    wasManuallyEdited?: BoolFilter<"Resume"> | boolean
    scoresStale?: BoolFilter<"Resume"> | boolean
    finalModifiedSections?: StringNullableFilter<"Resume"> | string | null
    atsWarnings?: StringNullableFilter<"Resume"> | string | null
    createdAt?: DateTimeFilter<"Resume"> | Date | string
    updatedAt?: DateTimeFilter<"Resume"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    analytics?: TailoringAnalyticsListRelationFilter
    scrubbedResume?: XOR<ScrubbedResumeNullableScalarRelationFilter, ScrubbedResumeWhereInput> | null
    promptArchives?: PromptArchiveListRelationFilter
    interactions?: ResumeInteractionListRelationFilter
    tags?: ResumeTagListRelationFilter
    metadata?: XOR<ResumeMetadataNullableScalarRelationFilter, ResumeMetadataWhereInput> | null
    tailoringPrompts?: TailoringPromptListRelationFilter
    coverLetters?: CoverLetterListRelationFilter
    exports?: ResumeExportListRelationFilter
    tailoringProgress?: TailoringProgressListRelationFilter
    tailoringAttempts?: TailoringAttemptListRelationFilter
    manualEdits?: ManualEditListRelationFilter
    manualScorings?: ManualScoringListRelationFilter
    resumeFeedback?: ResumeFeedbackListRelationFilter
    ResumeSectionRationale?: ResumeSectionRationaleListRelationFilter
  }, "id">

  export type ResumeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    modifiedResume?: SortOrderInput | SortOrder
    tailoringMode?: SortOrder
    version?: SortOrder
    label?: SortOrderInput | SortOrder
    atsScore?: SortOrderInput | SortOrder
    jdScore?: SortOrderInput | SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    isSaved?: SortOrder
    originalResumeId?: SortOrderInput | SortOrder
    wasManuallyEdited?: SortOrder
    scoresStale?: SortOrder
    finalModifiedSections?: SortOrderInput | SortOrder
    atsWarnings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResumeCountOrderByAggregateInput
    _avg?: ResumeAvgOrderByAggregateInput
    _max?: ResumeMaxOrderByAggregateInput
    _min?: ResumeMinOrderByAggregateInput
    _sum?: ResumeSumOrderByAggregateInput
  }

  export type ResumeScalarWhereWithAggregatesInput = {
    AND?: ResumeScalarWhereWithAggregatesInput | ResumeScalarWhereWithAggregatesInput[]
    OR?: ResumeScalarWhereWithAggregatesInput[]
    NOT?: ResumeScalarWhereWithAggregatesInput | ResumeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resume"> | string
    userId?: StringWithAggregatesFilter<"Resume"> | string
    resumeText?: StringWithAggregatesFilter<"Resume"> | string
    jobDescription?: StringWithAggregatesFilter<"Resume"> | string
    modifiedResume?: StringNullableWithAggregatesFilter<"Resume"> | string | null
    tailoringMode?: StringWithAggregatesFilter<"Resume"> | string
    version?: IntWithAggregatesFilter<"Resume"> | number
    label?: StringNullableWithAggregatesFilter<"Resume"> | string | null
    atsScore?: IntNullableWithAggregatesFilter<"Resume"> | number | null
    jdScore?: IntNullableWithAggregatesFilter<"Resume"> | number | null
    goldenPassed?: BoolWithAggregatesFilter<"Resume"> | boolean
    isRefinement?: BoolWithAggregatesFilter<"Resume"> | boolean
    isSaved?: BoolWithAggregatesFilter<"Resume"> | boolean
    originalResumeId?: StringNullableWithAggregatesFilter<"Resume"> | string | null
    wasManuallyEdited?: BoolWithAggregatesFilter<"Resume"> | boolean
    scoresStale?: BoolWithAggregatesFilter<"Resume"> | boolean
    finalModifiedSections?: StringNullableWithAggregatesFilter<"Resume"> | string | null
    atsWarnings?: StringNullableWithAggregatesFilter<"Resume"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Resume"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resume"> | Date | string
  }

  export type ResumeEventWhereInput = {
    AND?: ResumeEventWhereInput | ResumeEventWhereInput[]
    OR?: ResumeEventWhereInput[]
    NOT?: ResumeEventWhereInput | ResumeEventWhereInput[]
    id?: StringFilter<"ResumeEvent"> | string
    userId?: StringFilter<"ResumeEvent"> | string
    resumeId?: StringFilter<"ResumeEvent"> | string
    eventType?: StringFilter<"ResumeEvent"> | string
    resumeText?: StringNullableFilter<"ResumeEvent"> | string | null
    jobDescription?: StringNullableFilter<"ResumeEvent"> | string | null
    metadata?: JsonNullableFilter<"ResumeEvent">
    createdAt?: DateTimeFilter<"ResumeEvent"> | Date | string
  }

  export type ResumeEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    eventType?: SortOrder
    resumeText?: SortOrderInput | SortOrder
    jobDescription?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ResumeEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResumeEventWhereInput | ResumeEventWhereInput[]
    OR?: ResumeEventWhereInput[]
    NOT?: ResumeEventWhereInput | ResumeEventWhereInput[]
    userId?: StringFilter<"ResumeEvent"> | string
    resumeId?: StringFilter<"ResumeEvent"> | string
    eventType?: StringFilter<"ResumeEvent"> | string
    resumeText?: StringNullableFilter<"ResumeEvent"> | string | null
    jobDescription?: StringNullableFilter<"ResumeEvent"> | string | null
    metadata?: JsonNullableFilter<"ResumeEvent">
    createdAt?: DateTimeFilter<"ResumeEvent"> | Date | string
  }, "id">

  export type ResumeEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    eventType?: SortOrder
    resumeText?: SortOrderInput | SortOrder
    jobDescription?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ResumeEventCountOrderByAggregateInput
    _max?: ResumeEventMaxOrderByAggregateInput
    _min?: ResumeEventMinOrderByAggregateInput
  }

  export type ResumeEventScalarWhereWithAggregatesInput = {
    AND?: ResumeEventScalarWhereWithAggregatesInput | ResumeEventScalarWhereWithAggregatesInput[]
    OR?: ResumeEventScalarWhereWithAggregatesInput[]
    NOT?: ResumeEventScalarWhereWithAggregatesInput | ResumeEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResumeEvent"> | string
    userId?: StringWithAggregatesFilter<"ResumeEvent"> | string
    resumeId?: StringWithAggregatesFilter<"ResumeEvent"> | string
    eventType?: StringWithAggregatesFilter<"ResumeEvent"> | string
    resumeText?: StringNullableWithAggregatesFilter<"ResumeEvent"> | string | null
    jobDescription?: StringNullableWithAggregatesFilter<"ResumeEvent"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ResumeEvent">
    createdAt?: DateTimeWithAggregatesFilter<"ResumeEvent"> | Date | string
  }

  export type AnalyticsEventWhereInput = {
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    eventType?: StringFilter<"AnalyticsEvent"> | string
    metadata?: JsonNullableFilter<"AnalyticsEvent">
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    eventType?: StringFilter<"AnalyticsEvent"> | string
    metadata?: JsonNullableFilter<"AnalyticsEvent">
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }, "id">

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEventScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    eventType?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AnalyticsEvent">
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
  }

  export type TailoringAnalyticsWhereInput = {
    AND?: TailoringAnalyticsWhereInput | TailoringAnalyticsWhereInput[]
    OR?: TailoringAnalyticsWhereInput[]
    NOT?: TailoringAnalyticsWhereInput | TailoringAnalyticsWhereInput[]
    id?: StringFilter<"TailoringAnalytics"> | string
    resumeId?: StringFilter<"TailoringAnalytics"> | string
    userId?: StringFilter<"TailoringAnalytics"> | string
    tailoringMode?: StringFilter<"TailoringAnalytics"> | string
    iterations?: IntFilter<"TailoringAnalytics"> | number
    atsScore?: IntFilter<"TailoringAnalytics"> | number
    jdScore?: IntFilter<"TailoringAnalytics"> | number
    goldenPassed?: BoolFilter<"TailoringAnalytics"> | boolean
    isRefinement?: BoolFilter<"TailoringAnalytics"> | boolean
    createdAt?: DateTimeFilter<"TailoringAnalytics"> | Date | string
    modifiedSections?: StringNullableFilter<"TailoringAnalytics"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type TailoringAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    createdAt?: SortOrder
    modifiedSections?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
  }

  export type TailoringAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TailoringAnalyticsWhereInput | TailoringAnalyticsWhereInput[]
    OR?: TailoringAnalyticsWhereInput[]
    NOT?: TailoringAnalyticsWhereInput | TailoringAnalyticsWhereInput[]
    resumeId?: StringFilter<"TailoringAnalytics"> | string
    userId?: StringFilter<"TailoringAnalytics"> | string
    tailoringMode?: StringFilter<"TailoringAnalytics"> | string
    iterations?: IntFilter<"TailoringAnalytics"> | number
    atsScore?: IntFilter<"TailoringAnalytics"> | number
    jdScore?: IntFilter<"TailoringAnalytics"> | number
    goldenPassed?: BoolFilter<"TailoringAnalytics"> | boolean
    isRefinement?: BoolFilter<"TailoringAnalytics"> | boolean
    createdAt?: DateTimeFilter<"TailoringAnalytics"> | Date | string
    modifiedSections?: StringNullableFilter<"TailoringAnalytics"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type TailoringAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    createdAt?: SortOrder
    modifiedSections?: SortOrderInput | SortOrder
    _count?: TailoringAnalyticsCountOrderByAggregateInput
    _avg?: TailoringAnalyticsAvgOrderByAggregateInput
    _max?: TailoringAnalyticsMaxOrderByAggregateInput
    _min?: TailoringAnalyticsMinOrderByAggregateInput
    _sum?: TailoringAnalyticsSumOrderByAggregateInput
  }

  export type TailoringAnalyticsScalarWhereWithAggregatesInput = {
    AND?: TailoringAnalyticsScalarWhereWithAggregatesInput | TailoringAnalyticsScalarWhereWithAggregatesInput[]
    OR?: TailoringAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: TailoringAnalyticsScalarWhereWithAggregatesInput | TailoringAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TailoringAnalytics"> | string
    resumeId?: StringWithAggregatesFilter<"TailoringAnalytics"> | string
    userId?: StringWithAggregatesFilter<"TailoringAnalytics"> | string
    tailoringMode?: StringWithAggregatesFilter<"TailoringAnalytics"> | string
    iterations?: IntWithAggregatesFilter<"TailoringAnalytics"> | number
    atsScore?: IntWithAggregatesFilter<"TailoringAnalytics"> | number
    jdScore?: IntWithAggregatesFilter<"TailoringAnalytics"> | number
    goldenPassed?: BoolWithAggregatesFilter<"TailoringAnalytics"> | boolean
    isRefinement?: BoolWithAggregatesFilter<"TailoringAnalytics"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TailoringAnalytics"> | Date | string
    modifiedSections?: StringNullableWithAggregatesFilter<"TailoringAnalytics"> | string | null
  }

  export type ScrubbedResumeWhereInput = {
    AND?: ScrubbedResumeWhereInput | ScrubbedResumeWhereInput[]
    OR?: ScrubbedResumeWhereInput[]
    NOT?: ScrubbedResumeWhereInput | ScrubbedResumeWhereInput[]
    id?: StringFilter<"ScrubbedResume"> | string
    resumeId?: StringFilter<"ScrubbedResume"> | string
    cleanText?: StringFilter<"ScrubbedResume"> | string
    createdAt?: DateTimeFilter<"ScrubbedResume"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ScrubbedResumeOrderByWithRelationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    cleanText?: SortOrder
    createdAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type ScrubbedResumeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    resumeId?: string
    AND?: ScrubbedResumeWhereInput | ScrubbedResumeWhereInput[]
    OR?: ScrubbedResumeWhereInput[]
    NOT?: ScrubbedResumeWhereInput | ScrubbedResumeWhereInput[]
    cleanText?: StringFilter<"ScrubbedResume"> | string
    createdAt?: DateTimeFilter<"ScrubbedResume"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id" | "resumeId">

  export type ScrubbedResumeOrderByWithAggregationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    cleanText?: SortOrder
    createdAt?: SortOrder
    _count?: ScrubbedResumeCountOrderByAggregateInput
    _max?: ScrubbedResumeMaxOrderByAggregateInput
    _min?: ScrubbedResumeMinOrderByAggregateInput
  }

  export type ScrubbedResumeScalarWhereWithAggregatesInput = {
    AND?: ScrubbedResumeScalarWhereWithAggregatesInput | ScrubbedResumeScalarWhereWithAggregatesInput[]
    OR?: ScrubbedResumeScalarWhereWithAggregatesInput[]
    NOT?: ScrubbedResumeScalarWhereWithAggregatesInput | ScrubbedResumeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScrubbedResume"> | string
    resumeId?: StringWithAggregatesFilter<"ScrubbedResume"> | string
    cleanText?: StringWithAggregatesFilter<"ScrubbedResume"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScrubbedResume"> | Date | string
  }

  export type PromptArchiveWhereInput = {
    AND?: PromptArchiveWhereInput | PromptArchiveWhereInput[]
    OR?: PromptArchiveWhereInput[]
    NOT?: PromptArchiveWhereInput | PromptArchiveWhereInput[]
    id?: StringFilter<"PromptArchive"> | string
    resumeId?: StringFilter<"PromptArchive"> | string
    content?: StringFilter<"PromptArchive"> | string
    response?: StringFilter<"PromptArchive"> | string
    metadata?: JsonNullableFilter<"PromptArchive">
    createdAt?: DateTimeFilter<"PromptArchive"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type PromptArchiveOrderByWithRelationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    content?: SortOrder
    response?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type PromptArchiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptArchiveWhereInput | PromptArchiveWhereInput[]
    OR?: PromptArchiveWhereInput[]
    NOT?: PromptArchiveWhereInput | PromptArchiveWhereInput[]
    resumeId?: StringFilter<"PromptArchive"> | string
    content?: StringFilter<"PromptArchive"> | string
    response?: StringFilter<"PromptArchive"> | string
    metadata?: JsonNullableFilter<"PromptArchive">
    createdAt?: DateTimeFilter<"PromptArchive"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type PromptArchiveOrderByWithAggregationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    content?: SortOrder
    response?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PromptArchiveCountOrderByAggregateInput
    _max?: PromptArchiveMaxOrderByAggregateInput
    _min?: PromptArchiveMinOrderByAggregateInput
  }

  export type PromptArchiveScalarWhereWithAggregatesInput = {
    AND?: PromptArchiveScalarWhereWithAggregatesInput | PromptArchiveScalarWhereWithAggregatesInput[]
    OR?: PromptArchiveScalarWhereWithAggregatesInput[]
    NOT?: PromptArchiveScalarWhereWithAggregatesInput | PromptArchiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromptArchive"> | string
    resumeId?: StringWithAggregatesFilter<"PromptArchive"> | string
    content?: StringWithAggregatesFilter<"PromptArchive"> | string
    response?: StringWithAggregatesFilter<"PromptArchive"> | string
    metadata?: JsonNullableWithAggregatesFilter<"PromptArchive">
    createdAt?: DateTimeWithAggregatesFilter<"PromptArchive"> | Date | string
  }

  export type ResumeInteractionWhereInput = {
    AND?: ResumeInteractionWhereInput | ResumeInteractionWhereInput[]
    OR?: ResumeInteractionWhereInput[]
    NOT?: ResumeInteractionWhereInput | ResumeInteractionWhereInput[]
    id?: StringFilter<"ResumeInteraction"> | string
    userId?: StringFilter<"ResumeInteraction"> | string
    resumeId?: StringFilter<"ResumeInteraction"> | string
    action?: StringFilter<"ResumeInteraction"> | string
    createdAt?: DateTimeFilter<"ResumeInteraction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ResumeInteractionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
  }

  export type ResumeInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResumeInteractionWhereInput | ResumeInteractionWhereInput[]
    OR?: ResumeInteractionWhereInput[]
    NOT?: ResumeInteractionWhereInput | ResumeInteractionWhereInput[]
    userId?: StringFilter<"ResumeInteraction"> | string
    resumeId?: StringFilter<"ResumeInteraction"> | string
    action?: StringFilter<"ResumeInteraction"> | string
    createdAt?: DateTimeFilter<"ResumeInteraction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type ResumeInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    _count?: ResumeInteractionCountOrderByAggregateInput
    _max?: ResumeInteractionMaxOrderByAggregateInput
    _min?: ResumeInteractionMinOrderByAggregateInput
  }

  export type ResumeInteractionScalarWhereWithAggregatesInput = {
    AND?: ResumeInteractionScalarWhereWithAggregatesInput | ResumeInteractionScalarWhereWithAggregatesInput[]
    OR?: ResumeInteractionScalarWhereWithAggregatesInput[]
    NOT?: ResumeInteractionScalarWhereWithAggregatesInput | ResumeInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResumeInteraction"> | string
    userId?: StringWithAggregatesFilter<"ResumeInteraction"> | string
    resumeId?: StringWithAggregatesFilter<"ResumeInteraction"> | string
    action?: StringWithAggregatesFilter<"ResumeInteraction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ResumeInteraction"> | Date | string
  }

  export type ResumeTagWhereInput = {
    AND?: ResumeTagWhereInput | ResumeTagWhereInput[]
    OR?: ResumeTagWhereInput[]
    NOT?: ResumeTagWhereInput | ResumeTagWhereInput[]
    id?: StringFilter<"ResumeTag"> | string
    userId?: StringFilter<"ResumeTag"> | string
    resumeId?: StringFilter<"ResumeTag"> | string
    tag?: StringFilter<"ResumeTag"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ResumeTagOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    tag?: SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
  }

  export type ResumeTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResumeTagWhereInput | ResumeTagWhereInput[]
    OR?: ResumeTagWhereInput[]
    NOT?: ResumeTagWhereInput | ResumeTagWhereInput[]
    userId?: StringFilter<"ResumeTag"> | string
    resumeId?: StringFilter<"ResumeTag"> | string
    tag?: StringFilter<"ResumeTag"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type ResumeTagOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    tag?: SortOrder
    _count?: ResumeTagCountOrderByAggregateInput
    _max?: ResumeTagMaxOrderByAggregateInput
    _min?: ResumeTagMinOrderByAggregateInput
  }

  export type ResumeTagScalarWhereWithAggregatesInput = {
    AND?: ResumeTagScalarWhereWithAggregatesInput | ResumeTagScalarWhereWithAggregatesInput[]
    OR?: ResumeTagScalarWhereWithAggregatesInput[]
    NOT?: ResumeTagScalarWhereWithAggregatesInput | ResumeTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResumeTag"> | string
    userId?: StringWithAggregatesFilter<"ResumeTag"> | string
    resumeId?: StringWithAggregatesFilter<"ResumeTag"> | string
    tag?: StringWithAggregatesFilter<"ResumeTag"> | string
  }

  export type ResumeMetadataWhereInput = {
    AND?: ResumeMetadataWhereInput | ResumeMetadataWhereInput[]
    OR?: ResumeMetadataWhereInput[]
    NOT?: ResumeMetadataWhereInput | ResumeMetadataWhereInput[]
    id?: StringFilter<"ResumeMetadata"> | string
    userId?: StringFilter<"ResumeMetadata"> | string
    resumeId?: StringFilter<"ResumeMetadata"> | string
    contentSnippet?: StringFilter<"ResumeMetadata"> | string
    tailoringMode?: StringFilter<"ResumeMetadata"> | string
    iterations?: IntFilter<"ResumeMetadata"> | number
    passedRules?: BoolFilter<"ResumeMetadata"> | boolean
    atsScore?: IntFilter<"ResumeMetadata"> | number
    jdScore?: IntFilter<"ResumeMetadata"> | number
    createdAt?: DateTimeFilter<"ResumeMetadata"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ResumeMetadataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    contentSnippet?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    passedRules?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
  }

  export type ResumeMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    resumeId?: string
    AND?: ResumeMetadataWhereInput | ResumeMetadataWhereInput[]
    OR?: ResumeMetadataWhereInput[]
    NOT?: ResumeMetadataWhereInput | ResumeMetadataWhereInput[]
    userId?: StringFilter<"ResumeMetadata"> | string
    contentSnippet?: StringFilter<"ResumeMetadata"> | string
    tailoringMode?: StringFilter<"ResumeMetadata"> | string
    iterations?: IntFilter<"ResumeMetadata"> | number
    passedRules?: BoolFilter<"ResumeMetadata"> | boolean
    atsScore?: IntFilter<"ResumeMetadata"> | number
    jdScore?: IntFilter<"ResumeMetadata"> | number
    createdAt?: DateTimeFilter<"ResumeMetadata"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id" | "resumeId">

  export type ResumeMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    contentSnippet?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    passedRules?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    createdAt?: SortOrder
    _count?: ResumeMetadataCountOrderByAggregateInput
    _avg?: ResumeMetadataAvgOrderByAggregateInput
    _max?: ResumeMetadataMaxOrderByAggregateInput
    _min?: ResumeMetadataMinOrderByAggregateInput
    _sum?: ResumeMetadataSumOrderByAggregateInput
  }

  export type ResumeMetadataScalarWhereWithAggregatesInput = {
    AND?: ResumeMetadataScalarWhereWithAggregatesInput | ResumeMetadataScalarWhereWithAggregatesInput[]
    OR?: ResumeMetadataScalarWhereWithAggregatesInput[]
    NOT?: ResumeMetadataScalarWhereWithAggregatesInput | ResumeMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResumeMetadata"> | string
    userId?: StringWithAggregatesFilter<"ResumeMetadata"> | string
    resumeId?: StringWithAggregatesFilter<"ResumeMetadata"> | string
    contentSnippet?: StringWithAggregatesFilter<"ResumeMetadata"> | string
    tailoringMode?: StringWithAggregatesFilter<"ResumeMetadata"> | string
    iterations?: IntWithAggregatesFilter<"ResumeMetadata"> | number
    passedRules?: BoolWithAggregatesFilter<"ResumeMetadata"> | boolean
    atsScore?: IntWithAggregatesFilter<"ResumeMetadata"> | number
    jdScore?: IntWithAggregatesFilter<"ResumeMetadata"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ResumeMetadata"> | Date | string
  }

  export type TailoringPromptWhereInput = {
    AND?: TailoringPromptWhereInput | TailoringPromptWhereInput[]
    OR?: TailoringPromptWhereInput[]
    NOT?: TailoringPromptWhereInput | TailoringPromptWhereInput[]
    id?: StringFilter<"TailoringPrompt"> | string
    resumeId?: StringFilter<"TailoringPrompt"> | string
    tailoringMode?: StringFilter<"TailoringPrompt"> | string
    prompt?: StringFilter<"TailoringPrompt"> | string
    attempt?: IntFilter<"TailoringPrompt"> | number
    version?: IntFilter<"TailoringPrompt"> | number
    createdAt?: DateTimeFilter<"TailoringPrompt"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type TailoringPromptOrderByWithRelationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    tailoringMode?: SortOrder
    prompt?: SortOrder
    attempt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type TailoringPromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TailoringPromptWhereInput | TailoringPromptWhereInput[]
    OR?: TailoringPromptWhereInput[]
    NOT?: TailoringPromptWhereInput | TailoringPromptWhereInput[]
    resumeId?: StringFilter<"TailoringPrompt"> | string
    tailoringMode?: StringFilter<"TailoringPrompt"> | string
    prompt?: StringFilter<"TailoringPrompt"> | string
    attempt?: IntFilter<"TailoringPrompt"> | number
    version?: IntFilter<"TailoringPrompt"> | number
    createdAt?: DateTimeFilter<"TailoringPrompt"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type TailoringPromptOrderByWithAggregationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    tailoringMode?: SortOrder
    prompt?: SortOrder
    attempt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    _count?: TailoringPromptCountOrderByAggregateInput
    _avg?: TailoringPromptAvgOrderByAggregateInput
    _max?: TailoringPromptMaxOrderByAggregateInput
    _min?: TailoringPromptMinOrderByAggregateInput
    _sum?: TailoringPromptSumOrderByAggregateInput
  }

  export type TailoringPromptScalarWhereWithAggregatesInput = {
    AND?: TailoringPromptScalarWhereWithAggregatesInput | TailoringPromptScalarWhereWithAggregatesInput[]
    OR?: TailoringPromptScalarWhereWithAggregatesInput[]
    NOT?: TailoringPromptScalarWhereWithAggregatesInput | TailoringPromptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TailoringPrompt"> | string
    resumeId?: StringWithAggregatesFilter<"TailoringPrompt"> | string
    tailoringMode?: StringWithAggregatesFilter<"TailoringPrompt"> | string
    prompt?: StringWithAggregatesFilter<"TailoringPrompt"> | string
    attempt?: IntWithAggregatesFilter<"TailoringPrompt"> | number
    version?: IntWithAggregatesFilter<"TailoringPrompt"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TailoringPrompt"> | Date | string
  }

  export type TailoringProgressWhereInput = {
    AND?: TailoringProgressWhereInput | TailoringProgressWhereInput[]
    OR?: TailoringProgressWhereInput[]
    NOT?: TailoringProgressWhereInput | TailoringProgressWhereInput[]
    id?: StringFilter<"TailoringProgress"> | string
    userId?: StringFilter<"TailoringProgress"> | string
    resumeId?: StringFilter<"TailoringProgress"> | string
    status?: StringFilter<"TailoringProgress"> | string
    progress?: IntFilter<"TailoringProgress"> | number
    currentAttempt?: IntNullableFilter<"TailoringProgress"> | number | null
    maxAttempts?: IntNullableFilter<"TailoringProgress"> | number | null
    createdAt?: DateTimeFilter<"TailoringProgress"> | Date | string
    updatedAt?: DateTimeFilter<"TailoringProgress"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type TailoringProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentAttempt?: SortOrderInput | SortOrder
    maxAttempts?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type TailoringProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    resumeId_userId?: TailoringProgressResumeId_userIdCompoundUniqueInput
    AND?: TailoringProgressWhereInput | TailoringProgressWhereInput[]
    OR?: TailoringProgressWhereInput[]
    NOT?: TailoringProgressWhereInput | TailoringProgressWhereInput[]
    userId?: StringFilter<"TailoringProgress"> | string
    resumeId?: StringFilter<"TailoringProgress"> | string
    status?: StringFilter<"TailoringProgress"> | string
    progress?: IntFilter<"TailoringProgress"> | number
    currentAttempt?: IntNullableFilter<"TailoringProgress"> | number | null
    maxAttempts?: IntNullableFilter<"TailoringProgress"> | number | null
    createdAt?: DateTimeFilter<"TailoringProgress"> | Date | string
    updatedAt?: DateTimeFilter<"TailoringProgress"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id" | "resumeId_userId">

  export type TailoringProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentAttempt?: SortOrderInput | SortOrder
    maxAttempts?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TailoringProgressCountOrderByAggregateInput
    _avg?: TailoringProgressAvgOrderByAggregateInput
    _max?: TailoringProgressMaxOrderByAggregateInput
    _min?: TailoringProgressMinOrderByAggregateInput
    _sum?: TailoringProgressSumOrderByAggregateInput
  }

  export type TailoringProgressScalarWhereWithAggregatesInput = {
    AND?: TailoringProgressScalarWhereWithAggregatesInput | TailoringProgressScalarWhereWithAggregatesInput[]
    OR?: TailoringProgressScalarWhereWithAggregatesInput[]
    NOT?: TailoringProgressScalarWhereWithAggregatesInput | TailoringProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TailoringProgress"> | string
    userId?: StringWithAggregatesFilter<"TailoringProgress"> | string
    resumeId?: StringWithAggregatesFilter<"TailoringProgress"> | string
    status?: StringWithAggregatesFilter<"TailoringProgress"> | string
    progress?: IntWithAggregatesFilter<"TailoringProgress"> | number
    currentAttempt?: IntNullableWithAggregatesFilter<"TailoringProgress"> | number | null
    maxAttempts?: IntNullableWithAggregatesFilter<"TailoringProgress"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TailoringProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TailoringProgress"> | Date | string
  }

  export type TailoringAttemptWhereInput = {
    AND?: TailoringAttemptWhereInput | TailoringAttemptWhereInput[]
    OR?: TailoringAttemptWhereInput[]
    NOT?: TailoringAttemptWhereInput | TailoringAttemptWhereInput[]
    id?: StringFilter<"TailoringAttempt"> | string
    userId?: StringFilter<"TailoringAttempt"> | string
    resumeId?: StringFilter<"TailoringAttempt"> | string
    attemptNumber?: IntFilter<"TailoringAttempt"> | number
    atsScore?: IntFilter<"TailoringAttempt"> | number
    jdScore?: IntFilter<"TailoringAttempt"> | number
    goldenPassed?: BoolFilter<"TailoringAttempt"> | boolean
    feedback?: StringFilter<"TailoringAttempt"> | string
    suggestions?: StringFilter<"TailoringAttempt"> | string
    atsFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    jdFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    createdAt?: DateTimeFilter<"TailoringAttempt"> | Date | string
    modifiedSectionsSent?: StringNullableFilter<"TailoringAttempt"> | string | null
    modifiedSectionsReceived?: StringNullableFilter<"TailoringAttempt"> | string | null
    promptTokens?: IntNullableFilter<"TailoringAttempt"> | number | null
    goldenRuleFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    iteration?: IntNullableFilter<"TailoringAttempt"> | number | null
    modifiedSections?: StringNullableFilter<"TailoringAttempt"> | string | null
    score?: IntNullableFilter<"TailoringAttempt"> | number | null
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type TailoringAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    attemptNumber?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    feedback?: SortOrder
    suggestions?: SortOrder
    atsFeedback?: SortOrderInput | SortOrder
    jdFeedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    modifiedSectionsSent?: SortOrderInput | SortOrder
    modifiedSectionsReceived?: SortOrderInput | SortOrder
    promptTokens?: SortOrderInput | SortOrder
    goldenRuleFeedback?: SortOrderInput | SortOrder
    iteration?: SortOrderInput | SortOrder
    modifiedSections?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type TailoringAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TailoringAttemptWhereInput | TailoringAttemptWhereInput[]
    OR?: TailoringAttemptWhereInput[]
    NOT?: TailoringAttemptWhereInput | TailoringAttemptWhereInput[]
    userId?: StringFilter<"TailoringAttempt"> | string
    resumeId?: StringFilter<"TailoringAttempt"> | string
    attemptNumber?: IntFilter<"TailoringAttempt"> | number
    atsScore?: IntFilter<"TailoringAttempt"> | number
    jdScore?: IntFilter<"TailoringAttempt"> | number
    goldenPassed?: BoolFilter<"TailoringAttempt"> | boolean
    feedback?: StringFilter<"TailoringAttempt"> | string
    suggestions?: StringFilter<"TailoringAttempt"> | string
    atsFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    jdFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    createdAt?: DateTimeFilter<"TailoringAttempt"> | Date | string
    modifiedSectionsSent?: StringNullableFilter<"TailoringAttempt"> | string | null
    modifiedSectionsReceived?: StringNullableFilter<"TailoringAttempt"> | string | null
    promptTokens?: IntNullableFilter<"TailoringAttempt"> | number | null
    goldenRuleFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    iteration?: IntNullableFilter<"TailoringAttempt"> | number | null
    modifiedSections?: StringNullableFilter<"TailoringAttempt"> | string | null
    score?: IntNullableFilter<"TailoringAttempt"> | number | null
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type TailoringAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    attemptNumber?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    feedback?: SortOrder
    suggestions?: SortOrder
    atsFeedback?: SortOrderInput | SortOrder
    jdFeedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    modifiedSectionsSent?: SortOrderInput | SortOrder
    modifiedSectionsReceived?: SortOrderInput | SortOrder
    promptTokens?: SortOrderInput | SortOrder
    goldenRuleFeedback?: SortOrderInput | SortOrder
    iteration?: SortOrderInput | SortOrder
    modifiedSections?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    _count?: TailoringAttemptCountOrderByAggregateInput
    _avg?: TailoringAttemptAvgOrderByAggregateInput
    _max?: TailoringAttemptMaxOrderByAggregateInput
    _min?: TailoringAttemptMinOrderByAggregateInput
    _sum?: TailoringAttemptSumOrderByAggregateInput
  }

  export type TailoringAttemptScalarWhereWithAggregatesInput = {
    AND?: TailoringAttemptScalarWhereWithAggregatesInput | TailoringAttemptScalarWhereWithAggregatesInput[]
    OR?: TailoringAttemptScalarWhereWithAggregatesInput[]
    NOT?: TailoringAttemptScalarWhereWithAggregatesInput | TailoringAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TailoringAttempt"> | string
    userId?: StringWithAggregatesFilter<"TailoringAttempt"> | string
    resumeId?: StringWithAggregatesFilter<"TailoringAttempt"> | string
    attemptNumber?: IntWithAggregatesFilter<"TailoringAttempt"> | number
    atsScore?: IntWithAggregatesFilter<"TailoringAttempt"> | number
    jdScore?: IntWithAggregatesFilter<"TailoringAttempt"> | number
    goldenPassed?: BoolWithAggregatesFilter<"TailoringAttempt"> | boolean
    feedback?: StringWithAggregatesFilter<"TailoringAttempt"> | string
    suggestions?: StringWithAggregatesFilter<"TailoringAttempt"> | string
    atsFeedback?: StringNullableWithAggregatesFilter<"TailoringAttempt"> | string | null
    jdFeedback?: StringNullableWithAggregatesFilter<"TailoringAttempt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TailoringAttempt"> | Date | string
    modifiedSectionsSent?: StringNullableWithAggregatesFilter<"TailoringAttempt"> | string | null
    modifiedSectionsReceived?: StringNullableWithAggregatesFilter<"TailoringAttempt"> | string | null
    promptTokens?: IntNullableWithAggregatesFilter<"TailoringAttempt"> | number | null
    goldenRuleFeedback?: StringNullableWithAggregatesFilter<"TailoringAttempt"> | string | null
    iteration?: IntNullableWithAggregatesFilter<"TailoringAttempt"> | number | null
    modifiedSections?: StringNullableWithAggregatesFilter<"TailoringAttempt"> | string | null
    score?: IntNullableWithAggregatesFilter<"TailoringAttempt"> | number | null
  }

  export type ResumeFeedbackWhereInput = {
    AND?: ResumeFeedbackWhereInput | ResumeFeedbackWhereInput[]
    OR?: ResumeFeedbackWhereInput[]
    NOT?: ResumeFeedbackWhereInput | ResumeFeedbackWhereInput[]
    id?: StringFilter<"ResumeFeedback"> | string
    userId?: StringFilter<"ResumeFeedback"> | string
    resumeId?: StringFilter<"ResumeFeedback"> | string
    feedbackType?: StringFilter<"ResumeFeedback"> | string
    feedbackPoints?: StringNullableListFilter<"ResumeFeedback">
    sourceVersion?: IntNullableFilter<"ResumeFeedback"> | number | null
    createdAt?: DateTimeFilter<"ResumeFeedback"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ResumeFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    feedbackType?: SortOrder
    feedbackPoints?: SortOrder
    sourceVersion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type ResumeFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResumeFeedbackWhereInput | ResumeFeedbackWhereInput[]
    OR?: ResumeFeedbackWhereInput[]
    NOT?: ResumeFeedbackWhereInput | ResumeFeedbackWhereInput[]
    userId?: StringFilter<"ResumeFeedback"> | string
    resumeId?: StringFilter<"ResumeFeedback"> | string
    feedbackType?: StringFilter<"ResumeFeedback"> | string
    feedbackPoints?: StringNullableListFilter<"ResumeFeedback">
    sourceVersion?: IntNullableFilter<"ResumeFeedback"> | number | null
    createdAt?: DateTimeFilter<"ResumeFeedback"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type ResumeFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    feedbackType?: SortOrder
    feedbackPoints?: SortOrder
    sourceVersion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ResumeFeedbackCountOrderByAggregateInput
    _avg?: ResumeFeedbackAvgOrderByAggregateInput
    _max?: ResumeFeedbackMaxOrderByAggregateInput
    _min?: ResumeFeedbackMinOrderByAggregateInput
    _sum?: ResumeFeedbackSumOrderByAggregateInput
  }

  export type ResumeFeedbackScalarWhereWithAggregatesInput = {
    AND?: ResumeFeedbackScalarWhereWithAggregatesInput | ResumeFeedbackScalarWhereWithAggregatesInput[]
    OR?: ResumeFeedbackScalarWhereWithAggregatesInput[]
    NOT?: ResumeFeedbackScalarWhereWithAggregatesInput | ResumeFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResumeFeedback"> | string
    userId?: StringWithAggregatesFilter<"ResumeFeedback"> | string
    resumeId?: StringWithAggregatesFilter<"ResumeFeedback"> | string
    feedbackType?: StringWithAggregatesFilter<"ResumeFeedback"> | string
    feedbackPoints?: StringNullableListFilter<"ResumeFeedback">
    sourceVersion?: IntNullableWithAggregatesFilter<"ResumeFeedback"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ResumeFeedback"> | Date | string
  }

  export type ManualEditWhereInput = {
    AND?: ManualEditWhereInput | ManualEditWhereInput[]
    OR?: ManualEditWhereInput[]
    NOT?: ManualEditWhereInput | ManualEditWhereInput[]
    id?: StringFilter<"ManualEdit"> | string
    userId?: StringFilter<"ManualEdit"> | string
    resumeId?: StringFilter<"ManualEdit"> | string
    editedText?: StringFilter<"ManualEdit"> | string
    createdAt?: DateTimeFilter<"ManualEdit"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ManualEditOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    editedText?: SortOrder
    createdAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type ManualEditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManualEditWhereInput | ManualEditWhereInput[]
    OR?: ManualEditWhereInput[]
    NOT?: ManualEditWhereInput | ManualEditWhereInput[]
    userId?: StringFilter<"ManualEdit"> | string
    resumeId?: StringFilter<"ManualEdit"> | string
    editedText?: StringFilter<"ManualEdit"> | string
    createdAt?: DateTimeFilter<"ManualEdit"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type ManualEditOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    editedText?: SortOrder
    createdAt?: SortOrder
    _count?: ManualEditCountOrderByAggregateInput
    _max?: ManualEditMaxOrderByAggregateInput
    _min?: ManualEditMinOrderByAggregateInput
  }

  export type ManualEditScalarWhereWithAggregatesInput = {
    AND?: ManualEditScalarWhereWithAggregatesInput | ManualEditScalarWhereWithAggregatesInput[]
    OR?: ManualEditScalarWhereWithAggregatesInput[]
    NOT?: ManualEditScalarWhereWithAggregatesInput | ManualEditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManualEdit"> | string
    userId?: StringWithAggregatesFilter<"ManualEdit"> | string
    resumeId?: StringWithAggregatesFilter<"ManualEdit"> | string
    editedText?: StringWithAggregatesFilter<"ManualEdit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ManualEdit"> | Date | string
  }

  export type ManualScoringWhereInput = {
    AND?: ManualScoringWhereInput | ManualScoringWhereInput[]
    OR?: ManualScoringWhereInput[]
    NOT?: ManualScoringWhereInput | ManualScoringWhereInput[]
    id?: StringFilter<"ManualScoring"> | string
    userId?: StringFilter<"ManualScoring"> | string
    resumeId?: StringFilter<"ManualScoring"> | string
    atsScore?: IntFilter<"ManualScoring"> | number
    jdScore?: IntFilter<"ManualScoring"> | number
    atsFeedback?: StringNullableFilter<"ManualScoring"> | string | null
    jdFeedback?: StringNullableFilter<"ManualScoring"> | string | null
    createdAt?: DateTimeFilter<"ManualScoring"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ManualScoringOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    atsFeedback?: SortOrderInput | SortOrder
    jdFeedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
  }

  export type ManualScoringWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManualScoringWhereInput | ManualScoringWhereInput[]
    OR?: ManualScoringWhereInput[]
    NOT?: ManualScoringWhereInput | ManualScoringWhereInput[]
    userId?: StringFilter<"ManualScoring"> | string
    resumeId?: StringFilter<"ManualScoring"> | string
    atsScore?: IntFilter<"ManualScoring"> | number
    jdScore?: IntFilter<"ManualScoring"> | number
    atsFeedback?: StringNullableFilter<"ManualScoring"> | string | null
    jdFeedback?: StringNullableFilter<"ManualScoring"> | string | null
    createdAt?: DateTimeFilter<"ManualScoring"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type ManualScoringOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    atsFeedback?: SortOrderInput | SortOrder
    jdFeedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ManualScoringCountOrderByAggregateInput
    _avg?: ManualScoringAvgOrderByAggregateInput
    _max?: ManualScoringMaxOrderByAggregateInput
    _min?: ManualScoringMinOrderByAggregateInput
    _sum?: ManualScoringSumOrderByAggregateInput
  }

  export type ManualScoringScalarWhereWithAggregatesInput = {
    AND?: ManualScoringScalarWhereWithAggregatesInput | ManualScoringScalarWhereWithAggregatesInput[]
    OR?: ManualScoringScalarWhereWithAggregatesInput[]
    NOT?: ManualScoringScalarWhereWithAggregatesInput | ManualScoringScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManualScoring"> | string
    userId?: StringWithAggregatesFilter<"ManualScoring"> | string
    resumeId?: StringWithAggregatesFilter<"ManualScoring"> | string
    atsScore?: IntWithAggregatesFilter<"ManualScoring"> | number
    jdScore?: IntWithAggregatesFilter<"ManualScoring"> | number
    atsFeedback?: StringNullableWithAggregatesFilter<"ManualScoring"> | string | null
    jdFeedback?: StringNullableWithAggregatesFilter<"ManualScoring"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ManualScoring"> | Date | string
  }

  export type CoverLetterWhereInput = {
    AND?: CoverLetterWhereInput | CoverLetterWhereInput[]
    OR?: CoverLetterWhereInput[]
    NOT?: CoverLetterWhereInput | CoverLetterWhereInput[]
    id?: StringFilter<"CoverLetter"> | string
    userId?: StringFilter<"CoverLetter"> | string
    resumeId?: StringFilter<"CoverLetter"> | string
    jobDescription?: StringFilter<"CoverLetter"> | string
    content?: StringFilter<"CoverLetter"> | string
    tone?: StringFilter<"CoverLetter"> | string
    atsScore?: IntNullableFilter<"CoverLetter"> | number | null
    jdScore?: IntNullableFilter<"CoverLetter"> | number | null
    version?: IntFilter<"CoverLetter"> | number
    createdAt?: DateTimeFilter<"CoverLetter"> | Date | string
    updatedAt?: DateTimeFilter<"CoverLetter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type CoverLetterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    jobDescription?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    atsScore?: SortOrderInput | SortOrder
    jdScore?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
  }

  export type CoverLetterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoverLetterWhereInput | CoverLetterWhereInput[]
    OR?: CoverLetterWhereInput[]
    NOT?: CoverLetterWhereInput | CoverLetterWhereInput[]
    userId?: StringFilter<"CoverLetter"> | string
    resumeId?: StringFilter<"CoverLetter"> | string
    jobDescription?: StringFilter<"CoverLetter"> | string
    content?: StringFilter<"CoverLetter"> | string
    tone?: StringFilter<"CoverLetter"> | string
    atsScore?: IntNullableFilter<"CoverLetter"> | number | null
    jdScore?: IntNullableFilter<"CoverLetter"> | number | null
    version?: IntFilter<"CoverLetter"> | number
    createdAt?: DateTimeFilter<"CoverLetter"> | Date | string
    updatedAt?: DateTimeFilter<"CoverLetter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type CoverLetterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    jobDescription?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    atsScore?: SortOrderInput | SortOrder
    jdScore?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoverLetterCountOrderByAggregateInput
    _avg?: CoverLetterAvgOrderByAggregateInput
    _max?: CoverLetterMaxOrderByAggregateInput
    _min?: CoverLetterMinOrderByAggregateInput
    _sum?: CoverLetterSumOrderByAggregateInput
  }

  export type CoverLetterScalarWhereWithAggregatesInput = {
    AND?: CoverLetterScalarWhereWithAggregatesInput | CoverLetterScalarWhereWithAggregatesInput[]
    OR?: CoverLetterScalarWhereWithAggregatesInput[]
    NOT?: CoverLetterScalarWhereWithAggregatesInput | CoverLetterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoverLetter"> | string
    userId?: StringWithAggregatesFilter<"CoverLetter"> | string
    resumeId?: StringWithAggregatesFilter<"CoverLetter"> | string
    jobDescription?: StringWithAggregatesFilter<"CoverLetter"> | string
    content?: StringWithAggregatesFilter<"CoverLetter"> | string
    tone?: StringWithAggregatesFilter<"CoverLetter"> | string
    atsScore?: IntNullableWithAggregatesFilter<"CoverLetter"> | number | null
    jdScore?: IntNullableWithAggregatesFilter<"CoverLetter"> | number | null
    version?: IntWithAggregatesFilter<"CoverLetter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CoverLetter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoverLetter"> | Date | string
  }

  export type LinkedInOptimizationWhereInput = {
    AND?: LinkedInOptimizationWhereInput | LinkedInOptimizationWhereInput[]
    OR?: LinkedInOptimizationWhereInput[]
    NOT?: LinkedInOptimizationWhereInput | LinkedInOptimizationWhereInput[]
    id?: StringFilter<"LinkedInOptimization"> | string
    userId?: StringFilter<"LinkedInOptimization"> | string
    jobDescription?: StringFilter<"LinkedInOptimization"> | string
    originalAbout?: StringFilter<"LinkedInOptimization"> | string
    optimizedAbout?: StringFilter<"LinkedInOptimization"> | string
    tone?: StringFilter<"LinkedInOptimization"> | string
    createdAt?: DateTimeFilter<"LinkedInOptimization"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedInOptimization"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LinkedInOptimizationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    originalAbout?: SortOrder
    optimizedAbout?: SortOrder
    tone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LinkedInOptimizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LinkedInOptimizationWhereInput | LinkedInOptimizationWhereInput[]
    OR?: LinkedInOptimizationWhereInput[]
    NOT?: LinkedInOptimizationWhereInput | LinkedInOptimizationWhereInput[]
    userId?: StringFilter<"LinkedInOptimization"> | string
    jobDescription?: StringFilter<"LinkedInOptimization"> | string
    originalAbout?: StringFilter<"LinkedInOptimization"> | string
    optimizedAbout?: StringFilter<"LinkedInOptimization"> | string
    tone?: StringFilter<"LinkedInOptimization"> | string
    createdAt?: DateTimeFilter<"LinkedInOptimization"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedInOptimization"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LinkedInOptimizationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    originalAbout?: SortOrder
    optimizedAbout?: SortOrder
    tone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LinkedInOptimizationCountOrderByAggregateInput
    _max?: LinkedInOptimizationMaxOrderByAggregateInput
    _min?: LinkedInOptimizationMinOrderByAggregateInput
  }

  export type LinkedInOptimizationScalarWhereWithAggregatesInput = {
    AND?: LinkedInOptimizationScalarWhereWithAggregatesInput | LinkedInOptimizationScalarWhereWithAggregatesInput[]
    OR?: LinkedInOptimizationScalarWhereWithAggregatesInput[]
    NOT?: LinkedInOptimizationScalarWhereWithAggregatesInput | LinkedInOptimizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LinkedInOptimization"> | string
    userId?: StringWithAggregatesFilter<"LinkedInOptimization"> | string
    jobDescription?: StringWithAggregatesFilter<"LinkedInOptimization"> | string
    originalAbout?: StringWithAggregatesFilter<"LinkedInOptimization"> | string
    optimizedAbout?: StringWithAggregatesFilter<"LinkedInOptimization"> | string
    tone?: StringWithAggregatesFilter<"LinkedInOptimization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LinkedInOptimization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LinkedInOptimization"> | Date | string
  }

  export type InterviewSessionWhereInput = {
    AND?: InterviewSessionWhereInput | InterviewSessionWhereInput[]
    OR?: InterviewSessionWhereInput[]
    NOT?: InterviewSessionWhereInput | InterviewSessionWhereInput[]
    id?: StringFilter<"InterviewSession"> | string
    userId?: StringFilter<"InterviewSession"> | string
    jobDescription?: StringFilter<"InterviewSession"> | string
    selectedTypes?: StringNullableListFilter<"InterviewSession">
    questions?: JsonFilter<"InterviewSession">
    answers?: JsonNullableFilter<"InterviewSession">
    needsReview?: JsonNullableFilter<"InterviewSession">
    createdAt?: DateTimeFilter<"InterviewSession"> | Date | string
    updatedAt?: DateTimeFilter<"InterviewSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InterviewSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    selectedTypes?: SortOrder
    questions?: SortOrder
    answers?: SortOrderInput | SortOrder
    needsReview?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InterviewSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterviewSessionWhereInput | InterviewSessionWhereInput[]
    OR?: InterviewSessionWhereInput[]
    NOT?: InterviewSessionWhereInput | InterviewSessionWhereInput[]
    userId?: StringFilter<"InterviewSession"> | string
    jobDescription?: StringFilter<"InterviewSession"> | string
    selectedTypes?: StringNullableListFilter<"InterviewSession">
    questions?: JsonFilter<"InterviewSession">
    answers?: JsonNullableFilter<"InterviewSession">
    needsReview?: JsonNullableFilter<"InterviewSession">
    createdAt?: DateTimeFilter<"InterviewSession"> | Date | string
    updatedAt?: DateTimeFilter<"InterviewSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InterviewSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    selectedTypes?: SortOrder
    questions?: SortOrder
    answers?: SortOrderInput | SortOrder
    needsReview?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterviewSessionCountOrderByAggregateInput
    _max?: InterviewSessionMaxOrderByAggregateInput
    _min?: InterviewSessionMinOrderByAggregateInput
  }

  export type InterviewSessionScalarWhereWithAggregatesInput = {
    AND?: InterviewSessionScalarWhereWithAggregatesInput | InterviewSessionScalarWhereWithAggregatesInput[]
    OR?: InterviewSessionScalarWhereWithAggregatesInput[]
    NOT?: InterviewSessionScalarWhereWithAggregatesInput | InterviewSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewSession"> | string
    userId?: StringWithAggregatesFilter<"InterviewSession"> | string
    jobDescription?: StringWithAggregatesFilter<"InterviewSession"> | string
    selectedTypes?: StringNullableListFilter<"InterviewSession">
    questions?: JsonWithAggregatesFilter<"InterviewSession">
    answers?: JsonNullableWithAggregatesFilter<"InterviewSession">
    needsReview?: JsonNullableWithAggregatesFilter<"InterviewSession">
    createdAt?: DateTimeWithAggregatesFilter<"InterviewSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InterviewSession"> | Date | string
  }

  export type ResumeExportWhereInput = {
    AND?: ResumeExportWhereInput | ResumeExportWhereInput[]
    OR?: ResumeExportWhereInput[]
    NOT?: ResumeExportWhereInput | ResumeExportWhereInput[]
    id?: StringFilter<"ResumeExport"> | string
    userId?: StringFilter<"ResumeExport"> | string
    resumeId?: StringFilter<"ResumeExport"> | string
    templateId?: StringFilter<"ResumeExport"> | string
    format?: StringFilter<"ResumeExport"> | string
    createdAt?: DateTimeFilter<"ResumeExport"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ResumeExportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    templateId?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
  }

  export type ResumeExportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResumeExportWhereInput | ResumeExportWhereInput[]
    OR?: ResumeExportWhereInput[]
    NOT?: ResumeExportWhereInput | ResumeExportWhereInput[]
    userId?: StringFilter<"ResumeExport"> | string
    resumeId?: StringFilter<"ResumeExport"> | string
    templateId?: StringFilter<"ResumeExport"> | string
    format?: StringFilter<"ResumeExport"> | string
    createdAt?: DateTimeFilter<"ResumeExport"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "id">

  export type ResumeExportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    templateId?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    _count?: ResumeExportCountOrderByAggregateInput
    _max?: ResumeExportMaxOrderByAggregateInput
    _min?: ResumeExportMinOrderByAggregateInput
  }

  export type ResumeExportScalarWhereWithAggregatesInput = {
    AND?: ResumeExportScalarWhereWithAggregatesInput | ResumeExportScalarWhereWithAggregatesInput[]
    OR?: ResumeExportScalarWhereWithAggregatesInput[]
    NOT?: ResumeExportScalarWhereWithAggregatesInput | ResumeExportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResumeExport"> | string
    userId?: StringWithAggregatesFilter<"ResumeExport"> | string
    resumeId?: StringWithAggregatesFilter<"ResumeExport"> | string
    templateId?: StringWithAggregatesFilter<"ResumeExport"> | string
    format?: StringWithAggregatesFilter<"ResumeExport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ResumeExport"> | Date | string
  }

  export type JobDescriptionIntelligenceWhereInput = {
    AND?: JobDescriptionIntelligenceWhereInput | JobDescriptionIntelligenceWhereInput[]
    OR?: JobDescriptionIntelligenceWhereInput[]
    NOT?: JobDescriptionIntelligenceWhereInput | JobDescriptionIntelligenceWhereInput[]
    id?: StringFilter<"JobDescriptionIntelligence"> | string
    userId?: StringFilter<"JobDescriptionIntelligence"> | string
    resumeId?: StringNullableFilter<"JobDescriptionIntelligence"> | string | null
    role?: StringFilter<"JobDescriptionIntelligence"> | string
    seniority?: StringFilter<"JobDescriptionIntelligence"> | string
    keywords?: StringNullableListFilter<"JobDescriptionIntelligence">
    responsibilities?: StringNullableListFilter<"JobDescriptionIntelligence">
    qualifications?: StringNullableListFilter<"JobDescriptionIntelligence">
    categories?: JsonFilter<"JobDescriptionIntelligence">
    createdAt?: DateTimeFilter<"JobDescriptionIntelligence"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JobDescriptionIntelligenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrderInput | SortOrder
    role?: SortOrder
    seniority?: SortOrder
    keywords?: SortOrder
    responsibilities?: SortOrder
    qualifications?: SortOrder
    categories?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type JobDescriptionIntelligenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobDescriptionIntelligenceWhereInput | JobDescriptionIntelligenceWhereInput[]
    OR?: JobDescriptionIntelligenceWhereInput[]
    NOT?: JobDescriptionIntelligenceWhereInput | JobDescriptionIntelligenceWhereInput[]
    userId?: StringFilter<"JobDescriptionIntelligence"> | string
    resumeId?: StringNullableFilter<"JobDescriptionIntelligence"> | string | null
    role?: StringFilter<"JobDescriptionIntelligence"> | string
    seniority?: StringFilter<"JobDescriptionIntelligence"> | string
    keywords?: StringNullableListFilter<"JobDescriptionIntelligence">
    responsibilities?: StringNullableListFilter<"JobDescriptionIntelligence">
    qualifications?: StringNullableListFilter<"JobDescriptionIntelligence">
    categories?: JsonFilter<"JobDescriptionIntelligence">
    createdAt?: DateTimeFilter<"JobDescriptionIntelligence"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type JobDescriptionIntelligenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrderInput | SortOrder
    role?: SortOrder
    seniority?: SortOrder
    keywords?: SortOrder
    responsibilities?: SortOrder
    qualifications?: SortOrder
    categories?: SortOrder
    createdAt?: SortOrder
    _count?: JobDescriptionIntelligenceCountOrderByAggregateInput
    _max?: JobDescriptionIntelligenceMaxOrderByAggregateInput
    _min?: JobDescriptionIntelligenceMinOrderByAggregateInput
  }

  export type JobDescriptionIntelligenceScalarWhereWithAggregatesInput = {
    AND?: JobDescriptionIntelligenceScalarWhereWithAggregatesInput | JobDescriptionIntelligenceScalarWhereWithAggregatesInput[]
    OR?: JobDescriptionIntelligenceScalarWhereWithAggregatesInput[]
    NOT?: JobDescriptionIntelligenceScalarWhereWithAggregatesInput | JobDescriptionIntelligenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobDescriptionIntelligence"> | string
    userId?: StringWithAggregatesFilter<"JobDescriptionIntelligence"> | string
    resumeId?: StringNullableWithAggregatesFilter<"JobDescriptionIntelligence"> | string | null
    role?: StringWithAggregatesFilter<"JobDescriptionIntelligence"> | string
    seniority?: StringWithAggregatesFilter<"JobDescriptionIntelligence"> | string
    keywords?: StringNullableListFilter<"JobDescriptionIntelligence">
    responsibilities?: StringNullableListFilter<"JobDescriptionIntelligence">
    qualifications?: StringNullableListFilter<"JobDescriptionIntelligence">
    categories?: JsonWithAggregatesFilter<"JobDescriptionIntelligence">
    createdAt?: DateTimeWithAggregatesFilter<"JobDescriptionIntelligence"> | Date | string
  }

  export type ResumeSectionRationaleWhereInput = {
    AND?: ResumeSectionRationaleWhereInput | ResumeSectionRationaleWhereInput[]
    OR?: ResumeSectionRationaleWhereInput[]
    NOT?: ResumeSectionRationaleWhereInput | ResumeSectionRationaleWhereInput[]
    id?: StringFilter<"ResumeSectionRationale"> | string
    resumeId?: StringFilter<"ResumeSectionRationale"> | string
    userId?: StringFilter<"ResumeSectionRationale"> | string
    sectionName?: StringFilter<"ResumeSectionRationale"> | string
    rationale?: StringFilter<"ResumeSectionRationale"> | string
    createdAt?: DateTimeFilter<"ResumeSectionRationale"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ResumeSectionRationaleOrderByWithRelationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    sectionName?: SortOrder
    rationale?: SortOrder
    createdAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ResumeSectionRationaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    resumeId_sectionName?: ResumeSectionRationaleResumeIdSectionNameCompoundUniqueInput
    AND?: ResumeSectionRationaleWhereInput | ResumeSectionRationaleWhereInput[]
    OR?: ResumeSectionRationaleWhereInput[]
    NOT?: ResumeSectionRationaleWhereInput | ResumeSectionRationaleWhereInput[]
    resumeId?: StringFilter<"ResumeSectionRationale"> | string
    userId?: StringFilter<"ResumeSectionRationale"> | string
    sectionName?: StringFilter<"ResumeSectionRationale"> | string
    rationale?: StringFilter<"ResumeSectionRationale"> | string
    createdAt?: DateTimeFilter<"ResumeSectionRationale"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "resumeId_sectionName">

  export type ResumeSectionRationaleOrderByWithAggregationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    sectionName?: SortOrder
    rationale?: SortOrder
    createdAt?: SortOrder
    _count?: ResumeSectionRationaleCountOrderByAggregateInput
    _max?: ResumeSectionRationaleMaxOrderByAggregateInput
    _min?: ResumeSectionRationaleMinOrderByAggregateInput
  }

  export type ResumeSectionRationaleScalarWhereWithAggregatesInput = {
    AND?: ResumeSectionRationaleScalarWhereWithAggregatesInput | ResumeSectionRationaleScalarWhereWithAggregatesInput[]
    OR?: ResumeSectionRationaleScalarWhereWithAggregatesInput[]
    NOT?: ResumeSectionRationaleScalarWhereWithAggregatesInput | ResumeSectionRationaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResumeSectionRationale"> | string
    resumeId?: StringWithAggregatesFilter<"ResumeSectionRationale"> | string
    userId?: StringWithAggregatesFilter<"ResumeSectionRationale"> | string
    sectionName?: StringWithAggregatesFilter<"ResumeSectionRationale"> | string
    rationale?: StringWithAggregatesFilter<"ResumeSectionRationale"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ResumeSectionRationale"> | Date | string
  }

  export type ContactSubmissionWhereInput = {
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    id?: StringFilter<"ContactSubmission"> | string
    name?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    subject?: StringFilter<"ContactSubmission"> | string
    message?: StringFilter<"ContactSubmission"> | string
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
    isRead?: BoolFilter<"ContactSubmission"> | boolean
  }

  export type ContactSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type ContactSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    name?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    subject?: StringFilter<"ContactSubmission"> | string
    message?: StringFilter<"ContactSubmission"> | string
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
    isRead?: BoolFilter<"ContactSubmission"> | boolean
  }, "id">

  export type ContactSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    _count?: ContactSubmissionCountOrderByAggregateInput
    _max?: ContactSubmissionMaxOrderByAggregateInput
    _min?: ContactSubmissionMinOrderByAggregateInput
  }

  export type ContactSubmissionScalarWhereWithAggregatesInput = {
    AND?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    OR?: ContactSubmissionScalarWhereWithAggregatesInput[]
    NOT?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactSubmission"> | string
    name?: StringWithAggregatesFilter<"ContactSubmission"> | string
    email?: StringWithAggregatesFilter<"ContactSubmission"> | string
    subject?: StringWithAggregatesFilter<"ContactSubmission"> | string
    message?: StringWithAggregatesFilter<"ContactSubmission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactSubmission"> | Date | string
    isRead?: BoolWithAggregatesFilter<"ContactSubmission"> | boolean
  }

  export type UserCreateInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeCreateInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateManyInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeEventCreateInput = {
    id?: string
    userId: string
    resumeId: string
    eventType: string
    resumeText?: string | null
    jobDescription?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ResumeEventUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    eventType: string
    resumeText?: string | null
    jobDescription?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ResumeEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeEventCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    eventType: string
    resumeText?: string | null
    jobDescription?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ResumeEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    userId?: string | null
    eventType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringAnalyticsCreateInput = {
    id?: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
    user: UserCreateNestedOneWithoutAnalyticsInput
    resume: ResumeCreateNestedOneWithoutAnalyticsInput
  }

  export type TailoringAnalyticsUncheckedCreateInput = {
    id?: string
    resumeId: string
    userId: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
  }

  export type TailoringAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAnalyticsNestedInput
    resume?: ResumeUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type TailoringAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TailoringAnalyticsCreateManyInput = {
    id?: string
    resumeId: string
    userId: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
  }

  export type TailoringAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TailoringAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScrubbedResumeCreateInput = {
    id?: string
    cleanText: string
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutScrubbedResumeInput
  }

  export type ScrubbedResumeUncheckedCreateInput = {
    id?: string
    resumeId: string
    cleanText: string
    createdAt?: Date | string
  }

  export type ScrubbedResumeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cleanText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutScrubbedResumeNestedInput
  }

  export type ScrubbedResumeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    cleanText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScrubbedResumeCreateManyInput = {
    id?: string
    resumeId: string
    cleanText: string
    createdAt?: Date | string
  }

  export type ScrubbedResumeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cleanText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScrubbedResumeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    cleanText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptArchiveCreateInput = {
    id?: string
    content: string
    response: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutPromptArchivesInput
  }

  export type PromptArchiveUncheckedCreateInput = {
    id?: string
    resumeId: string
    content: string
    response: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PromptArchiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutPromptArchivesNestedInput
  }

  export type PromptArchiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptArchiveCreateManyInput = {
    id?: string
    resumeId: string
    content: string
    response: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PromptArchiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptArchiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeInteractionCreateInput = {
    id?: string
    action: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInteractionsInput
    resume: ResumeCreateNestedOneWithoutInteractionsInput
  }

  export type ResumeInteractionUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    action: string
    createdAt?: Date | string
  }

  export type ResumeInteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInteractionsNestedInput
    resume?: ResumeUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type ResumeInteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeInteractionCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    action: string
    createdAt?: Date | string
  }

  export type ResumeInteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeInteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeTagCreateInput = {
    id?: string
    tag: string
    user: UserCreateNestedOneWithoutResumeTagInput
    resume: ResumeCreateNestedOneWithoutTagsInput
  }

  export type ResumeTagUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    tag: string
  }

  export type ResumeTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutResumeTagNestedInput
    resume?: ResumeUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ResumeTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeTagCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    tag: string
  }

  export type ResumeTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeMetadataCreateInput = {
    id?: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutResumeMetadataInput
    resume: ResumeCreateNestedOneWithoutMetadataInput
  }

  export type ResumeMetadataUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt?: Date | string
  }

  export type ResumeMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumeMetadataNestedInput
    resume?: ResumeUpdateOneRequiredWithoutMetadataNestedInput
  }

  export type ResumeMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeMetadataCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt?: Date | string
  }

  export type ResumeMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringPromptCreateInput = {
    id?: string
    tailoringMode: string
    prompt: string
    attempt: number
    version: number
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutTailoringPromptsInput
  }

  export type TailoringPromptUncheckedCreateInput = {
    id?: string
    resumeId: string
    tailoringMode: string
    prompt: string
    attempt: number
    version: number
    createdAt?: Date | string
  }

  export type TailoringPromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    attempt?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutTailoringPromptsNestedInput
  }

  export type TailoringPromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    attempt?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringPromptCreateManyInput = {
    id?: string
    resumeId: string
    tailoringMode: string
    prompt: string
    attempt: number
    version: number
    createdAt?: Date | string
  }

  export type TailoringPromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    attempt?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringPromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    attempt?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringProgressCreateInput = {
    id?: string
    userId: string
    status: string
    progress: number
    currentAttempt?: number | null
    maxAttempts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resume: ResumeCreateNestedOneWithoutTailoringProgressInput
  }

  export type TailoringProgressUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    status: string
    progress: number
    currentAttempt?: number | null
    maxAttempts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TailoringProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    currentAttempt?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutTailoringProgressNestedInput
  }

  export type TailoringProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    currentAttempt?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringProgressCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    status: string
    progress: number
    currentAttempt?: number | null
    maxAttempts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TailoringProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    currentAttempt?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    currentAttempt?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringAttemptCreateInput = {
    id?: string
    userId: string
    attemptNumber: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    feedback: string
    suggestions: string
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
    modifiedSectionsSent?: string | null
    modifiedSectionsReceived?: string | null
    promptTokens?: number | null
    goldenRuleFeedback?: string | null
    iteration?: number | null
    modifiedSections?: string | null
    score?: number | null
    resume: ResumeCreateNestedOneWithoutTailoringAttemptsInput
  }

  export type TailoringAttemptUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    attemptNumber: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    feedback: string
    suggestions: string
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
    modifiedSectionsSent?: string | null
    modifiedSectionsReceived?: string | null
    promptTokens?: number | null
    goldenRuleFeedback?: string | null
    iteration?: number | null
    modifiedSections?: string | null
    score?: number | null
  }

  export type TailoringAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: StringFieldUpdateOperationsInput | string
    suggestions?: StringFieldUpdateOperationsInput | string
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSectionsSent?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedSectionsReceived?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    goldenRuleFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    iteration?: NullableIntFieldUpdateOperationsInput | number | null
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    resume?: ResumeUpdateOneRequiredWithoutTailoringAttemptsNestedInput
  }

  export type TailoringAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: StringFieldUpdateOperationsInput | string
    suggestions?: StringFieldUpdateOperationsInput | string
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSectionsSent?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedSectionsReceived?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    goldenRuleFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    iteration?: NullableIntFieldUpdateOperationsInput | number | null
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TailoringAttemptCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    attemptNumber: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    feedback: string
    suggestions: string
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
    modifiedSectionsSent?: string | null
    modifiedSectionsReceived?: string | null
    promptTokens?: number | null
    goldenRuleFeedback?: string | null
    iteration?: number | null
    modifiedSections?: string | null
    score?: number | null
  }

  export type TailoringAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: StringFieldUpdateOperationsInput | string
    suggestions?: StringFieldUpdateOperationsInput | string
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSectionsSent?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedSectionsReceived?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    goldenRuleFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    iteration?: NullableIntFieldUpdateOperationsInput | number | null
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TailoringAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: StringFieldUpdateOperationsInput | string
    suggestions?: StringFieldUpdateOperationsInput | string
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSectionsSent?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedSectionsReceived?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    goldenRuleFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    iteration?: NullableIntFieldUpdateOperationsInput | number | null
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ResumeFeedbackCreateInput = {
    id?: string
    userId: string
    feedbackType: string
    feedbackPoints?: ResumeFeedbackCreatefeedbackPointsInput | string[]
    sourceVersion?: number | null
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutResumeFeedbackInput
  }

  export type ResumeFeedbackUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    feedbackType: string
    feedbackPoints?: ResumeFeedbackCreatefeedbackPointsInput | string[]
    sourceVersion?: number | null
    createdAt?: Date | string
  }

  export type ResumeFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: StringFieldUpdateOperationsInput | string
    feedbackPoints?: ResumeFeedbackUpdatefeedbackPointsInput | string[]
    sourceVersion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutResumeFeedbackNestedInput
  }

  export type ResumeFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    feedbackType?: StringFieldUpdateOperationsInput | string
    feedbackPoints?: ResumeFeedbackUpdatefeedbackPointsInput | string[]
    sourceVersion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeFeedbackCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    feedbackType: string
    feedbackPoints?: ResumeFeedbackCreatefeedbackPointsInput | string[]
    sourceVersion?: number | null
    createdAt?: Date | string
  }

  export type ResumeFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: StringFieldUpdateOperationsInput | string
    feedbackPoints?: ResumeFeedbackUpdatefeedbackPointsInput | string[]
    sourceVersion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    feedbackType?: StringFieldUpdateOperationsInput | string
    feedbackPoints?: ResumeFeedbackUpdatefeedbackPointsInput | string[]
    sourceVersion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualEditCreateInput = {
    id?: string
    userId: string
    editedText: string
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutManualEditsInput
  }

  export type ManualEditUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    editedText: string
    createdAt?: Date | string
  }

  export type ManualEditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    editedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutManualEditsNestedInput
  }

  export type ManualEditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    editedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualEditCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    editedText: string
    createdAt?: Date | string
  }

  export type ManualEditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    editedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualEditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    editedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualScoringCreateInput = {
    id?: string
    userId: string
    atsScore: number
    jdScore: number
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutManualScoringsInput
  }

  export type ManualScoringUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    atsScore: number
    jdScore: number
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
  }

  export type ManualScoringUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutManualScoringsNestedInput
  }

  export type ManualScoringUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualScoringCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    atsScore: number
    jdScore: number
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
  }

  export type ManualScoringUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualScoringUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverLetterCreateInput = {
    id?: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoverLettersInput
    resume: ResumeCreateNestedOneWithoutCoverLettersInput
  }

  export type CoverLetterUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoverLetterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoverLettersNestedInput
    resume?: ResumeUpdateOneRequiredWithoutCoverLettersNestedInput
  }

  export type CoverLetterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverLetterCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoverLetterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverLetterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedInOptimizationCreateInput = {
    id?: string
    jobDescription: string
    originalAbout: string
    optimizedAbout: string
    tone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinkedInOptimizationsInput
  }

  export type LinkedInOptimizationUncheckedCreateInput = {
    id?: string
    userId: string
    jobDescription: string
    originalAbout: string
    optimizedAbout: string
    tone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedInOptimizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    originalAbout?: StringFieldUpdateOperationsInput | string
    optimizedAbout?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinkedInOptimizationsNestedInput
  }

  export type LinkedInOptimizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    originalAbout?: StringFieldUpdateOperationsInput | string
    optimizedAbout?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedInOptimizationCreateManyInput = {
    id?: string
    userId: string
    jobDescription: string
    originalAbout: string
    optimizedAbout: string
    tone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedInOptimizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    originalAbout?: StringFieldUpdateOperationsInput | string
    optimizedAbout?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedInOptimizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    originalAbout?: StringFieldUpdateOperationsInput | string
    optimizedAbout?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionCreateInput = {
    id?: string
    jobDescription: string
    selectedTypes?: InterviewSessionCreateselectedTypesInput | string[]
    questions: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInterviewSessionsInput
  }

  export type InterviewSessionUncheckedCreateInput = {
    id?: string
    userId: string
    jobDescription: string
    selectedTypes?: InterviewSessionCreateselectedTypesInput | string[]
    questions: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    selectedTypes?: InterviewSessionUpdateselectedTypesInput | string[]
    questions?: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterviewSessionsNestedInput
  }

  export type InterviewSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    selectedTypes?: InterviewSessionUpdateselectedTypesInput | string[]
    questions?: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionCreateManyInput = {
    id?: string
    userId: string
    jobDescription: string
    selectedTypes?: InterviewSessionCreateselectedTypesInput | string[]
    questions: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    selectedTypes?: InterviewSessionUpdateselectedTypesInput | string[]
    questions?: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    selectedTypes?: InterviewSessionUpdateselectedTypesInput | string[]
    questions?: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeExportCreateInput = {
    id?: string
    templateId: string
    format: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutResumeExportsInput
    resume: ResumeCreateNestedOneWithoutExportsInput
  }

  export type ResumeExportUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId: string
    templateId: string
    format: string
    createdAt?: Date | string
  }

  export type ResumeExportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumeExportsNestedInput
    resume?: ResumeUpdateOneRequiredWithoutExportsNestedInput
  }

  export type ResumeExportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeExportCreateManyInput = {
    id?: string
    userId: string
    resumeId: string
    templateId: string
    format: string
    createdAt?: Date | string
  }

  export type ResumeExportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeExportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDescriptionIntelligenceCreateInput = {
    id?: string
    resumeId?: string | null
    role: string
    seniority: string
    keywords?: JobDescriptionIntelligenceCreatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceCreateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceCreatequalificationsInput | string[]
    categories: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutJdIntelligenceInput
  }

  export type JobDescriptionIntelligenceUncheckedCreateInput = {
    id?: string
    userId: string
    resumeId?: string | null
    role: string
    seniority: string
    keywords?: JobDescriptionIntelligenceCreatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceCreateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceCreatequalificationsInput | string[]
    categories: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type JobDescriptionIntelligenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seniority?: StringFieldUpdateOperationsInput | string
    keywords?: JobDescriptionIntelligenceUpdatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceUpdateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceUpdatequalificationsInput | string[]
    categories?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJdIntelligenceNestedInput
  }

  export type JobDescriptionIntelligenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seniority?: StringFieldUpdateOperationsInput | string
    keywords?: JobDescriptionIntelligenceUpdatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceUpdateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceUpdatequalificationsInput | string[]
    categories?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDescriptionIntelligenceCreateManyInput = {
    id?: string
    userId: string
    resumeId?: string | null
    role: string
    seniority: string
    keywords?: JobDescriptionIntelligenceCreatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceCreateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceCreatequalificationsInput | string[]
    categories: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type JobDescriptionIntelligenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seniority?: StringFieldUpdateOperationsInput | string
    keywords?: JobDescriptionIntelligenceUpdatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceUpdateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceUpdatequalificationsInput | string[]
    categories?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDescriptionIntelligenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seniority?: StringFieldUpdateOperationsInput | string
    keywords?: JobDescriptionIntelligenceUpdatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceUpdateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceUpdatequalificationsInput | string[]
    categories?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeSectionRationaleCreateInput = {
    id?: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutResumeSectionRationaleInput
    user: UserCreateNestedOneWithoutResumeSectionRationaleInput
  }

  export type ResumeSectionRationaleUncheckedCreateInput = {
    id?: string
    resumeId: string
    userId: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
  }

  export type ResumeSectionRationaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutResumeSectionRationaleNestedInput
    user?: UserUpdateOneRequiredWithoutResumeSectionRationaleNestedInput
  }

  export type ResumeSectionRationaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeSectionRationaleCreateManyInput = {
    id?: string
    resumeId: string
    userId: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
  }

  export type ResumeSectionRationaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeSectionRationaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionCreateInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    isRead?: boolean
  }

  export type ContactSubmissionUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    isRead?: boolean
  }

  export type ContactSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactSubmissionCreateManyInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    isRead?: boolean
  }

  export type ContactSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ResumeListRelationFilter = {
    every?: ResumeWhereInput
    some?: ResumeWhereInput
    none?: ResumeWhereInput
  }

  export type TailoringAnalyticsListRelationFilter = {
    every?: TailoringAnalyticsWhereInput
    some?: TailoringAnalyticsWhereInput
    none?: TailoringAnalyticsWhereInput
  }

  export type ResumeInteractionListRelationFilter = {
    every?: ResumeInteractionWhereInput
    some?: ResumeInteractionWhereInput
    none?: ResumeInteractionWhereInput
  }

  export type CoverLetterListRelationFilter = {
    every?: CoverLetterWhereInput
    some?: CoverLetterWhereInput
    none?: CoverLetterWhereInput
  }

  export type LinkedInOptimizationListRelationFilter = {
    every?: LinkedInOptimizationWhereInput
    some?: LinkedInOptimizationWhereInput
    none?: LinkedInOptimizationWhereInput
  }

  export type InterviewSessionListRelationFilter = {
    every?: InterviewSessionWhereInput
    some?: InterviewSessionWhereInput
    none?: InterviewSessionWhereInput
  }

  export type ResumeExportListRelationFilter = {
    every?: ResumeExportWhereInput
    some?: ResumeExportWhereInput
    none?: ResumeExportWhereInput
  }

  export type JobDescriptionIntelligenceListRelationFilter = {
    every?: JobDescriptionIntelligenceWhereInput
    some?: JobDescriptionIntelligenceWhereInput
    none?: JobDescriptionIntelligenceWhereInput
  }

  export type ResumeTagListRelationFilter = {
    every?: ResumeTagWhereInput
    some?: ResumeTagWhereInput
    none?: ResumeTagWhereInput
  }

  export type ResumeMetadataListRelationFilter = {
    every?: ResumeMetadataWhereInput
    some?: ResumeMetadataWhereInput
    none?: ResumeMetadataWhereInput
  }

  export type ResumeSectionRationaleListRelationFilter = {
    every?: ResumeSectionRationaleWhereInput
    some?: ResumeSectionRationaleWhereInput
    none?: ResumeSectionRationaleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ResumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TailoringAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoverLetterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinkedInOptimizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeExportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobDescriptionIntelligenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeSectionRationaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    isPremium?: SortOrder
    dailyResetDate?: SortOrder
    dailyBasicTailoringsUsed?: SortOrder
    dailyPersonalizedTailoringsUsed?: SortOrder
    dailyAggressiveTailoringsUsed?: SortOrder
    dailyCoverLettersUsed?: SortOrder
    dailyLinkedinOptimizationsUsed?: SortOrder
    dailyInterviewSessionsUsed?: SortOrder
    analyticsTimeRange?: SortOrder
    analyticsViewMode?: SortOrder
    resumeTemplate?: SortOrder
    preferredTailoringMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    dailyBasicTailoringsUsed?: SortOrder
    dailyPersonalizedTailoringsUsed?: SortOrder
    dailyAggressiveTailoringsUsed?: SortOrder
    dailyCoverLettersUsed?: SortOrder
    dailyLinkedinOptimizationsUsed?: SortOrder
    dailyInterviewSessionsUsed?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    isPremium?: SortOrder
    dailyResetDate?: SortOrder
    dailyBasicTailoringsUsed?: SortOrder
    dailyPersonalizedTailoringsUsed?: SortOrder
    dailyAggressiveTailoringsUsed?: SortOrder
    dailyCoverLettersUsed?: SortOrder
    dailyLinkedinOptimizationsUsed?: SortOrder
    dailyInterviewSessionsUsed?: SortOrder
    analyticsTimeRange?: SortOrder
    analyticsViewMode?: SortOrder
    resumeTemplate?: SortOrder
    preferredTailoringMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    isPremium?: SortOrder
    dailyResetDate?: SortOrder
    dailyBasicTailoringsUsed?: SortOrder
    dailyPersonalizedTailoringsUsed?: SortOrder
    dailyAggressiveTailoringsUsed?: SortOrder
    dailyCoverLettersUsed?: SortOrder
    dailyLinkedinOptimizationsUsed?: SortOrder
    dailyInterviewSessionsUsed?: SortOrder
    analyticsTimeRange?: SortOrder
    analyticsViewMode?: SortOrder
    resumeTemplate?: SortOrder
    preferredTailoringMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    dailyBasicTailoringsUsed?: SortOrder
    dailyPersonalizedTailoringsUsed?: SortOrder
    dailyAggressiveTailoringsUsed?: SortOrder
    dailyCoverLettersUsed?: SortOrder
    dailyLinkedinOptimizationsUsed?: SortOrder
    dailyInterviewSessionsUsed?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ScrubbedResumeNullableScalarRelationFilter = {
    is?: ScrubbedResumeWhereInput | null
    isNot?: ScrubbedResumeWhereInput | null
  }

  export type PromptArchiveListRelationFilter = {
    every?: PromptArchiveWhereInput
    some?: PromptArchiveWhereInput
    none?: PromptArchiveWhereInput
  }

  export type ResumeMetadataNullableScalarRelationFilter = {
    is?: ResumeMetadataWhereInput | null
    isNot?: ResumeMetadataWhereInput | null
  }

  export type TailoringPromptListRelationFilter = {
    every?: TailoringPromptWhereInput
    some?: TailoringPromptWhereInput
    none?: TailoringPromptWhereInput
  }

  export type TailoringProgressListRelationFilter = {
    every?: TailoringProgressWhereInput
    some?: TailoringProgressWhereInput
    none?: TailoringProgressWhereInput
  }

  export type TailoringAttemptListRelationFilter = {
    every?: TailoringAttemptWhereInput
    some?: TailoringAttemptWhereInput
    none?: TailoringAttemptWhereInput
  }

  export type ManualEditListRelationFilter = {
    every?: ManualEditWhereInput
    some?: ManualEditWhereInput
    none?: ManualEditWhereInput
  }

  export type ManualScoringListRelationFilter = {
    every?: ManualScoringWhereInput
    some?: ManualScoringWhereInput
    none?: ManualScoringWhereInput
  }

  export type ResumeFeedbackListRelationFilter = {
    every?: ResumeFeedbackWhereInput
    some?: ResumeFeedbackWhereInput
    none?: ResumeFeedbackWhereInput
  }

  export type PromptArchiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TailoringPromptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TailoringProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TailoringAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManualEditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManualScoringOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    modifiedResume?: SortOrder
    tailoringMode?: SortOrder
    version?: SortOrder
    label?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    isSaved?: SortOrder
    originalResumeId?: SortOrder
    wasManuallyEdited?: SortOrder
    scoresStale?: SortOrder
    finalModifiedSections?: SortOrder
    atsWarnings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumeAvgOrderByAggregateInput = {
    version?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
  }

  export type ResumeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    modifiedResume?: SortOrder
    tailoringMode?: SortOrder
    version?: SortOrder
    label?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    isSaved?: SortOrder
    originalResumeId?: SortOrder
    wasManuallyEdited?: SortOrder
    scoresStale?: SortOrder
    finalModifiedSections?: SortOrder
    atsWarnings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    modifiedResume?: SortOrder
    tailoringMode?: SortOrder
    version?: SortOrder
    label?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    isSaved?: SortOrder
    originalResumeId?: SortOrder
    wasManuallyEdited?: SortOrder
    scoresStale?: SortOrder
    finalModifiedSections?: SortOrder
    atsWarnings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResumeSumOrderByAggregateInput = {
    version?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ResumeEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    eventType?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    eventType?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    eventType?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeScalarRelationFilter = {
    is?: ResumeWhereInput
    isNot?: ResumeWhereInput
  }

  export type TailoringAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    createdAt?: SortOrder
    modifiedSections?: SortOrder
  }

  export type TailoringAnalyticsAvgOrderByAggregateInput = {
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
  }

  export type TailoringAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    createdAt?: SortOrder
    modifiedSections?: SortOrder
  }

  export type TailoringAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    isRefinement?: SortOrder
    createdAt?: SortOrder
    modifiedSections?: SortOrder
  }

  export type TailoringAnalyticsSumOrderByAggregateInput = {
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
  }

  export type ScrubbedResumeCountOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    cleanText?: SortOrder
    createdAt?: SortOrder
  }

  export type ScrubbedResumeMaxOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    cleanText?: SortOrder
    createdAt?: SortOrder
  }

  export type ScrubbedResumeMinOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    cleanText?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptArchiveCountOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    content?: SortOrder
    response?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptArchiveMaxOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    content?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptArchiveMinOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    content?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeTagCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    tag?: SortOrder
  }

  export type ResumeTagMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    tag?: SortOrder
  }

  export type ResumeTagMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    tag?: SortOrder
  }

  export type ResumeMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    contentSnippet?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    passedRules?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeMetadataAvgOrderByAggregateInput = {
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
  }

  export type ResumeMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    contentSnippet?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    passedRules?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    contentSnippet?: SortOrder
    tailoringMode?: SortOrder
    iterations?: SortOrder
    passedRules?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeMetadataSumOrderByAggregateInput = {
    iterations?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
  }

  export type TailoringPromptCountOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    tailoringMode?: SortOrder
    prompt?: SortOrder
    attempt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
  }

  export type TailoringPromptAvgOrderByAggregateInput = {
    attempt?: SortOrder
    version?: SortOrder
  }

  export type TailoringPromptMaxOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    tailoringMode?: SortOrder
    prompt?: SortOrder
    attempt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
  }

  export type TailoringPromptMinOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    tailoringMode?: SortOrder
    prompt?: SortOrder
    attempt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
  }

  export type TailoringPromptSumOrderByAggregateInput = {
    attempt?: SortOrder
    version?: SortOrder
  }

  export type TailoringProgressResumeId_userIdCompoundUniqueInput = {
    resumeId: string
    userId: string
  }

  export type TailoringProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentAttempt?: SortOrder
    maxAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TailoringProgressAvgOrderByAggregateInput = {
    progress?: SortOrder
    currentAttempt?: SortOrder
    maxAttempts?: SortOrder
  }

  export type TailoringProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentAttempt?: SortOrder
    maxAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TailoringProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    currentAttempt?: SortOrder
    maxAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TailoringProgressSumOrderByAggregateInput = {
    progress?: SortOrder
    currentAttempt?: SortOrder
    maxAttempts?: SortOrder
  }

  export type TailoringAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    attemptNumber?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    feedback?: SortOrder
    suggestions?: SortOrder
    atsFeedback?: SortOrder
    jdFeedback?: SortOrder
    createdAt?: SortOrder
    modifiedSectionsSent?: SortOrder
    modifiedSectionsReceived?: SortOrder
    promptTokens?: SortOrder
    goldenRuleFeedback?: SortOrder
    iteration?: SortOrder
    modifiedSections?: SortOrder
    score?: SortOrder
  }

  export type TailoringAttemptAvgOrderByAggregateInput = {
    attemptNumber?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    promptTokens?: SortOrder
    iteration?: SortOrder
    score?: SortOrder
  }

  export type TailoringAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    attemptNumber?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    feedback?: SortOrder
    suggestions?: SortOrder
    atsFeedback?: SortOrder
    jdFeedback?: SortOrder
    createdAt?: SortOrder
    modifiedSectionsSent?: SortOrder
    modifiedSectionsReceived?: SortOrder
    promptTokens?: SortOrder
    goldenRuleFeedback?: SortOrder
    iteration?: SortOrder
    modifiedSections?: SortOrder
    score?: SortOrder
  }

  export type TailoringAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    attemptNumber?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    goldenPassed?: SortOrder
    feedback?: SortOrder
    suggestions?: SortOrder
    atsFeedback?: SortOrder
    jdFeedback?: SortOrder
    createdAt?: SortOrder
    modifiedSectionsSent?: SortOrder
    modifiedSectionsReceived?: SortOrder
    promptTokens?: SortOrder
    goldenRuleFeedback?: SortOrder
    iteration?: SortOrder
    modifiedSections?: SortOrder
    score?: SortOrder
  }

  export type TailoringAttemptSumOrderByAggregateInput = {
    attemptNumber?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    promptTokens?: SortOrder
    iteration?: SortOrder
    score?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ResumeFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    feedbackType?: SortOrder
    feedbackPoints?: SortOrder
    sourceVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeFeedbackAvgOrderByAggregateInput = {
    sourceVersion?: SortOrder
  }

  export type ResumeFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    feedbackType?: SortOrder
    sourceVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    feedbackType?: SortOrder
    sourceVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeFeedbackSumOrderByAggregateInput = {
    sourceVersion?: SortOrder
  }

  export type ManualEditCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    editedText?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualEditMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    editedText?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualEditMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    editedText?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualScoringCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    atsFeedback?: SortOrder
    jdFeedback?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualScoringAvgOrderByAggregateInput = {
    atsScore?: SortOrder
    jdScore?: SortOrder
  }

  export type ManualScoringMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    atsFeedback?: SortOrder
    jdFeedback?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualScoringMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    atsFeedback?: SortOrder
    jdFeedback?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualScoringSumOrderByAggregateInput = {
    atsScore?: SortOrder
    jdScore?: SortOrder
  }

  export type CoverLetterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    jobDescription?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoverLetterAvgOrderByAggregateInput = {
    atsScore?: SortOrder
    jdScore?: SortOrder
    version?: SortOrder
  }

  export type CoverLetterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    jobDescription?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoverLetterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    jobDescription?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    atsScore?: SortOrder
    jdScore?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoverLetterSumOrderByAggregateInput = {
    atsScore?: SortOrder
    jdScore?: SortOrder
    version?: SortOrder
  }

  export type LinkedInOptimizationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    originalAbout?: SortOrder
    optimizedAbout?: SortOrder
    tone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedInOptimizationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    originalAbout?: SortOrder
    optimizedAbout?: SortOrder
    tone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedInOptimizationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    originalAbout?: SortOrder
    optimizedAbout?: SortOrder
    tone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type InterviewSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    selectedTypes?: SortOrder
    questions?: SortOrder
    answers?: SortOrder
    needsReview?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ResumeExportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    templateId?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeExportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    templateId?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeExportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    templateId?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
  }

  export type JobDescriptionIntelligenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    role?: SortOrder
    seniority?: SortOrder
    keywords?: SortOrder
    responsibilities?: SortOrder
    qualifications?: SortOrder
    categories?: SortOrder
    createdAt?: SortOrder
  }

  export type JobDescriptionIntelligenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    role?: SortOrder
    seniority?: SortOrder
    createdAt?: SortOrder
  }

  export type JobDescriptionIntelligenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    role?: SortOrder
    seniority?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeSectionRationaleResumeIdSectionNameCompoundUniqueInput = {
    resumeId: string
    sectionName: string
  }

  export type ResumeSectionRationaleCountOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    sectionName?: SortOrder
    rationale?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeSectionRationaleMaxOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    sectionName?: SortOrder
    rationale?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeSectionRationaleMinOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    userId?: SortOrder
    sectionName?: SortOrder
    rationale?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type ContactSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type ContactSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type ResumeCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput> | ResumeCreateWithoutUserInput[] | ResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutUserInput | ResumeCreateOrConnectWithoutUserInput[]
    createMany?: ResumeCreateManyUserInputEnvelope
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
  }

  export type TailoringAnalyticsCreateNestedManyWithoutUserInput = {
    create?: XOR<TailoringAnalyticsCreateWithoutUserInput, TailoringAnalyticsUncheckedCreateWithoutUserInput> | TailoringAnalyticsCreateWithoutUserInput[] | TailoringAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TailoringAnalyticsCreateOrConnectWithoutUserInput | TailoringAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: TailoringAnalyticsCreateManyUserInputEnvelope
    connect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
  }

  export type ResumeInteractionCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeInteractionCreateWithoutUserInput, ResumeInteractionUncheckedCreateWithoutUserInput> | ResumeInteractionCreateWithoutUserInput[] | ResumeInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeInteractionCreateOrConnectWithoutUserInput | ResumeInteractionCreateOrConnectWithoutUserInput[]
    createMany?: ResumeInteractionCreateManyUserInputEnvelope
    connect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
  }

  export type CoverLetterCreateNestedManyWithoutUserInput = {
    create?: XOR<CoverLetterCreateWithoutUserInput, CoverLetterUncheckedCreateWithoutUserInput> | CoverLetterCreateWithoutUserInput[] | CoverLetterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoverLetterCreateOrConnectWithoutUserInput | CoverLetterCreateOrConnectWithoutUserInput[]
    createMany?: CoverLetterCreateManyUserInputEnvelope
    connect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
  }

  export type LinkedInOptimizationCreateNestedManyWithoutUserInput = {
    create?: XOR<LinkedInOptimizationCreateWithoutUserInput, LinkedInOptimizationUncheckedCreateWithoutUserInput> | LinkedInOptimizationCreateWithoutUserInput[] | LinkedInOptimizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkedInOptimizationCreateOrConnectWithoutUserInput | LinkedInOptimizationCreateOrConnectWithoutUserInput[]
    createMany?: LinkedInOptimizationCreateManyUserInputEnvelope
    connect?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
  }

  export type InterviewSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput> | InterviewSessionCreateWithoutUserInput[] | InterviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutUserInput | InterviewSessionCreateOrConnectWithoutUserInput[]
    createMany?: InterviewSessionCreateManyUserInputEnvelope
    connect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
  }

  export type ResumeExportCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeExportCreateWithoutUserInput, ResumeExportUncheckedCreateWithoutUserInput> | ResumeExportCreateWithoutUserInput[] | ResumeExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeExportCreateOrConnectWithoutUserInput | ResumeExportCreateOrConnectWithoutUserInput[]
    createMany?: ResumeExportCreateManyUserInputEnvelope
    connect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
  }

  export type JobDescriptionIntelligenceCreateNestedManyWithoutUserInput = {
    create?: XOR<JobDescriptionIntelligenceCreateWithoutUserInput, JobDescriptionIntelligenceUncheckedCreateWithoutUserInput> | JobDescriptionIntelligenceCreateWithoutUserInput[] | JobDescriptionIntelligenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobDescriptionIntelligenceCreateOrConnectWithoutUserInput | JobDescriptionIntelligenceCreateOrConnectWithoutUserInput[]
    createMany?: JobDescriptionIntelligenceCreateManyUserInputEnvelope
    connect?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
  }

  export type ResumeTagCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeTagCreateWithoutUserInput, ResumeTagUncheckedCreateWithoutUserInput> | ResumeTagCreateWithoutUserInput[] | ResumeTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeTagCreateOrConnectWithoutUserInput | ResumeTagCreateOrConnectWithoutUserInput[]
    createMany?: ResumeTagCreateManyUserInputEnvelope
    connect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
  }

  export type ResumeMetadataCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeMetadataCreateWithoutUserInput, ResumeMetadataUncheckedCreateWithoutUserInput> | ResumeMetadataCreateWithoutUserInput[] | ResumeMetadataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeMetadataCreateOrConnectWithoutUserInput | ResumeMetadataCreateOrConnectWithoutUserInput[]
    createMany?: ResumeMetadataCreateManyUserInputEnvelope
    connect?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
  }

  export type ResumeSectionRationaleCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeSectionRationaleCreateWithoutUserInput, ResumeSectionRationaleUncheckedCreateWithoutUserInput> | ResumeSectionRationaleCreateWithoutUserInput[] | ResumeSectionRationaleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeSectionRationaleCreateOrConnectWithoutUserInput | ResumeSectionRationaleCreateOrConnectWithoutUserInput[]
    createMany?: ResumeSectionRationaleCreateManyUserInputEnvelope
    connect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
  }

  export type ResumeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput> | ResumeCreateWithoutUserInput[] | ResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutUserInput | ResumeCreateOrConnectWithoutUserInput[]
    createMany?: ResumeCreateManyUserInputEnvelope
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
  }

  export type TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TailoringAnalyticsCreateWithoutUserInput, TailoringAnalyticsUncheckedCreateWithoutUserInput> | TailoringAnalyticsCreateWithoutUserInput[] | TailoringAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TailoringAnalyticsCreateOrConnectWithoutUserInput | TailoringAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: TailoringAnalyticsCreateManyUserInputEnvelope
    connect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
  }

  export type ResumeInteractionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeInteractionCreateWithoutUserInput, ResumeInteractionUncheckedCreateWithoutUserInput> | ResumeInteractionCreateWithoutUserInput[] | ResumeInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeInteractionCreateOrConnectWithoutUserInput | ResumeInteractionCreateOrConnectWithoutUserInput[]
    createMany?: ResumeInteractionCreateManyUserInputEnvelope
    connect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
  }

  export type CoverLetterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CoverLetterCreateWithoutUserInput, CoverLetterUncheckedCreateWithoutUserInput> | CoverLetterCreateWithoutUserInput[] | CoverLetterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoverLetterCreateOrConnectWithoutUserInput | CoverLetterCreateOrConnectWithoutUserInput[]
    createMany?: CoverLetterCreateManyUserInputEnvelope
    connect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
  }

  export type LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LinkedInOptimizationCreateWithoutUserInput, LinkedInOptimizationUncheckedCreateWithoutUserInput> | LinkedInOptimizationCreateWithoutUserInput[] | LinkedInOptimizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkedInOptimizationCreateOrConnectWithoutUserInput | LinkedInOptimizationCreateOrConnectWithoutUserInput[]
    createMany?: LinkedInOptimizationCreateManyUserInputEnvelope
    connect?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
  }

  export type InterviewSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput> | InterviewSessionCreateWithoutUserInput[] | InterviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutUserInput | InterviewSessionCreateOrConnectWithoutUserInput[]
    createMany?: InterviewSessionCreateManyUserInputEnvelope
    connect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
  }

  export type ResumeExportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeExportCreateWithoutUserInput, ResumeExportUncheckedCreateWithoutUserInput> | ResumeExportCreateWithoutUserInput[] | ResumeExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeExportCreateOrConnectWithoutUserInput | ResumeExportCreateOrConnectWithoutUserInput[]
    createMany?: ResumeExportCreateManyUserInputEnvelope
    connect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
  }

  export type JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JobDescriptionIntelligenceCreateWithoutUserInput, JobDescriptionIntelligenceUncheckedCreateWithoutUserInput> | JobDescriptionIntelligenceCreateWithoutUserInput[] | JobDescriptionIntelligenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobDescriptionIntelligenceCreateOrConnectWithoutUserInput | JobDescriptionIntelligenceCreateOrConnectWithoutUserInput[]
    createMany?: JobDescriptionIntelligenceCreateManyUserInputEnvelope
    connect?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
  }

  export type ResumeTagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeTagCreateWithoutUserInput, ResumeTagUncheckedCreateWithoutUserInput> | ResumeTagCreateWithoutUserInput[] | ResumeTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeTagCreateOrConnectWithoutUserInput | ResumeTagCreateOrConnectWithoutUserInput[]
    createMany?: ResumeTagCreateManyUserInputEnvelope
    connect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
  }

  export type ResumeMetadataUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeMetadataCreateWithoutUserInput, ResumeMetadataUncheckedCreateWithoutUserInput> | ResumeMetadataCreateWithoutUserInput[] | ResumeMetadataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeMetadataCreateOrConnectWithoutUserInput | ResumeMetadataCreateOrConnectWithoutUserInput[]
    createMany?: ResumeMetadataCreateManyUserInputEnvelope
    connect?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
  }

  export type ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeSectionRationaleCreateWithoutUserInput, ResumeSectionRationaleUncheckedCreateWithoutUserInput> | ResumeSectionRationaleCreateWithoutUserInput[] | ResumeSectionRationaleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeSectionRationaleCreateOrConnectWithoutUserInput | ResumeSectionRationaleCreateOrConnectWithoutUserInput[]
    createMany?: ResumeSectionRationaleCreateManyUserInputEnvelope
    connect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ResumeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput> | ResumeCreateWithoutUserInput[] | ResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutUserInput | ResumeCreateOrConnectWithoutUserInput[]
    upsert?: ResumeUpsertWithWhereUniqueWithoutUserInput | ResumeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeCreateManyUserInputEnvelope
    set?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    disconnect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    delete?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    update?: ResumeUpdateWithWhereUniqueWithoutUserInput | ResumeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeUpdateManyWithWhereWithoutUserInput | ResumeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
  }

  export type TailoringAnalyticsUpdateManyWithoutUserNestedInput = {
    create?: XOR<TailoringAnalyticsCreateWithoutUserInput, TailoringAnalyticsUncheckedCreateWithoutUserInput> | TailoringAnalyticsCreateWithoutUserInput[] | TailoringAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TailoringAnalyticsCreateOrConnectWithoutUserInput | TailoringAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: TailoringAnalyticsUpsertWithWhereUniqueWithoutUserInput | TailoringAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TailoringAnalyticsCreateManyUserInputEnvelope
    set?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    disconnect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    delete?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    connect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    update?: TailoringAnalyticsUpdateWithWhereUniqueWithoutUserInput | TailoringAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TailoringAnalyticsUpdateManyWithWhereWithoutUserInput | TailoringAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TailoringAnalyticsScalarWhereInput | TailoringAnalyticsScalarWhereInput[]
  }

  export type ResumeInteractionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeInteractionCreateWithoutUserInput, ResumeInteractionUncheckedCreateWithoutUserInput> | ResumeInteractionCreateWithoutUserInput[] | ResumeInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeInteractionCreateOrConnectWithoutUserInput | ResumeInteractionCreateOrConnectWithoutUserInput[]
    upsert?: ResumeInteractionUpsertWithWhereUniqueWithoutUserInput | ResumeInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeInteractionCreateManyUserInputEnvelope
    set?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    disconnect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    delete?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    connect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    update?: ResumeInteractionUpdateWithWhereUniqueWithoutUserInput | ResumeInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeInteractionUpdateManyWithWhereWithoutUserInput | ResumeInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeInteractionScalarWhereInput | ResumeInteractionScalarWhereInput[]
  }

  export type CoverLetterUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoverLetterCreateWithoutUserInput, CoverLetterUncheckedCreateWithoutUserInput> | CoverLetterCreateWithoutUserInput[] | CoverLetterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoverLetterCreateOrConnectWithoutUserInput | CoverLetterCreateOrConnectWithoutUserInput[]
    upsert?: CoverLetterUpsertWithWhereUniqueWithoutUserInput | CoverLetterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoverLetterCreateManyUserInputEnvelope
    set?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    disconnect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    delete?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    connect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    update?: CoverLetterUpdateWithWhereUniqueWithoutUserInput | CoverLetterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoverLetterUpdateManyWithWhereWithoutUserInput | CoverLetterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoverLetterScalarWhereInput | CoverLetterScalarWhereInput[]
  }

  export type LinkedInOptimizationUpdateManyWithoutUserNestedInput = {
    create?: XOR<LinkedInOptimizationCreateWithoutUserInput, LinkedInOptimizationUncheckedCreateWithoutUserInput> | LinkedInOptimizationCreateWithoutUserInput[] | LinkedInOptimizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkedInOptimizationCreateOrConnectWithoutUserInput | LinkedInOptimizationCreateOrConnectWithoutUserInput[]
    upsert?: LinkedInOptimizationUpsertWithWhereUniqueWithoutUserInput | LinkedInOptimizationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LinkedInOptimizationCreateManyUserInputEnvelope
    set?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
    disconnect?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
    delete?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
    connect?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
    update?: LinkedInOptimizationUpdateWithWhereUniqueWithoutUserInput | LinkedInOptimizationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LinkedInOptimizationUpdateManyWithWhereWithoutUserInput | LinkedInOptimizationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LinkedInOptimizationScalarWhereInput | LinkedInOptimizationScalarWhereInput[]
  }

  export type InterviewSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput> | InterviewSessionCreateWithoutUserInput[] | InterviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutUserInput | InterviewSessionCreateOrConnectWithoutUserInput[]
    upsert?: InterviewSessionUpsertWithWhereUniqueWithoutUserInput | InterviewSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewSessionCreateManyUserInputEnvelope
    set?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    disconnect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    delete?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    connect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    update?: InterviewSessionUpdateWithWhereUniqueWithoutUserInput | InterviewSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewSessionUpdateManyWithWhereWithoutUserInput | InterviewSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewSessionScalarWhereInput | InterviewSessionScalarWhereInput[]
  }

  export type ResumeExportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeExportCreateWithoutUserInput, ResumeExportUncheckedCreateWithoutUserInput> | ResumeExportCreateWithoutUserInput[] | ResumeExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeExportCreateOrConnectWithoutUserInput | ResumeExportCreateOrConnectWithoutUserInput[]
    upsert?: ResumeExportUpsertWithWhereUniqueWithoutUserInput | ResumeExportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeExportCreateManyUserInputEnvelope
    set?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    disconnect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    delete?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    connect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    update?: ResumeExportUpdateWithWhereUniqueWithoutUserInput | ResumeExportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeExportUpdateManyWithWhereWithoutUserInput | ResumeExportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeExportScalarWhereInput | ResumeExportScalarWhereInput[]
  }

  export type JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobDescriptionIntelligenceCreateWithoutUserInput, JobDescriptionIntelligenceUncheckedCreateWithoutUserInput> | JobDescriptionIntelligenceCreateWithoutUserInput[] | JobDescriptionIntelligenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobDescriptionIntelligenceCreateOrConnectWithoutUserInput | JobDescriptionIntelligenceCreateOrConnectWithoutUserInput[]
    upsert?: JobDescriptionIntelligenceUpsertWithWhereUniqueWithoutUserInput | JobDescriptionIntelligenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobDescriptionIntelligenceCreateManyUserInputEnvelope
    set?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
    disconnect?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
    delete?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
    connect?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
    update?: JobDescriptionIntelligenceUpdateWithWhereUniqueWithoutUserInput | JobDescriptionIntelligenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobDescriptionIntelligenceUpdateManyWithWhereWithoutUserInput | JobDescriptionIntelligenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobDescriptionIntelligenceScalarWhereInput | JobDescriptionIntelligenceScalarWhereInput[]
  }

  export type ResumeTagUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeTagCreateWithoutUserInput, ResumeTagUncheckedCreateWithoutUserInput> | ResumeTagCreateWithoutUserInput[] | ResumeTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeTagCreateOrConnectWithoutUserInput | ResumeTagCreateOrConnectWithoutUserInput[]
    upsert?: ResumeTagUpsertWithWhereUniqueWithoutUserInput | ResumeTagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeTagCreateManyUserInputEnvelope
    set?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    disconnect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    delete?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    connect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    update?: ResumeTagUpdateWithWhereUniqueWithoutUserInput | ResumeTagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeTagUpdateManyWithWhereWithoutUserInput | ResumeTagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeTagScalarWhereInput | ResumeTagScalarWhereInput[]
  }

  export type ResumeMetadataUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeMetadataCreateWithoutUserInput, ResumeMetadataUncheckedCreateWithoutUserInput> | ResumeMetadataCreateWithoutUserInput[] | ResumeMetadataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeMetadataCreateOrConnectWithoutUserInput | ResumeMetadataCreateOrConnectWithoutUserInput[]
    upsert?: ResumeMetadataUpsertWithWhereUniqueWithoutUserInput | ResumeMetadataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeMetadataCreateManyUserInputEnvelope
    set?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
    disconnect?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
    delete?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
    connect?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
    update?: ResumeMetadataUpdateWithWhereUniqueWithoutUserInput | ResumeMetadataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeMetadataUpdateManyWithWhereWithoutUserInput | ResumeMetadataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeMetadataScalarWhereInput | ResumeMetadataScalarWhereInput[]
  }

  export type ResumeSectionRationaleUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeSectionRationaleCreateWithoutUserInput, ResumeSectionRationaleUncheckedCreateWithoutUserInput> | ResumeSectionRationaleCreateWithoutUserInput[] | ResumeSectionRationaleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeSectionRationaleCreateOrConnectWithoutUserInput | ResumeSectionRationaleCreateOrConnectWithoutUserInput[]
    upsert?: ResumeSectionRationaleUpsertWithWhereUniqueWithoutUserInput | ResumeSectionRationaleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeSectionRationaleCreateManyUserInputEnvelope
    set?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    disconnect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    delete?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    connect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    update?: ResumeSectionRationaleUpdateWithWhereUniqueWithoutUserInput | ResumeSectionRationaleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeSectionRationaleUpdateManyWithWhereWithoutUserInput | ResumeSectionRationaleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeSectionRationaleScalarWhereInput | ResumeSectionRationaleScalarWhereInput[]
  }

  export type ResumeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput> | ResumeCreateWithoutUserInput[] | ResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutUserInput | ResumeCreateOrConnectWithoutUserInput[]
    upsert?: ResumeUpsertWithWhereUniqueWithoutUserInput | ResumeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeCreateManyUserInputEnvelope
    set?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    disconnect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    delete?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    update?: ResumeUpdateWithWhereUniqueWithoutUserInput | ResumeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeUpdateManyWithWhereWithoutUserInput | ResumeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
  }

  export type TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TailoringAnalyticsCreateWithoutUserInput, TailoringAnalyticsUncheckedCreateWithoutUserInput> | TailoringAnalyticsCreateWithoutUserInput[] | TailoringAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TailoringAnalyticsCreateOrConnectWithoutUserInput | TailoringAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: TailoringAnalyticsUpsertWithWhereUniqueWithoutUserInput | TailoringAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TailoringAnalyticsCreateManyUserInputEnvelope
    set?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    disconnect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    delete?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    connect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    update?: TailoringAnalyticsUpdateWithWhereUniqueWithoutUserInput | TailoringAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TailoringAnalyticsUpdateManyWithWhereWithoutUserInput | TailoringAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TailoringAnalyticsScalarWhereInput | TailoringAnalyticsScalarWhereInput[]
  }

  export type ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeInteractionCreateWithoutUserInput, ResumeInteractionUncheckedCreateWithoutUserInput> | ResumeInteractionCreateWithoutUserInput[] | ResumeInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeInteractionCreateOrConnectWithoutUserInput | ResumeInteractionCreateOrConnectWithoutUserInput[]
    upsert?: ResumeInteractionUpsertWithWhereUniqueWithoutUserInput | ResumeInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeInteractionCreateManyUserInputEnvelope
    set?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    disconnect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    delete?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    connect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    update?: ResumeInteractionUpdateWithWhereUniqueWithoutUserInput | ResumeInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeInteractionUpdateManyWithWhereWithoutUserInput | ResumeInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeInteractionScalarWhereInput | ResumeInteractionScalarWhereInput[]
  }

  export type CoverLetterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoverLetterCreateWithoutUserInput, CoverLetterUncheckedCreateWithoutUserInput> | CoverLetterCreateWithoutUserInput[] | CoverLetterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoverLetterCreateOrConnectWithoutUserInput | CoverLetterCreateOrConnectWithoutUserInput[]
    upsert?: CoverLetterUpsertWithWhereUniqueWithoutUserInput | CoverLetterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoverLetterCreateManyUserInputEnvelope
    set?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    disconnect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    delete?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    connect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    update?: CoverLetterUpdateWithWhereUniqueWithoutUserInput | CoverLetterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoverLetterUpdateManyWithWhereWithoutUserInput | CoverLetterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoverLetterScalarWhereInput | CoverLetterScalarWhereInput[]
  }

  export type LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LinkedInOptimizationCreateWithoutUserInput, LinkedInOptimizationUncheckedCreateWithoutUserInput> | LinkedInOptimizationCreateWithoutUserInput[] | LinkedInOptimizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkedInOptimizationCreateOrConnectWithoutUserInput | LinkedInOptimizationCreateOrConnectWithoutUserInput[]
    upsert?: LinkedInOptimizationUpsertWithWhereUniqueWithoutUserInput | LinkedInOptimizationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LinkedInOptimizationCreateManyUserInputEnvelope
    set?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
    disconnect?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
    delete?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
    connect?: LinkedInOptimizationWhereUniqueInput | LinkedInOptimizationWhereUniqueInput[]
    update?: LinkedInOptimizationUpdateWithWhereUniqueWithoutUserInput | LinkedInOptimizationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LinkedInOptimizationUpdateManyWithWhereWithoutUserInput | LinkedInOptimizationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LinkedInOptimizationScalarWhereInput | LinkedInOptimizationScalarWhereInput[]
  }

  export type InterviewSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput> | InterviewSessionCreateWithoutUserInput[] | InterviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutUserInput | InterviewSessionCreateOrConnectWithoutUserInput[]
    upsert?: InterviewSessionUpsertWithWhereUniqueWithoutUserInput | InterviewSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewSessionCreateManyUserInputEnvelope
    set?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    disconnect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    delete?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    connect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    update?: InterviewSessionUpdateWithWhereUniqueWithoutUserInput | InterviewSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewSessionUpdateManyWithWhereWithoutUserInput | InterviewSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewSessionScalarWhereInput | InterviewSessionScalarWhereInput[]
  }

  export type ResumeExportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeExportCreateWithoutUserInput, ResumeExportUncheckedCreateWithoutUserInput> | ResumeExportCreateWithoutUserInput[] | ResumeExportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeExportCreateOrConnectWithoutUserInput | ResumeExportCreateOrConnectWithoutUserInput[]
    upsert?: ResumeExportUpsertWithWhereUniqueWithoutUserInput | ResumeExportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeExportCreateManyUserInputEnvelope
    set?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    disconnect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    delete?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    connect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    update?: ResumeExportUpdateWithWhereUniqueWithoutUserInput | ResumeExportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeExportUpdateManyWithWhereWithoutUserInput | ResumeExportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeExportScalarWhereInput | ResumeExportScalarWhereInput[]
  }

  export type JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobDescriptionIntelligenceCreateWithoutUserInput, JobDescriptionIntelligenceUncheckedCreateWithoutUserInput> | JobDescriptionIntelligenceCreateWithoutUserInput[] | JobDescriptionIntelligenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobDescriptionIntelligenceCreateOrConnectWithoutUserInput | JobDescriptionIntelligenceCreateOrConnectWithoutUserInput[]
    upsert?: JobDescriptionIntelligenceUpsertWithWhereUniqueWithoutUserInput | JobDescriptionIntelligenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobDescriptionIntelligenceCreateManyUserInputEnvelope
    set?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
    disconnect?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
    delete?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
    connect?: JobDescriptionIntelligenceWhereUniqueInput | JobDescriptionIntelligenceWhereUniqueInput[]
    update?: JobDescriptionIntelligenceUpdateWithWhereUniqueWithoutUserInput | JobDescriptionIntelligenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobDescriptionIntelligenceUpdateManyWithWhereWithoutUserInput | JobDescriptionIntelligenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobDescriptionIntelligenceScalarWhereInput | JobDescriptionIntelligenceScalarWhereInput[]
  }

  export type ResumeTagUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeTagCreateWithoutUserInput, ResumeTagUncheckedCreateWithoutUserInput> | ResumeTagCreateWithoutUserInput[] | ResumeTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeTagCreateOrConnectWithoutUserInput | ResumeTagCreateOrConnectWithoutUserInput[]
    upsert?: ResumeTagUpsertWithWhereUniqueWithoutUserInput | ResumeTagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeTagCreateManyUserInputEnvelope
    set?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    disconnect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    delete?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    connect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    update?: ResumeTagUpdateWithWhereUniqueWithoutUserInput | ResumeTagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeTagUpdateManyWithWhereWithoutUserInput | ResumeTagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeTagScalarWhereInput | ResumeTagScalarWhereInput[]
  }

  export type ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeMetadataCreateWithoutUserInput, ResumeMetadataUncheckedCreateWithoutUserInput> | ResumeMetadataCreateWithoutUserInput[] | ResumeMetadataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeMetadataCreateOrConnectWithoutUserInput | ResumeMetadataCreateOrConnectWithoutUserInput[]
    upsert?: ResumeMetadataUpsertWithWhereUniqueWithoutUserInput | ResumeMetadataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeMetadataCreateManyUserInputEnvelope
    set?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
    disconnect?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
    delete?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
    connect?: ResumeMetadataWhereUniqueInput | ResumeMetadataWhereUniqueInput[]
    update?: ResumeMetadataUpdateWithWhereUniqueWithoutUserInput | ResumeMetadataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeMetadataUpdateManyWithWhereWithoutUserInput | ResumeMetadataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeMetadataScalarWhereInput | ResumeMetadataScalarWhereInput[]
  }

  export type ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeSectionRationaleCreateWithoutUserInput, ResumeSectionRationaleUncheckedCreateWithoutUserInput> | ResumeSectionRationaleCreateWithoutUserInput[] | ResumeSectionRationaleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeSectionRationaleCreateOrConnectWithoutUserInput | ResumeSectionRationaleCreateOrConnectWithoutUserInput[]
    upsert?: ResumeSectionRationaleUpsertWithWhereUniqueWithoutUserInput | ResumeSectionRationaleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeSectionRationaleCreateManyUserInputEnvelope
    set?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    disconnect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    delete?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    connect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    update?: ResumeSectionRationaleUpdateWithWhereUniqueWithoutUserInput | ResumeSectionRationaleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeSectionRationaleUpdateManyWithWhereWithoutUserInput | ResumeSectionRationaleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeSectionRationaleScalarWhereInput | ResumeSectionRationaleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutResumesInput = {
    create?: XOR<UserCreateWithoutResumesInput, UserUncheckedCreateWithoutResumesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesInput
    connect?: UserWhereUniqueInput
  }

  export type TailoringAnalyticsCreateNestedManyWithoutResumeInput = {
    create?: XOR<TailoringAnalyticsCreateWithoutResumeInput, TailoringAnalyticsUncheckedCreateWithoutResumeInput> | TailoringAnalyticsCreateWithoutResumeInput[] | TailoringAnalyticsUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringAnalyticsCreateOrConnectWithoutResumeInput | TailoringAnalyticsCreateOrConnectWithoutResumeInput[]
    createMany?: TailoringAnalyticsCreateManyResumeInputEnvelope
    connect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
  }

  export type ScrubbedResumeCreateNestedOneWithoutResumeInput = {
    create?: XOR<ScrubbedResumeCreateWithoutResumeInput, ScrubbedResumeUncheckedCreateWithoutResumeInput>
    connectOrCreate?: ScrubbedResumeCreateOrConnectWithoutResumeInput
    connect?: ScrubbedResumeWhereUniqueInput
  }

  export type PromptArchiveCreateNestedManyWithoutResumeInput = {
    create?: XOR<PromptArchiveCreateWithoutResumeInput, PromptArchiveUncheckedCreateWithoutResumeInput> | PromptArchiveCreateWithoutResumeInput[] | PromptArchiveUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PromptArchiveCreateOrConnectWithoutResumeInput | PromptArchiveCreateOrConnectWithoutResumeInput[]
    createMany?: PromptArchiveCreateManyResumeInputEnvelope
    connect?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
  }

  export type ResumeInteractionCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeInteractionCreateWithoutResumeInput, ResumeInteractionUncheckedCreateWithoutResumeInput> | ResumeInteractionCreateWithoutResumeInput[] | ResumeInteractionUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeInteractionCreateOrConnectWithoutResumeInput | ResumeInteractionCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeInteractionCreateManyResumeInputEnvelope
    connect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
  }

  export type ResumeTagCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeTagCreateWithoutResumeInput, ResumeTagUncheckedCreateWithoutResumeInput> | ResumeTagCreateWithoutResumeInput[] | ResumeTagUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeTagCreateOrConnectWithoutResumeInput | ResumeTagCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeTagCreateManyResumeInputEnvelope
    connect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
  }

  export type ResumeMetadataCreateNestedOneWithoutResumeInput = {
    create?: XOR<ResumeMetadataCreateWithoutResumeInput, ResumeMetadataUncheckedCreateWithoutResumeInput>
    connectOrCreate?: ResumeMetadataCreateOrConnectWithoutResumeInput
    connect?: ResumeMetadataWhereUniqueInput
  }

  export type TailoringPromptCreateNestedManyWithoutResumeInput = {
    create?: XOR<TailoringPromptCreateWithoutResumeInput, TailoringPromptUncheckedCreateWithoutResumeInput> | TailoringPromptCreateWithoutResumeInput[] | TailoringPromptUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringPromptCreateOrConnectWithoutResumeInput | TailoringPromptCreateOrConnectWithoutResumeInput[]
    createMany?: TailoringPromptCreateManyResumeInputEnvelope
    connect?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
  }

  export type CoverLetterCreateNestedManyWithoutResumeInput = {
    create?: XOR<CoverLetterCreateWithoutResumeInput, CoverLetterUncheckedCreateWithoutResumeInput> | CoverLetterCreateWithoutResumeInput[] | CoverLetterUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: CoverLetterCreateOrConnectWithoutResumeInput | CoverLetterCreateOrConnectWithoutResumeInput[]
    createMany?: CoverLetterCreateManyResumeInputEnvelope
    connect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
  }

  export type ResumeExportCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeExportCreateWithoutResumeInput, ResumeExportUncheckedCreateWithoutResumeInput> | ResumeExportCreateWithoutResumeInput[] | ResumeExportUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeExportCreateOrConnectWithoutResumeInput | ResumeExportCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeExportCreateManyResumeInputEnvelope
    connect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
  }

  export type TailoringProgressCreateNestedManyWithoutResumeInput = {
    create?: XOR<TailoringProgressCreateWithoutResumeInput, TailoringProgressUncheckedCreateWithoutResumeInput> | TailoringProgressCreateWithoutResumeInput[] | TailoringProgressUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringProgressCreateOrConnectWithoutResumeInput | TailoringProgressCreateOrConnectWithoutResumeInput[]
    createMany?: TailoringProgressCreateManyResumeInputEnvelope
    connect?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
  }

  export type TailoringAttemptCreateNestedManyWithoutResumeInput = {
    create?: XOR<TailoringAttemptCreateWithoutResumeInput, TailoringAttemptUncheckedCreateWithoutResumeInput> | TailoringAttemptCreateWithoutResumeInput[] | TailoringAttemptUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringAttemptCreateOrConnectWithoutResumeInput | TailoringAttemptCreateOrConnectWithoutResumeInput[]
    createMany?: TailoringAttemptCreateManyResumeInputEnvelope
    connect?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
  }

  export type ManualEditCreateNestedManyWithoutResumeInput = {
    create?: XOR<ManualEditCreateWithoutResumeInput, ManualEditUncheckedCreateWithoutResumeInput> | ManualEditCreateWithoutResumeInput[] | ManualEditUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ManualEditCreateOrConnectWithoutResumeInput | ManualEditCreateOrConnectWithoutResumeInput[]
    createMany?: ManualEditCreateManyResumeInputEnvelope
    connect?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
  }

  export type ManualScoringCreateNestedManyWithoutResumeInput = {
    create?: XOR<ManualScoringCreateWithoutResumeInput, ManualScoringUncheckedCreateWithoutResumeInput> | ManualScoringCreateWithoutResumeInput[] | ManualScoringUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ManualScoringCreateOrConnectWithoutResumeInput | ManualScoringCreateOrConnectWithoutResumeInput[]
    createMany?: ManualScoringCreateManyResumeInputEnvelope
    connect?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
  }

  export type ResumeFeedbackCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeFeedbackCreateWithoutResumeInput, ResumeFeedbackUncheckedCreateWithoutResumeInput> | ResumeFeedbackCreateWithoutResumeInput[] | ResumeFeedbackUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeFeedbackCreateOrConnectWithoutResumeInput | ResumeFeedbackCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeFeedbackCreateManyResumeInputEnvelope
    connect?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
  }

  export type ResumeSectionRationaleCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeSectionRationaleCreateWithoutResumeInput, ResumeSectionRationaleUncheckedCreateWithoutResumeInput> | ResumeSectionRationaleCreateWithoutResumeInput[] | ResumeSectionRationaleUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeSectionRationaleCreateOrConnectWithoutResumeInput | ResumeSectionRationaleCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeSectionRationaleCreateManyResumeInputEnvelope
    connect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
  }

  export type TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<TailoringAnalyticsCreateWithoutResumeInput, TailoringAnalyticsUncheckedCreateWithoutResumeInput> | TailoringAnalyticsCreateWithoutResumeInput[] | TailoringAnalyticsUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringAnalyticsCreateOrConnectWithoutResumeInput | TailoringAnalyticsCreateOrConnectWithoutResumeInput[]
    createMany?: TailoringAnalyticsCreateManyResumeInputEnvelope
    connect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
  }

  export type ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput = {
    create?: XOR<ScrubbedResumeCreateWithoutResumeInput, ScrubbedResumeUncheckedCreateWithoutResumeInput>
    connectOrCreate?: ScrubbedResumeCreateOrConnectWithoutResumeInput
    connect?: ScrubbedResumeWhereUniqueInput
  }

  export type PromptArchiveUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<PromptArchiveCreateWithoutResumeInput, PromptArchiveUncheckedCreateWithoutResumeInput> | PromptArchiveCreateWithoutResumeInput[] | PromptArchiveUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PromptArchiveCreateOrConnectWithoutResumeInput | PromptArchiveCreateOrConnectWithoutResumeInput[]
    createMany?: PromptArchiveCreateManyResumeInputEnvelope
    connect?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
  }

  export type ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeInteractionCreateWithoutResumeInput, ResumeInteractionUncheckedCreateWithoutResumeInput> | ResumeInteractionCreateWithoutResumeInput[] | ResumeInteractionUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeInteractionCreateOrConnectWithoutResumeInput | ResumeInteractionCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeInteractionCreateManyResumeInputEnvelope
    connect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
  }

  export type ResumeTagUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeTagCreateWithoutResumeInput, ResumeTagUncheckedCreateWithoutResumeInput> | ResumeTagCreateWithoutResumeInput[] | ResumeTagUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeTagCreateOrConnectWithoutResumeInput | ResumeTagCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeTagCreateManyResumeInputEnvelope
    connect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
  }

  export type ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput = {
    create?: XOR<ResumeMetadataCreateWithoutResumeInput, ResumeMetadataUncheckedCreateWithoutResumeInput>
    connectOrCreate?: ResumeMetadataCreateOrConnectWithoutResumeInput
    connect?: ResumeMetadataWhereUniqueInput
  }

  export type TailoringPromptUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<TailoringPromptCreateWithoutResumeInput, TailoringPromptUncheckedCreateWithoutResumeInput> | TailoringPromptCreateWithoutResumeInput[] | TailoringPromptUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringPromptCreateOrConnectWithoutResumeInput | TailoringPromptCreateOrConnectWithoutResumeInput[]
    createMany?: TailoringPromptCreateManyResumeInputEnvelope
    connect?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
  }

  export type CoverLetterUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<CoverLetterCreateWithoutResumeInput, CoverLetterUncheckedCreateWithoutResumeInput> | CoverLetterCreateWithoutResumeInput[] | CoverLetterUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: CoverLetterCreateOrConnectWithoutResumeInput | CoverLetterCreateOrConnectWithoutResumeInput[]
    createMany?: CoverLetterCreateManyResumeInputEnvelope
    connect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
  }

  export type ResumeExportUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeExportCreateWithoutResumeInput, ResumeExportUncheckedCreateWithoutResumeInput> | ResumeExportCreateWithoutResumeInput[] | ResumeExportUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeExportCreateOrConnectWithoutResumeInput | ResumeExportCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeExportCreateManyResumeInputEnvelope
    connect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
  }

  export type TailoringProgressUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<TailoringProgressCreateWithoutResumeInput, TailoringProgressUncheckedCreateWithoutResumeInput> | TailoringProgressCreateWithoutResumeInput[] | TailoringProgressUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringProgressCreateOrConnectWithoutResumeInput | TailoringProgressCreateOrConnectWithoutResumeInput[]
    createMany?: TailoringProgressCreateManyResumeInputEnvelope
    connect?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
  }

  export type TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<TailoringAttemptCreateWithoutResumeInput, TailoringAttemptUncheckedCreateWithoutResumeInput> | TailoringAttemptCreateWithoutResumeInput[] | TailoringAttemptUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringAttemptCreateOrConnectWithoutResumeInput | TailoringAttemptCreateOrConnectWithoutResumeInput[]
    createMany?: TailoringAttemptCreateManyResumeInputEnvelope
    connect?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
  }

  export type ManualEditUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ManualEditCreateWithoutResumeInput, ManualEditUncheckedCreateWithoutResumeInput> | ManualEditCreateWithoutResumeInput[] | ManualEditUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ManualEditCreateOrConnectWithoutResumeInput | ManualEditCreateOrConnectWithoutResumeInput[]
    createMany?: ManualEditCreateManyResumeInputEnvelope
    connect?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
  }

  export type ManualScoringUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ManualScoringCreateWithoutResumeInput, ManualScoringUncheckedCreateWithoutResumeInput> | ManualScoringCreateWithoutResumeInput[] | ManualScoringUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ManualScoringCreateOrConnectWithoutResumeInput | ManualScoringCreateOrConnectWithoutResumeInput[]
    createMany?: ManualScoringCreateManyResumeInputEnvelope
    connect?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
  }

  export type ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeFeedbackCreateWithoutResumeInput, ResumeFeedbackUncheckedCreateWithoutResumeInput> | ResumeFeedbackCreateWithoutResumeInput[] | ResumeFeedbackUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeFeedbackCreateOrConnectWithoutResumeInput | ResumeFeedbackCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeFeedbackCreateManyResumeInputEnvelope
    connect?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
  }

  export type ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeSectionRationaleCreateWithoutResumeInput, ResumeSectionRationaleUncheckedCreateWithoutResumeInput> | ResumeSectionRationaleCreateWithoutResumeInput[] | ResumeSectionRationaleUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeSectionRationaleCreateOrConnectWithoutResumeInput | ResumeSectionRationaleCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeSectionRationaleCreateManyResumeInputEnvelope
    connect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutResumesNestedInput = {
    create?: XOR<UserCreateWithoutResumesInput, UserUncheckedCreateWithoutResumesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesInput
    upsert?: UserUpsertWithoutResumesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResumesInput, UserUpdateWithoutResumesInput>, UserUncheckedUpdateWithoutResumesInput>
  }

  export type TailoringAnalyticsUpdateManyWithoutResumeNestedInput = {
    create?: XOR<TailoringAnalyticsCreateWithoutResumeInput, TailoringAnalyticsUncheckedCreateWithoutResumeInput> | TailoringAnalyticsCreateWithoutResumeInput[] | TailoringAnalyticsUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringAnalyticsCreateOrConnectWithoutResumeInput | TailoringAnalyticsCreateOrConnectWithoutResumeInput[]
    upsert?: TailoringAnalyticsUpsertWithWhereUniqueWithoutResumeInput | TailoringAnalyticsUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: TailoringAnalyticsCreateManyResumeInputEnvelope
    set?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    disconnect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    delete?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    connect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    update?: TailoringAnalyticsUpdateWithWhereUniqueWithoutResumeInput | TailoringAnalyticsUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: TailoringAnalyticsUpdateManyWithWhereWithoutResumeInput | TailoringAnalyticsUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: TailoringAnalyticsScalarWhereInput | TailoringAnalyticsScalarWhereInput[]
  }

  export type ScrubbedResumeUpdateOneWithoutResumeNestedInput = {
    create?: XOR<ScrubbedResumeCreateWithoutResumeInput, ScrubbedResumeUncheckedCreateWithoutResumeInput>
    connectOrCreate?: ScrubbedResumeCreateOrConnectWithoutResumeInput
    upsert?: ScrubbedResumeUpsertWithoutResumeInput
    disconnect?: ScrubbedResumeWhereInput | boolean
    delete?: ScrubbedResumeWhereInput | boolean
    connect?: ScrubbedResumeWhereUniqueInput
    update?: XOR<XOR<ScrubbedResumeUpdateToOneWithWhereWithoutResumeInput, ScrubbedResumeUpdateWithoutResumeInput>, ScrubbedResumeUncheckedUpdateWithoutResumeInput>
  }

  export type PromptArchiveUpdateManyWithoutResumeNestedInput = {
    create?: XOR<PromptArchiveCreateWithoutResumeInput, PromptArchiveUncheckedCreateWithoutResumeInput> | PromptArchiveCreateWithoutResumeInput[] | PromptArchiveUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PromptArchiveCreateOrConnectWithoutResumeInput | PromptArchiveCreateOrConnectWithoutResumeInput[]
    upsert?: PromptArchiveUpsertWithWhereUniqueWithoutResumeInput | PromptArchiveUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: PromptArchiveCreateManyResumeInputEnvelope
    set?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
    disconnect?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
    delete?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
    connect?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
    update?: PromptArchiveUpdateWithWhereUniqueWithoutResumeInput | PromptArchiveUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: PromptArchiveUpdateManyWithWhereWithoutResumeInput | PromptArchiveUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: PromptArchiveScalarWhereInput | PromptArchiveScalarWhereInput[]
  }

  export type ResumeInteractionUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeInteractionCreateWithoutResumeInput, ResumeInteractionUncheckedCreateWithoutResumeInput> | ResumeInteractionCreateWithoutResumeInput[] | ResumeInteractionUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeInteractionCreateOrConnectWithoutResumeInput | ResumeInteractionCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeInteractionUpsertWithWhereUniqueWithoutResumeInput | ResumeInteractionUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeInteractionCreateManyResumeInputEnvelope
    set?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    disconnect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    delete?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    connect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    update?: ResumeInteractionUpdateWithWhereUniqueWithoutResumeInput | ResumeInteractionUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeInteractionUpdateManyWithWhereWithoutResumeInput | ResumeInteractionUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeInteractionScalarWhereInput | ResumeInteractionScalarWhereInput[]
  }

  export type ResumeTagUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeTagCreateWithoutResumeInput, ResumeTagUncheckedCreateWithoutResumeInput> | ResumeTagCreateWithoutResumeInput[] | ResumeTagUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeTagCreateOrConnectWithoutResumeInput | ResumeTagCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeTagUpsertWithWhereUniqueWithoutResumeInput | ResumeTagUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeTagCreateManyResumeInputEnvelope
    set?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    disconnect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    delete?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    connect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    update?: ResumeTagUpdateWithWhereUniqueWithoutResumeInput | ResumeTagUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeTagUpdateManyWithWhereWithoutResumeInput | ResumeTagUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeTagScalarWhereInput | ResumeTagScalarWhereInput[]
  }

  export type ResumeMetadataUpdateOneWithoutResumeNestedInput = {
    create?: XOR<ResumeMetadataCreateWithoutResumeInput, ResumeMetadataUncheckedCreateWithoutResumeInput>
    connectOrCreate?: ResumeMetadataCreateOrConnectWithoutResumeInput
    upsert?: ResumeMetadataUpsertWithoutResumeInput
    disconnect?: ResumeMetadataWhereInput | boolean
    delete?: ResumeMetadataWhereInput | boolean
    connect?: ResumeMetadataWhereUniqueInput
    update?: XOR<XOR<ResumeMetadataUpdateToOneWithWhereWithoutResumeInput, ResumeMetadataUpdateWithoutResumeInput>, ResumeMetadataUncheckedUpdateWithoutResumeInput>
  }

  export type TailoringPromptUpdateManyWithoutResumeNestedInput = {
    create?: XOR<TailoringPromptCreateWithoutResumeInput, TailoringPromptUncheckedCreateWithoutResumeInput> | TailoringPromptCreateWithoutResumeInput[] | TailoringPromptUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringPromptCreateOrConnectWithoutResumeInput | TailoringPromptCreateOrConnectWithoutResumeInput[]
    upsert?: TailoringPromptUpsertWithWhereUniqueWithoutResumeInput | TailoringPromptUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: TailoringPromptCreateManyResumeInputEnvelope
    set?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
    disconnect?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
    delete?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
    connect?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
    update?: TailoringPromptUpdateWithWhereUniqueWithoutResumeInput | TailoringPromptUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: TailoringPromptUpdateManyWithWhereWithoutResumeInput | TailoringPromptUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: TailoringPromptScalarWhereInput | TailoringPromptScalarWhereInput[]
  }

  export type CoverLetterUpdateManyWithoutResumeNestedInput = {
    create?: XOR<CoverLetterCreateWithoutResumeInput, CoverLetterUncheckedCreateWithoutResumeInput> | CoverLetterCreateWithoutResumeInput[] | CoverLetterUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: CoverLetterCreateOrConnectWithoutResumeInput | CoverLetterCreateOrConnectWithoutResumeInput[]
    upsert?: CoverLetterUpsertWithWhereUniqueWithoutResumeInput | CoverLetterUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: CoverLetterCreateManyResumeInputEnvelope
    set?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    disconnect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    delete?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    connect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    update?: CoverLetterUpdateWithWhereUniqueWithoutResumeInput | CoverLetterUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: CoverLetterUpdateManyWithWhereWithoutResumeInput | CoverLetterUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: CoverLetterScalarWhereInput | CoverLetterScalarWhereInput[]
  }

  export type ResumeExportUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeExportCreateWithoutResumeInput, ResumeExportUncheckedCreateWithoutResumeInput> | ResumeExportCreateWithoutResumeInput[] | ResumeExportUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeExportCreateOrConnectWithoutResumeInput | ResumeExportCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeExportUpsertWithWhereUniqueWithoutResumeInput | ResumeExportUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeExportCreateManyResumeInputEnvelope
    set?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    disconnect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    delete?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    connect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    update?: ResumeExportUpdateWithWhereUniqueWithoutResumeInput | ResumeExportUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeExportUpdateManyWithWhereWithoutResumeInput | ResumeExportUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeExportScalarWhereInput | ResumeExportScalarWhereInput[]
  }

  export type TailoringProgressUpdateManyWithoutResumeNestedInput = {
    create?: XOR<TailoringProgressCreateWithoutResumeInput, TailoringProgressUncheckedCreateWithoutResumeInput> | TailoringProgressCreateWithoutResumeInput[] | TailoringProgressUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringProgressCreateOrConnectWithoutResumeInput | TailoringProgressCreateOrConnectWithoutResumeInput[]
    upsert?: TailoringProgressUpsertWithWhereUniqueWithoutResumeInput | TailoringProgressUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: TailoringProgressCreateManyResumeInputEnvelope
    set?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
    disconnect?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
    delete?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
    connect?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
    update?: TailoringProgressUpdateWithWhereUniqueWithoutResumeInput | TailoringProgressUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: TailoringProgressUpdateManyWithWhereWithoutResumeInput | TailoringProgressUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: TailoringProgressScalarWhereInput | TailoringProgressScalarWhereInput[]
  }

  export type TailoringAttemptUpdateManyWithoutResumeNestedInput = {
    create?: XOR<TailoringAttemptCreateWithoutResumeInput, TailoringAttemptUncheckedCreateWithoutResumeInput> | TailoringAttemptCreateWithoutResumeInput[] | TailoringAttemptUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringAttemptCreateOrConnectWithoutResumeInput | TailoringAttemptCreateOrConnectWithoutResumeInput[]
    upsert?: TailoringAttemptUpsertWithWhereUniqueWithoutResumeInput | TailoringAttemptUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: TailoringAttemptCreateManyResumeInputEnvelope
    set?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
    disconnect?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
    delete?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
    connect?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
    update?: TailoringAttemptUpdateWithWhereUniqueWithoutResumeInput | TailoringAttemptUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: TailoringAttemptUpdateManyWithWhereWithoutResumeInput | TailoringAttemptUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: TailoringAttemptScalarWhereInput | TailoringAttemptScalarWhereInput[]
  }

  export type ManualEditUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ManualEditCreateWithoutResumeInput, ManualEditUncheckedCreateWithoutResumeInput> | ManualEditCreateWithoutResumeInput[] | ManualEditUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ManualEditCreateOrConnectWithoutResumeInput | ManualEditCreateOrConnectWithoutResumeInput[]
    upsert?: ManualEditUpsertWithWhereUniqueWithoutResumeInput | ManualEditUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ManualEditCreateManyResumeInputEnvelope
    set?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
    disconnect?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
    delete?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
    connect?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
    update?: ManualEditUpdateWithWhereUniqueWithoutResumeInput | ManualEditUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ManualEditUpdateManyWithWhereWithoutResumeInput | ManualEditUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ManualEditScalarWhereInput | ManualEditScalarWhereInput[]
  }

  export type ManualScoringUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ManualScoringCreateWithoutResumeInput, ManualScoringUncheckedCreateWithoutResumeInput> | ManualScoringCreateWithoutResumeInput[] | ManualScoringUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ManualScoringCreateOrConnectWithoutResumeInput | ManualScoringCreateOrConnectWithoutResumeInput[]
    upsert?: ManualScoringUpsertWithWhereUniqueWithoutResumeInput | ManualScoringUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ManualScoringCreateManyResumeInputEnvelope
    set?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
    disconnect?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
    delete?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
    connect?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
    update?: ManualScoringUpdateWithWhereUniqueWithoutResumeInput | ManualScoringUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ManualScoringUpdateManyWithWhereWithoutResumeInput | ManualScoringUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ManualScoringScalarWhereInput | ManualScoringScalarWhereInput[]
  }

  export type ResumeFeedbackUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeFeedbackCreateWithoutResumeInput, ResumeFeedbackUncheckedCreateWithoutResumeInput> | ResumeFeedbackCreateWithoutResumeInput[] | ResumeFeedbackUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeFeedbackCreateOrConnectWithoutResumeInput | ResumeFeedbackCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeFeedbackUpsertWithWhereUniqueWithoutResumeInput | ResumeFeedbackUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeFeedbackCreateManyResumeInputEnvelope
    set?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
    disconnect?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
    delete?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
    connect?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
    update?: ResumeFeedbackUpdateWithWhereUniqueWithoutResumeInput | ResumeFeedbackUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeFeedbackUpdateManyWithWhereWithoutResumeInput | ResumeFeedbackUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeFeedbackScalarWhereInput | ResumeFeedbackScalarWhereInput[]
  }

  export type ResumeSectionRationaleUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeSectionRationaleCreateWithoutResumeInput, ResumeSectionRationaleUncheckedCreateWithoutResumeInput> | ResumeSectionRationaleCreateWithoutResumeInput[] | ResumeSectionRationaleUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeSectionRationaleCreateOrConnectWithoutResumeInput | ResumeSectionRationaleCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeSectionRationaleUpsertWithWhereUniqueWithoutResumeInput | ResumeSectionRationaleUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeSectionRationaleCreateManyResumeInputEnvelope
    set?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    disconnect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    delete?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    connect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    update?: ResumeSectionRationaleUpdateWithWhereUniqueWithoutResumeInput | ResumeSectionRationaleUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeSectionRationaleUpdateManyWithWhereWithoutResumeInput | ResumeSectionRationaleUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeSectionRationaleScalarWhereInput | ResumeSectionRationaleScalarWhereInput[]
  }

  export type TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<TailoringAnalyticsCreateWithoutResumeInput, TailoringAnalyticsUncheckedCreateWithoutResumeInput> | TailoringAnalyticsCreateWithoutResumeInput[] | TailoringAnalyticsUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringAnalyticsCreateOrConnectWithoutResumeInput | TailoringAnalyticsCreateOrConnectWithoutResumeInput[]
    upsert?: TailoringAnalyticsUpsertWithWhereUniqueWithoutResumeInput | TailoringAnalyticsUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: TailoringAnalyticsCreateManyResumeInputEnvelope
    set?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    disconnect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    delete?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    connect?: TailoringAnalyticsWhereUniqueInput | TailoringAnalyticsWhereUniqueInput[]
    update?: TailoringAnalyticsUpdateWithWhereUniqueWithoutResumeInput | TailoringAnalyticsUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: TailoringAnalyticsUpdateManyWithWhereWithoutResumeInput | TailoringAnalyticsUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: TailoringAnalyticsScalarWhereInput | TailoringAnalyticsScalarWhereInput[]
  }

  export type ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput = {
    create?: XOR<ScrubbedResumeCreateWithoutResumeInput, ScrubbedResumeUncheckedCreateWithoutResumeInput>
    connectOrCreate?: ScrubbedResumeCreateOrConnectWithoutResumeInput
    upsert?: ScrubbedResumeUpsertWithoutResumeInput
    disconnect?: ScrubbedResumeWhereInput | boolean
    delete?: ScrubbedResumeWhereInput | boolean
    connect?: ScrubbedResumeWhereUniqueInput
    update?: XOR<XOR<ScrubbedResumeUpdateToOneWithWhereWithoutResumeInput, ScrubbedResumeUpdateWithoutResumeInput>, ScrubbedResumeUncheckedUpdateWithoutResumeInput>
  }

  export type PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<PromptArchiveCreateWithoutResumeInput, PromptArchiveUncheckedCreateWithoutResumeInput> | PromptArchiveCreateWithoutResumeInput[] | PromptArchiveUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: PromptArchiveCreateOrConnectWithoutResumeInput | PromptArchiveCreateOrConnectWithoutResumeInput[]
    upsert?: PromptArchiveUpsertWithWhereUniqueWithoutResumeInput | PromptArchiveUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: PromptArchiveCreateManyResumeInputEnvelope
    set?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
    disconnect?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
    delete?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
    connect?: PromptArchiveWhereUniqueInput | PromptArchiveWhereUniqueInput[]
    update?: PromptArchiveUpdateWithWhereUniqueWithoutResumeInput | PromptArchiveUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: PromptArchiveUpdateManyWithWhereWithoutResumeInput | PromptArchiveUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: PromptArchiveScalarWhereInput | PromptArchiveScalarWhereInput[]
  }

  export type ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeInteractionCreateWithoutResumeInput, ResumeInteractionUncheckedCreateWithoutResumeInput> | ResumeInteractionCreateWithoutResumeInput[] | ResumeInteractionUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeInteractionCreateOrConnectWithoutResumeInput | ResumeInteractionCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeInteractionUpsertWithWhereUniqueWithoutResumeInput | ResumeInteractionUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeInteractionCreateManyResumeInputEnvelope
    set?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    disconnect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    delete?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    connect?: ResumeInteractionWhereUniqueInput | ResumeInteractionWhereUniqueInput[]
    update?: ResumeInteractionUpdateWithWhereUniqueWithoutResumeInput | ResumeInteractionUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeInteractionUpdateManyWithWhereWithoutResumeInput | ResumeInteractionUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeInteractionScalarWhereInput | ResumeInteractionScalarWhereInput[]
  }

  export type ResumeTagUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeTagCreateWithoutResumeInput, ResumeTagUncheckedCreateWithoutResumeInput> | ResumeTagCreateWithoutResumeInput[] | ResumeTagUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeTagCreateOrConnectWithoutResumeInput | ResumeTagCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeTagUpsertWithWhereUniqueWithoutResumeInput | ResumeTagUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeTagCreateManyResumeInputEnvelope
    set?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    disconnect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    delete?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    connect?: ResumeTagWhereUniqueInput | ResumeTagWhereUniqueInput[]
    update?: ResumeTagUpdateWithWhereUniqueWithoutResumeInput | ResumeTagUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeTagUpdateManyWithWhereWithoutResumeInput | ResumeTagUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeTagScalarWhereInput | ResumeTagScalarWhereInput[]
  }

  export type ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput = {
    create?: XOR<ResumeMetadataCreateWithoutResumeInput, ResumeMetadataUncheckedCreateWithoutResumeInput>
    connectOrCreate?: ResumeMetadataCreateOrConnectWithoutResumeInput
    upsert?: ResumeMetadataUpsertWithoutResumeInput
    disconnect?: ResumeMetadataWhereInput | boolean
    delete?: ResumeMetadataWhereInput | boolean
    connect?: ResumeMetadataWhereUniqueInput
    update?: XOR<XOR<ResumeMetadataUpdateToOneWithWhereWithoutResumeInput, ResumeMetadataUpdateWithoutResumeInput>, ResumeMetadataUncheckedUpdateWithoutResumeInput>
  }

  export type TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<TailoringPromptCreateWithoutResumeInput, TailoringPromptUncheckedCreateWithoutResumeInput> | TailoringPromptCreateWithoutResumeInput[] | TailoringPromptUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringPromptCreateOrConnectWithoutResumeInput | TailoringPromptCreateOrConnectWithoutResumeInput[]
    upsert?: TailoringPromptUpsertWithWhereUniqueWithoutResumeInput | TailoringPromptUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: TailoringPromptCreateManyResumeInputEnvelope
    set?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
    disconnect?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
    delete?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
    connect?: TailoringPromptWhereUniqueInput | TailoringPromptWhereUniqueInput[]
    update?: TailoringPromptUpdateWithWhereUniqueWithoutResumeInput | TailoringPromptUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: TailoringPromptUpdateManyWithWhereWithoutResumeInput | TailoringPromptUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: TailoringPromptScalarWhereInput | TailoringPromptScalarWhereInput[]
  }

  export type CoverLetterUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<CoverLetterCreateWithoutResumeInput, CoverLetterUncheckedCreateWithoutResumeInput> | CoverLetterCreateWithoutResumeInput[] | CoverLetterUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: CoverLetterCreateOrConnectWithoutResumeInput | CoverLetterCreateOrConnectWithoutResumeInput[]
    upsert?: CoverLetterUpsertWithWhereUniqueWithoutResumeInput | CoverLetterUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: CoverLetterCreateManyResumeInputEnvelope
    set?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    disconnect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    delete?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    connect?: CoverLetterWhereUniqueInput | CoverLetterWhereUniqueInput[]
    update?: CoverLetterUpdateWithWhereUniqueWithoutResumeInput | CoverLetterUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: CoverLetterUpdateManyWithWhereWithoutResumeInput | CoverLetterUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: CoverLetterScalarWhereInput | CoverLetterScalarWhereInput[]
  }

  export type ResumeExportUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeExportCreateWithoutResumeInput, ResumeExportUncheckedCreateWithoutResumeInput> | ResumeExportCreateWithoutResumeInput[] | ResumeExportUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeExportCreateOrConnectWithoutResumeInput | ResumeExportCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeExportUpsertWithWhereUniqueWithoutResumeInput | ResumeExportUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeExportCreateManyResumeInputEnvelope
    set?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    disconnect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    delete?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    connect?: ResumeExportWhereUniqueInput | ResumeExportWhereUniqueInput[]
    update?: ResumeExportUpdateWithWhereUniqueWithoutResumeInput | ResumeExportUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeExportUpdateManyWithWhereWithoutResumeInput | ResumeExportUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeExportScalarWhereInput | ResumeExportScalarWhereInput[]
  }

  export type TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<TailoringProgressCreateWithoutResumeInput, TailoringProgressUncheckedCreateWithoutResumeInput> | TailoringProgressCreateWithoutResumeInput[] | TailoringProgressUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringProgressCreateOrConnectWithoutResumeInput | TailoringProgressCreateOrConnectWithoutResumeInput[]
    upsert?: TailoringProgressUpsertWithWhereUniqueWithoutResumeInput | TailoringProgressUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: TailoringProgressCreateManyResumeInputEnvelope
    set?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
    disconnect?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
    delete?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
    connect?: TailoringProgressWhereUniqueInput | TailoringProgressWhereUniqueInput[]
    update?: TailoringProgressUpdateWithWhereUniqueWithoutResumeInput | TailoringProgressUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: TailoringProgressUpdateManyWithWhereWithoutResumeInput | TailoringProgressUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: TailoringProgressScalarWhereInput | TailoringProgressScalarWhereInput[]
  }

  export type TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<TailoringAttemptCreateWithoutResumeInput, TailoringAttemptUncheckedCreateWithoutResumeInput> | TailoringAttemptCreateWithoutResumeInput[] | TailoringAttemptUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: TailoringAttemptCreateOrConnectWithoutResumeInput | TailoringAttemptCreateOrConnectWithoutResumeInput[]
    upsert?: TailoringAttemptUpsertWithWhereUniqueWithoutResumeInput | TailoringAttemptUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: TailoringAttemptCreateManyResumeInputEnvelope
    set?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
    disconnect?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
    delete?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
    connect?: TailoringAttemptWhereUniqueInput | TailoringAttemptWhereUniqueInput[]
    update?: TailoringAttemptUpdateWithWhereUniqueWithoutResumeInput | TailoringAttemptUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: TailoringAttemptUpdateManyWithWhereWithoutResumeInput | TailoringAttemptUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: TailoringAttemptScalarWhereInput | TailoringAttemptScalarWhereInput[]
  }

  export type ManualEditUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ManualEditCreateWithoutResumeInput, ManualEditUncheckedCreateWithoutResumeInput> | ManualEditCreateWithoutResumeInput[] | ManualEditUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ManualEditCreateOrConnectWithoutResumeInput | ManualEditCreateOrConnectWithoutResumeInput[]
    upsert?: ManualEditUpsertWithWhereUniqueWithoutResumeInput | ManualEditUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ManualEditCreateManyResumeInputEnvelope
    set?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
    disconnect?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
    delete?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
    connect?: ManualEditWhereUniqueInput | ManualEditWhereUniqueInput[]
    update?: ManualEditUpdateWithWhereUniqueWithoutResumeInput | ManualEditUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ManualEditUpdateManyWithWhereWithoutResumeInput | ManualEditUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ManualEditScalarWhereInput | ManualEditScalarWhereInput[]
  }

  export type ManualScoringUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ManualScoringCreateWithoutResumeInput, ManualScoringUncheckedCreateWithoutResumeInput> | ManualScoringCreateWithoutResumeInput[] | ManualScoringUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ManualScoringCreateOrConnectWithoutResumeInput | ManualScoringCreateOrConnectWithoutResumeInput[]
    upsert?: ManualScoringUpsertWithWhereUniqueWithoutResumeInput | ManualScoringUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ManualScoringCreateManyResumeInputEnvelope
    set?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
    disconnect?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
    delete?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
    connect?: ManualScoringWhereUniqueInput | ManualScoringWhereUniqueInput[]
    update?: ManualScoringUpdateWithWhereUniqueWithoutResumeInput | ManualScoringUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ManualScoringUpdateManyWithWhereWithoutResumeInput | ManualScoringUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ManualScoringScalarWhereInput | ManualScoringScalarWhereInput[]
  }

  export type ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeFeedbackCreateWithoutResumeInput, ResumeFeedbackUncheckedCreateWithoutResumeInput> | ResumeFeedbackCreateWithoutResumeInput[] | ResumeFeedbackUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeFeedbackCreateOrConnectWithoutResumeInput | ResumeFeedbackCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeFeedbackUpsertWithWhereUniqueWithoutResumeInput | ResumeFeedbackUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeFeedbackCreateManyResumeInputEnvelope
    set?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
    disconnect?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
    delete?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
    connect?: ResumeFeedbackWhereUniqueInput | ResumeFeedbackWhereUniqueInput[]
    update?: ResumeFeedbackUpdateWithWhereUniqueWithoutResumeInput | ResumeFeedbackUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeFeedbackUpdateManyWithWhereWithoutResumeInput | ResumeFeedbackUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeFeedbackScalarWhereInput | ResumeFeedbackScalarWhereInput[]
  }

  export type ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeSectionRationaleCreateWithoutResumeInput, ResumeSectionRationaleUncheckedCreateWithoutResumeInput> | ResumeSectionRationaleCreateWithoutResumeInput[] | ResumeSectionRationaleUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeSectionRationaleCreateOrConnectWithoutResumeInput | ResumeSectionRationaleCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeSectionRationaleUpsertWithWhereUniqueWithoutResumeInput | ResumeSectionRationaleUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeSectionRationaleCreateManyResumeInputEnvelope
    set?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    disconnect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    delete?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    connect?: ResumeSectionRationaleWhereUniqueInput | ResumeSectionRationaleWhereUniqueInput[]
    update?: ResumeSectionRationaleUpdateWithWhereUniqueWithoutResumeInput | ResumeSectionRationaleUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeSectionRationaleUpdateManyWithWhereWithoutResumeInput | ResumeSectionRationaleUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeSectionRationaleScalarWhereInput | ResumeSectionRationaleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<ResumeCreateWithoutAnalyticsInput, ResumeUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutAnalyticsInput
    connect?: ResumeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsInput
    upsert?: UserUpsertWithoutAnalyticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalyticsInput, UserUpdateWithoutAnalyticsInput>, UserUncheckedUpdateWithoutAnalyticsInput>
  }

  export type ResumeUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<ResumeCreateWithoutAnalyticsInput, ResumeUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutAnalyticsInput
    upsert?: ResumeUpsertWithoutAnalyticsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutAnalyticsInput, ResumeUpdateWithoutAnalyticsInput>, ResumeUncheckedUpdateWithoutAnalyticsInput>
  }

  export type ResumeCreateNestedOneWithoutScrubbedResumeInput = {
    create?: XOR<ResumeCreateWithoutScrubbedResumeInput, ResumeUncheckedCreateWithoutScrubbedResumeInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutScrubbedResumeInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutScrubbedResumeNestedInput = {
    create?: XOR<ResumeCreateWithoutScrubbedResumeInput, ResumeUncheckedCreateWithoutScrubbedResumeInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutScrubbedResumeInput
    upsert?: ResumeUpsertWithoutScrubbedResumeInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutScrubbedResumeInput, ResumeUpdateWithoutScrubbedResumeInput>, ResumeUncheckedUpdateWithoutScrubbedResumeInput>
  }

  export type ResumeCreateNestedOneWithoutPromptArchivesInput = {
    create?: XOR<ResumeCreateWithoutPromptArchivesInput, ResumeUncheckedCreateWithoutPromptArchivesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutPromptArchivesInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutPromptArchivesNestedInput = {
    create?: XOR<ResumeCreateWithoutPromptArchivesInput, ResumeUncheckedCreateWithoutPromptArchivesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutPromptArchivesInput
    upsert?: ResumeUpsertWithoutPromptArchivesInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutPromptArchivesInput, ResumeUpdateWithoutPromptArchivesInput>, ResumeUncheckedUpdateWithoutPromptArchivesInput>
  }

  export type UserCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInteractionsInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<ResumeCreateWithoutInteractionsInput, ResumeUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutInteractionsInput
    connect?: ResumeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInteractionsInput
    upsert?: UserUpsertWithoutInteractionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInteractionsInput, UserUpdateWithoutInteractionsInput>, UserUncheckedUpdateWithoutInteractionsInput>
  }

  export type ResumeUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<ResumeCreateWithoutInteractionsInput, ResumeUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutInteractionsInput
    upsert?: ResumeUpsertWithoutInteractionsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutInteractionsInput, ResumeUpdateWithoutInteractionsInput>, ResumeUncheckedUpdateWithoutInteractionsInput>
  }

  export type UserCreateNestedOneWithoutResumeTagInput = {
    create?: XOR<UserCreateWithoutResumeTagInput, UserUncheckedCreateWithoutResumeTagInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumeTagInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutTagsInput = {
    create?: XOR<ResumeCreateWithoutTagsInput, ResumeUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTagsInput
    connect?: ResumeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResumeTagNestedInput = {
    create?: XOR<UserCreateWithoutResumeTagInput, UserUncheckedCreateWithoutResumeTagInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumeTagInput
    upsert?: UserUpsertWithoutResumeTagInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResumeTagInput, UserUpdateWithoutResumeTagInput>, UserUncheckedUpdateWithoutResumeTagInput>
  }

  export type ResumeUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ResumeCreateWithoutTagsInput, ResumeUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTagsInput
    upsert?: ResumeUpsertWithoutTagsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutTagsInput, ResumeUpdateWithoutTagsInput>, ResumeUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutResumeMetadataInput = {
    create?: XOR<UserCreateWithoutResumeMetadataInput, UserUncheckedCreateWithoutResumeMetadataInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumeMetadataInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutMetadataInput = {
    create?: XOR<ResumeCreateWithoutMetadataInput, ResumeUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutMetadataInput
    connect?: ResumeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResumeMetadataNestedInput = {
    create?: XOR<UserCreateWithoutResumeMetadataInput, UserUncheckedCreateWithoutResumeMetadataInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumeMetadataInput
    upsert?: UserUpsertWithoutResumeMetadataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResumeMetadataInput, UserUpdateWithoutResumeMetadataInput>, UserUncheckedUpdateWithoutResumeMetadataInput>
  }

  export type ResumeUpdateOneRequiredWithoutMetadataNestedInput = {
    create?: XOR<ResumeCreateWithoutMetadataInput, ResumeUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutMetadataInput
    upsert?: ResumeUpsertWithoutMetadataInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutMetadataInput, ResumeUpdateWithoutMetadataInput>, ResumeUncheckedUpdateWithoutMetadataInput>
  }

  export type ResumeCreateNestedOneWithoutTailoringPromptsInput = {
    create?: XOR<ResumeCreateWithoutTailoringPromptsInput, ResumeUncheckedCreateWithoutTailoringPromptsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTailoringPromptsInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutTailoringPromptsNestedInput = {
    create?: XOR<ResumeCreateWithoutTailoringPromptsInput, ResumeUncheckedCreateWithoutTailoringPromptsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTailoringPromptsInput
    upsert?: ResumeUpsertWithoutTailoringPromptsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutTailoringPromptsInput, ResumeUpdateWithoutTailoringPromptsInput>, ResumeUncheckedUpdateWithoutTailoringPromptsInput>
  }

  export type ResumeCreateNestedOneWithoutTailoringProgressInput = {
    create?: XOR<ResumeCreateWithoutTailoringProgressInput, ResumeUncheckedCreateWithoutTailoringProgressInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTailoringProgressInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutTailoringProgressNestedInput = {
    create?: XOR<ResumeCreateWithoutTailoringProgressInput, ResumeUncheckedCreateWithoutTailoringProgressInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTailoringProgressInput
    upsert?: ResumeUpsertWithoutTailoringProgressInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutTailoringProgressInput, ResumeUpdateWithoutTailoringProgressInput>, ResumeUncheckedUpdateWithoutTailoringProgressInput>
  }

  export type ResumeCreateNestedOneWithoutTailoringAttemptsInput = {
    create?: XOR<ResumeCreateWithoutTailoringAttemptsInput, ResumeUncheckedCreateWithoutTailoringAttemptsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTailoringAttemptsInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutTailoringAttemptsNestedInput = {
    create?: XOR<ResumeCreateWithoutTailoringAttemptsInput, ResumeUncheckedCreateWithoutTailoringAttemptsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutTailoringAttemptsInput
    upsert?: ResumeUpsertWithoutTailoringAttemptsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutTailoringAttemptsInput, ResumeUpdateWithoutTailoringAttemptsInput>, ResumeUncheckedUpdateWithoutTailoringAttemptsInput>
  }

  export type ResumeFeedbackCreatefeedbackPointsInput = {
    set: string[]
  }

  export type ResumeCreateNestedOneWithoutResumeFeedbackInput = {
    create?: XOR<ResumeCreateWithoutResumeFeedbackInput, ResumeUncheckedCreateWithoutResumeFeedbackInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutResumeFeedbackInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeFeedbackUpdatefeedbackPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResumeUpdateOneRequiredWithoutResumeFeedbackNestedInput = {
    create?: XOR<ResumeCreateWithoutResumeFeedbackInput, ResumeUncheckedCreateWithoutResumeFeedbackInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutResumeFeedbackInput
    upsert?: ResumeUpsertWithoutResumeFeedbackInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutResumeFeedbackInput, ResumeUpdateWithoutResumeFeedbackInput>, ResumeUncheckedUpdateWithoutResumeFeedbackInput>
  }

  export type ResumeCreateNestedOneWithoutManualEditsInput = {
    create?: XOR<ResumeCreateWithoutManualEditsInput, ResumeUncheckedCreateWithoutManualEditsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutManualEditsInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutManualEditsNestedInput = {
    create?: XOR<ResumeCreateWithoutManualEditsInput, ResumeUncheckedCreateWithoutManualEditsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutManualEditsInput
    upsert?: ResumeUpsertWithoutManualEditsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutManualEditsInput, ResumeUpdateWithoutManualEditsInput>, ResumeUncheckedUpdateWithoutManualEditsInput>
  }

  export type ResumeCreateNestedOneWithoutManualScoringsInput = {
    create?: XOR<ResumeCreateWithoutManualScoringsInput, ResumeUncheckedCreateWithoutManualScoringsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutManualScoringsInput
    connect?: ResumeWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutManualScoringsNestedInput = {
    create?: XOR<ResumeCreateWithoutManualScoringsInput, ResumeUncheckedCreateWithoutManualScoringsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutManualScoringsInput
    upsert?: ResumeUpsertWithoutManualScoringsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutManualScoringsInput, ResumeUpdateWithoutManualScoringsInput>, ResumeUncheckedUpdateWithoutManualScoringsInput>
  }

  export type UserCreateNestedOneWithoutCoverLettersInput = {
    create?: XOR<UserCreateWithoutCoverLettersInput, UserUncheckedCreateWithoutCoverLettersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoverLettersInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutCoverLettersInput = {
    create?: XOR<ResumeCreateWithoutCoverLettersInput, ResumeUncheckedCreateWithoutCoverLettersInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutCoverLettersInput
    connect?: ResumeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCoverLettersNestedInput = {
    create?: XOR<UserCreateWithoutCoverLettersInput, UserUncheckedCreateWithoutCoverLettersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoverLettersInput
    upsert?: UserUpsertWithoutCoverLettersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoverLettersInput, UserUpdateWithoutCoverLettersInput>, UserUncheckedUpdateWithoutCoverLettersInput>
  }

  export type ResumeUpdateOneRequiredWithoutCoverLettersNestedInput = {
    create?: XOR<ResumeCreateWithoutCoverLettersInput, ResumeUncheckedCreateWithoutCoverLettersInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutCoverLettersInput
    upsert?: ResumeUpsertWithoutCoverLettersInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutCoverLettersInput, ResumeUpdateWithoutCoverLettersInput>, ResumeUncheckedUpdateWithoutCoverLettersInput>
  }

  export type UserCreateNestedOneWithoutLinkedInOptimizationsInput = {
    create?: XOR<UserCreateWithoutLinkedInOptimizationsInput, UserUncheckedCreateWithoutLinkedInOptimizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinkedInOptimizationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLinkedInOptimizationsNestedInput = {
    create?: XOR<UserCreateWithoutLinkedInOptimizationsInput, UserUncheckedCreateWithoutLinkedInOptimizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinkedInOptimizationsInput
    upsert?: UserUpsertWithoutLinkedInOptimizationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLinkedInOptimizationsInput, UserUpdateWithoutLinkedInOptimizationsInput>, UserUncheckedUpdateWithoutLinkedInOptimizationsInput>
  }

  export type InterviewSessionCreateselectedTypesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutInterviewSessionsInput = {
    create?: XOR<UserCreateWithoutInterviewSessionsInput, UserUncheckedCreateWithoutInterviewSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type InterviewSessionUpdateselectedTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutInterviewSessionsNestedInput = {
    create?: XOR<UserCreateWithoutInterviewSessionsInput, UserUncheckedCreateWithoutInterviewSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewSessionsInput
    upsert?: UserUpsertWithoutInterviewSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterviewSessionsInput, UserUpdateWithoutInterviewSessionsInput>, UserUncheckedUpdateWithoutInterviewSessionsInput>
  }

  export type UserCreateNestedOneWithoutResumeExportsInput = {
    create?: XOR<UserCreateWithoutResumeExportsInput, UserUncheckedCreateWithoutResumeExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumeExportsInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutExportsInput = {
    create?: XOR<ResumeCreateWithoutExportsInput, ResumeUncheckedCreateWithoutExportsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutExportsInput
    connect?: ResumeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResumeExportsNestedInput = {
    create?: XOR<UserCreateWithoutResumeExportsInput, UserUncheckedCreateWithoutResumeExportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumeExportsInput
    upsert?: UserUpsertWithoutResumeExportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResumeExportsInput, UserUpdateWithoutResumeExportsInput>, UserUncheckedUpdateWithoutResumeExportsInput>
  }

  export type ResumeUpdateOneRequiredWithoutExportsNestedInput = {
    create?: XOR<ResumeCreateWithoutExportsInput, ResumeUncheckedCreateWithoutExportsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutExportsInput
    upsert?: ResumeUpsertWithoutExportsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutExportsInput, ResumeUpdateWithoutExportsInput>, ResumeUncheckedUpdateWithoutExportsInput>
  }

  export type JobDescriptionIntelligenceCreatekeywordsInput = {
    set: string[]
  }

  export type JobDescriptionIntelligenceCreateresponsibilitiesInput = {
    set: string[]
  }

  export type JobDescriptionIntelligenceCreatequalificationsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutJdIntelligenceInput = {
    create?: XOR<UserCreateWithoutJdIntelligenceInput, UserUncheckedCreateWithoutJdIntelligenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutJdIntelligenceInput
    connect?: UserWhereUniqueInput
  }

  export type JobDescriptionIntelligenceUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobDescriptionIntelligenceUpdateresponsibilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobDescriptionIntelligenceUpdatequalificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutJdIntelligenceNestedInput = {
    create?: XOR<UserCreateWithoutJdIntelligenceInput, UserUncheckedCreateWithoutJdIntelligenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutJdIntelligenceInput
    upsert?: UserUpsertWithoutJdIntelligenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJdIntelligenceInput, UserUpdateWithoutJdIntelligenceInput>, UserUncheckedUpdateWithoutJdIntelligenceInput>
  }

  export type ResumeCreateNestedOneWithoutResumeSectionRationaleInput = {
    create?: XOR<ResumeCreateWithoutResumeSectionRationaleInput, ResumeUncheckedCreateWithoutResumeSectionRationaleInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutResumeSectionRationaleInput
    connect?: ResumeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResumeSectionRationaleInput = {
    create?: XOR<UserCreateWithoutResumeSectionRationaleInput, UserUncheckedCreateWithoutResumeSectionRationaleInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumeSectionRationaleInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutResumeSectionRationaleNestedInput = {
    create?: XOR<ResumeCreateWithoutResumeSectionRationaleInput, ResumeUncheckedCreateWithoutResumeSectionRationaleInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutResumeSectionRationaleInput
    upsert?: ResumeUpsertWithoutResumeSectionRationaleInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutResumeSectionRationaleInput, ResumeUpdateWithoutResumeSectionRationaleInput>, ResumeUncheckedUpdateWithoutResumeSectionRationaleInput>
  }

  export type UserUpdateOneRequiredWithoutResumeSectionRationaleNestedInput = {
    create?: XOR<UserCreateWithoutResumeSectionRationaleInput, UserUncheckedCreateWithoutResumeSectionRationaleInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumeSectionRationaleInput
    upsert?: UserUpsertWithoutResumeSectionRationaleInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResumeSectionRationaleInput, UserUpdateWithoutResumeSectionRationaleInput>, UserUncheckedUpdateWithoutResumeSectionRationaleInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ResumeCreateWithoutUserInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutUserInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutUserInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput>
  }

  export type ResumeCreateManyUserInputEnvelope = {
    data: ResumeCreateManyUserInput | ResumeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TailoringAnalyticsCreateWithoutUserInput = {
    id?: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
    resume: ResumeCreateNestedOneWithoutAnalyticsInput
  }

  export type TailoringAnalyticsUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
  }

  export type TailoringAnalyticsCreateOrConnectWithoutUserInput = {
    where: TailoringAnalyticsWhereUniqueInput
    create: XOR<TailoringAnalyticsCreateWithoutUserInput, TailoringAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type TailoringAnalyticsCreateManyUserInputEnvelope = {
    data: TailoringAnalyticsCreateManyUserInput | TailoringAnalyticsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResumeInteractionCreateWithoutUserInput = {
    id?: string
    action: string
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutInteractionsInput
  }

  export type ResumeInteractionUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    action: string
    createdAt?: Date | string
  }

  export type ResumeInteractionCreateOrConnectWithoutUserInput = {
    where: ResumeInteractionWhereUniqueInput
    create: XOR<ResumeInteractionCreateWithoutUserInput, ResumeInteractionUncheckedCreateWithoutUserInput>
  }

  export type ResumeInteractionCreateManyUserInputEnvelope = {
    data: ResumeInteractionCreateManyUserInput | ResumeInteractionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CoverLetterCreateWithoutUserInput = {
    id?: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    resume: ResumeCreateNestedOneWithoutCoverLettersInput
  }

  export type CoverLetterUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoverLetterCreateOrConnectWithoutUserInput = {
    where: CoverLetterWhereUniqueInput
    create: XOR<CoverLetterCreateWithoutUserInput, CoverLetterUncheckedCreateWithoutUserInput>
  }

  export type CoverLetterCreateManyUserInputEnvelope = {
    data: CoverLetterCreateManyUserInput | CoverLetterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LinkedInOptimizationCreateWithoutUserInput = {
    id?: string
    jobDescription: string
    originalAbout: string
    optimizedAbout: string
    tone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedInOptimizationUncheckedCreateWithoutUserInput = {
    id?: string
    jobDescription: string
    originalAbout: string
    optimizedAbout: string
    tone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedInOptimizationCreateOrConnectWithoutUserInput = {
    where: LinkedInOptimizationWhereUniqueInput
    create: XOR<LinkedInOptimizationCreateWithoutUserInput, LinkedInOptimizationUncheckedCreateWithoutUserInput>
  }

  export type LinkedInOptimizationCreateManyUserInputEnvelope = {
    data: LinkedInOptimizationCreateManyUserInput | LinkedInOptimizationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InterviewSessionCreateWithoutUserInput = {
    id?: string
    jobDescription: string
    selectedTypes?: InterviewSessionCreateselectedTypesInput | string[]
    questions: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSessionUncheckedCreateWithoutUserInput = {
    id?: string
    jobDescription: string
    selectedTypes?: InterviewSessionCreateselectedTypesInput | string[]
    questions: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSessionCreateOrConnectWithoutUserInput = {
    where: InterviewSessionWhereUniqueInput
    create: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput>
  }

  export type InterviewSessionCreateManyUserInputEnvelope = {
    data: InterviewSessionCreateManyUserInput | InterviewSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResumeExportCreateWithoutUserInput = {
    id?: string
    templateId: string
    format: string
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutExportsInput
  }

  export type ResumeExportUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    templateId: string
    format: string
    createdAt?: Date | string
  }

  export type ResumeExportCreateOrConnectWithoutUserInput = {
    where: ResumeExportWhereUniqueInput
    create: XOR<ResumeExportCreateWithoutUserInput, ResumeExportUncheckedCreateWithoutUserInput>
  }

  export type ResumeExportCreateManyUserInputEnvelope = {
    data: ResumeExportCreateManyUserInput | ResumeExportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JobDescriptionIntelligenceCreateWithoutUserInput = {
    id?: string
    resumeId?: string | null
    role: string
    seniority: string
    keywords?: JobDescriptionIntelligenceCreatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceCreateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceCreatequalificationsInput | string[]
    categories: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type JobDescriptionIntelligenceUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId?: string | null
    role: string
    seniority: string
    keywords?: JobDescriptionIntelligenceCreatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceCreateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceCreatequalificationsInput | string[]
    categories: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type JobDescriptionIntelligenceCreateOrConnectWithoutUserInput = {
    where: JobDescriptionIntelligenceWhereUniqueInput
    create: XOR<JobDescriptionIntelligenceCreateWithoutUserInput, JobDescriptionIntelligenceUncheckedCreateWithoutUserInput>
  }

  export type JobDescriptionIntelligenceCreateManyUserInputEnvelope = {
    data: JobDescriptionIntelligenceCreateManyUserInput | JobDescriptionIntelligenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResumeTagCreateWithoutUserInput = {
    id?: string
    tag: string
    resume: ResumeCreateNestedOneWithoutTagsInput
  }

  export type ResumeTagUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    tag: string
  }

  export type ResumeTagCreateOrConnectWithoutUserInput = {
    where: ResumeTagWhereUniqueInput
    create: XOR<ResumeTagCreateWithoutUserInput, ResumeTagUncheckedCreateWithoutUserInput>
  }

  export type ResumeTagCreateManyUserInputEnvelope = {
    data: ResumeTagCreateManyUserInput | ResumeTagCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResumeMetadataCreateWithoutUserInput = {
    id?: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutMetadataInput
  }

  export type ResumeMetadataUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt?: Date | string
  }

  export type ResumeMetadataCreateOrConnectWithoutUserInput = {
    where: ResumeMetadataWhereUniqueInput
    create: XOR<ResumeMetadataCreateWithoutUserInput, ResumeMetadataUncheckedCreateWithoutUserInput>
  }

  export type ResumeMetadataCreateManyUserInputEnvelope = {
    data: ResumeMetadataCreateManyUserInput | ResumeMetadataCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResumeSectionRationaleCreateWithoutUserInput = {
    id?: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutResumeSectionRationaleInput
  }

  export type ResumeSectionRationaleUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
  }

  export type ResumeSectionRationaleCreateOrConnectWithoutUserInput = {
    where: ResumeSectionRationaleWhereUniqueInput
    create: XOR<ResumeSectionRationaleCreateWithoutUserInput, ResumeSectionRationaleUncheckedCreateWithoutUserInput>
  }

  export type ResumeSectionRationaleCreateManyUserInputEnvelope = {
    data: ResumeSectionRationaleCreateManyUserInput | ResumeSectionRationaleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResumeUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumeWhereUniqueInput
    update: XOR<ResumeUpdateWithoutUserInput, ResumeUncheckedUpdateWithoutUserInput>
    create: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput>
  }

  export type ResumeUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumeWhereUniqueInput
    data: XOR<ResumeUpdateWithoutUserInput, ResumeUncheckedUpdateWithoutUserInput>
  }

  export type ResumeUpdateManyWithWhereWithoutUserInput = {
    where: ResumeScalarWhereInput
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyWithoutUserInput>
  }

  export type ResumeScalarWhereInput = {
    AND?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
    OR?: ResumeScalarWhereInput[]
    NOT?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
    id?: StringFilter<"Resume"> | string
    userId?: StringFilter<"Resume"> | string
    resumeText?: StringFilter<"Resume"> | string
    jobDescription?: StringFilter<"Resume"> | string
    modifiedResume?: StringNullableFilter<"Resume"> | string | null
    tailoringMode?: StringFilter<"Resume"> | string
    version?: IntFilter<"Resume"> | number
    label?: StringNullableFilter<"Resume"> | string | null
    atsScore?: IntNullableFilter<"Resume"> | number | null
    jdScore?: IntNullableFilter<"Resume"> | number | null
    goldenPassed?: BoolFilter<"Resume"> | boolean
    isRefinement?: BoolFilter<"Resume"> | boolean
    isSaved?: BoolFilter<"Resume"> | boolean
    originalResumeId?: StringNullableFilter<"Resume"> | string | null
    wasManuallyEdited?: BoolFilter<"Resume"> | boolean
    scoresStale?: BoolFilter<"Resume"> | boolean
    finalModifiedSections?: StringNullableFilter<"Resume"> | string | null
    atsWarnings?: StringNullableFilter<"Resume"> | string | null
    createdAt?: DateTimeFilter<"Resume"> | Date | string
    updatedAt?: DateTimeFilter<"Resume"> | Date | string
  }

  export type TailoringAnalyticsUpsertWithWhereUniqueWithoutUserInput = {
    where: TailoringAnalyticsWhereUniqueInput
    update: XOR<TailoringAnalyticsUpdateWithoutUserInput, TailoringAnalyticsUncheckedUpdateWithoutUserInput>
    create: XOR<TailoringAnalyticsCreateWithoutUserInput, TailoringAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type TailoringAnalyticsUpdateWithWhereUniqueWithoutUserInput = {
    where: TailoringAnalyticsWhereUniqueInput
    data: XOR<TailoringAnalyticsUpdateWithoutUserInput, TailoringAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type TailoringAnalyticsUpdateManyWithWhereWithoutUserInput = {
    where: TailoringAnalyticsScalarWhereInput
    data: XOR<TailoringAnalyticsUpdateManyMutationInput, TailoringAnalyticsUncheckedUpdateManyWithoutUserInput>
  }

  export type TailoringAnalyticsScalarWhereInput = {
    AND?: TailoringAnalyticsScalarWhereInput | TailoringAnalyticsScalarWhereInput[]
    OR?: TailoringAnalyticsScalarWhereInput[]
    NOT?: TailoringAnalyticsScalarWhereInput | TailoringAnalyticsScalarWhereInput[]
    id?: StringFilter<"TailoringAnalytics"> | string
    resumeId?: StringFilter<"TailoringAnalytics"> | string
    userId?: StringFilter<"TailoringAnalytics"> | string
    tailoringMode?: StringFilter<"TailoringAnalytics"> | string
    iterations?: IntFilter<"TailoringAnalytics"> | number
    atsScore?: IntFilter<"TailoringAnalytics"> | number
    jdScore?: IntFilter<"TailoringAnalytics"> | number
    goldenPassed?: BoolFilter<"TailoringAnalytics"> | boolean
    isRefinement?: BoolFilter<"TailoringAnalytics"> | boolean
    createdAt?: DateTimeFilter<"TailoringAnalytics"> | Date | string
    modifiedSections?: StringNullableFilter<"TailoringAnalytics"> | string | null
  }

  export type ResumeInteractionUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumeInteractionWhereUniqueInput
    update: XOR<ResumeInteractionUpdateWithoutUserInput, ResumeInteractionUncheckedUpdateWithoutUserInput>
    create: XOR<ResumeInteractionCreateWithoutUserInput, ResumeInteractionUncheckedCreateWithoutUserInput>
  }

  export type ResumeInteractionUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumeInteractionWhereUniqueInput
    data: XOR<ResumeInteractionUpdateWithoutUserInput, ResumeInteractionUncheckedUpdateWithoutUserInput>
  }

  export type ResumeInteractionUpdateManyWithWhereWithoutUserInput = {
    where: ResumeInteractionScalarWhereInput
    data: XOR<ResumeInteractionUpdateManyMutationInput, ResumeInteractionUncheckedUpdateManyWithoutUserInput>
  }

  export type ResumeInteractionScalarWhereInput = {
    AND?: ResumeInteractionScalarWhereInput | ResumeInteractionScalarWhereInput[]
    OR?: ResumeInteractionScalarWhereInput[]
    NOT?: ResumeInteractionScalarWhereInput | ResumeInteractionScalarWhereInput[]
    id?: StringFilter<"ResumeInteraction"> | string
    userId?: StringFilter<"ResumeInteraction"> | string
    resumeId?: StringFilter<"ResumeInteraction"> | string
    action?: StringFilter<"ResumeInteraction"> | string
    createdAt?: DateTimeFilter<"ResumeInteraction"> | Date | string
  }

  export type CoverLetterUpsertWithWhereUniqueWithoutUserInput = {
    where: CoverLetterWhereUniqueInput
    update: XOR<CoverLetterUpdateWithoutUserInput, CoverLetterUncheckedUpdateWithoutUserInput>
    create: XOR<CoverLetterCreateWithoutUserInput, CoverLetterUncheckedCreateWithoutUserInput>
  }

  export type CoverLetterUpdateWithWhereUniqueWithoutUserInput = {
    where: CoverLetterWhereUniqueInput
    data: XOR<CoverLetterUpdateWithoutUserInput, CoverLetterUncheckedUpdateWithoutUserInput>
  }

  export type CoverLetterUpdateManyWithWhereWithoutUserInput = {
    where: CoverLetterScalarWhereInput
    data: XOR<CoverLetterUpdateManyMutationInput, CoverLetterUncheckedUpdateManyWithoutUserInput>
  }

  export type CoverLetterScalarWhereInput = {
    AND?: CoverLetterScalarWhereInput | CoverLetterScalarWhereInput[]
    OR?: CoverLetterScalarWhereInput[]
    NOT?: CoverLetterScalarWhereInput | CoverLetterScalarWhereInput[]
    id?: StringFilter<"CoverLetter"> | string
    userId?: StringFilter<"CoverLetter"> | string
    resumeId?: StringFilter<"CoverLetter"> | string
    jobDescription?: StringFilter<"CoverLetter"> | string
    content?: StringFilter<"CoverLetter"> | string
    tone?: StringFilter<"CoverLetter"> | string
    atsScore?: IntNullableFilter<"CoverLetter"> | number | null
    jdScore?: IntNullableFilter<"CoverLetter"> | number | null
    version?: IntFilter<"CoverLetter"> | number
    createdAt?: DateTimeFilter<"CoverLetter"> | Date | string
    updatedAt?: DateTimeFilter<"CoverLetter"> | Date | string
  }

  export type LinkedInOptimizationUpsertWithWhereUniqueWithoutUserInput = {
    where: LinkedInOptimizationWhereUniqueInput
    update: XOR<LinkedInOptimizationUpdateWithoutUserInput, LinkedInOptimizationUncheckedUpdateWithoutUserInput>
    create: XOR<LinkedInOptimizationCreateWithoutUserInput, LinkedInOptimizationUncheckedCreateWithoutUserInput>
  }

  export type LinkedInOptimizationUpdateWithWhereUniqueWithoutUserInput = {
    where: LinkedInOptimizationWhereUniqueInput
    data: XOR<LinkedInOptimizationUpdateWithoutUserInput, LinkedInOptimizationUncheckedUpdateWithoutUserInput>
  }

  export type LinkedInOptimizationUpdateManyWithWhereWithoutUserInput = {
    where: LinkedInOptimizationScalarWhereInput
    data: XOR<LinkedInOptimizationUpdateManyMutationInput, LinkedInOptimizationUncheckedUpdateManyWithoutUserInput>
  }

  export type LinkedInOptimizationScalarWhereInput = {
    AND?: LinkedInOptimizationScalarWhereInput | LinkedInOptimizationScalarWhereInput[]
    OR?: LinkedInOptimizationScalarWhereInput[]
    NOT?: LinkedInOptimizationScalarWhereInput | LinkedInOptimizationScalarWhereInput[]
    id?: StringFilter<"LinkedInOptimization"> | string
    userId?: StringFilter<"LinkedInOptimization"> | string
    jobDescription?: StringFilter<"LinkedInOptimization"> | string
    originalAbout?: StringFilter<"LinkedInOptimization"> | string
    optimizedAbout?: StringFilter<"LinkedInOptimization"> | string
    tone?: StringFilter<"LinkedInOptimization"> | string
    createdAt?: DateTimeFilter<"LinkedInOptimization"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedInOptimization"> | Date | string
  }

  export type InterviewSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: InterviewSessionWhereUniqueInput
    update: XOR<InterviewSessionUpdateWithoutUserInput, InterviewSessionUncheckedUpdateWithoutUserInput>
    create: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput>
  }

  export type InterviewSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: InterviewSessionWhereUniqueInput
    data: XOR<InterviewSessionUpdateWithoutUserInput, InterviewSessionUncheckedUpdateWithoutUserInput>
  }

  export type InterviewSessionUpdateManyWithWhereWithoutUserInput = {
    where: InterviewSessionScalarWhereInput
    data: XOR<InterviewSessionUpdateManyMutationInput, InterviewSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type InterviewSessionScalarWhereInput = {
    AND?: InterviewSessionScalarWhereInput | InterviewSessionScalarWhereInput[]
    OR?: InterviewSessionScalarWhereInput[]
    NOT?: InterviewSessionScalarWhereInput | InterviewSessionScalarWhereInput[]
    id?: StringFilter<"InterviewSession"> | string
    userId?: StringFilter<"InterviewSession"> | string
    jobDescription?: StringFilter<"InterviewSession"> | string
    selectedTypes?: StringNullableListFilter<"InterviewSession">
    questions?: JsonFilter<"InterviewSession">
    answers?: JsonNullableFilter<"InterviewSession">
    needsReview?: JsonNullableFilter<"InterviewSession">
    createdAt?: DateTimeFilter<"InterviewSession"> | Date | string
    updatedAt?: DateTimeFilter<"InterviewSession"> | Date | string
  }

  export type ResumeExportUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumeExportWhereUniqueInput
    update: XOR<ResumeExportUpdateWithoutUserInput, ResumeExportUncheckedUpdateWithoutUserInput>
    create: XOR<ResumeExportCreateWithoutUserInput, ResumeExportUncheckedCreateWithoutUserInput>
  }

  export type ResumeExportUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumeExportWhereUniqueInput
    data: XOR<ResumeExportUpdateWithoutUserInput, ResumeExportUncheckedUpdateWithoutUserInput>
  }

  export type ResumeExportUpdateManyWithWhereWithoutUserInput = {
    where: ResumeExportScalarWhereInput
    data: XOR<ResumeExportUpdateManyMutationInput, ResumeExportUncheckedUpdateManyWithoutUserInput>
  }

  export type ResumeExportScalarWhereInput = {
    AND?: ResumeExportScalarWhereInput | ResumeExportScalarWhereInput[]
    OR?: ResumeExportScalarWhereInput[]
    NOT?: ResumeExportScalarWhereInput | ResumeExportScalarWhereInput[]
    id?: StringFilter<"ResumeExport"> | string
    userId?: StringFilter<"ResumeExport"> | string
    resumeId?: StringFilter<"ResumeExport"> | string
    templateId?: StringFilter<"ResumeExport"> | string
    format?: StringFilter<"ResumeExport"> | string
    createdAt?: DateTimeFilter<"ResumeExport"> | Date | string
  }

  export type JobDescriptionIntelligenceUpsertWithWhereUniqueWithoutUserInput = {
    where: JobDescriptionIntelligenceWhereUniqueInput
    update: XOR<JobDescriptionIntelligenceUpdateWithoutUserInput, JobDescriptionIntelligenceUncheckedUpdateWithoutUserInput>
    create: XOR<JobDescriptionIntelligenceCreateWithoutUserInput, JobDescriptionIntelligenceUncheckedCreateWithoutUserInput>
  }

  export type JobDescriptionIntelligenceUpdateWithWhereUniqueWithoutUserInput = {
    where: JobDescriptionIntelligenceWhereUniqueInput
    data: XOR<JobDescriptionIntelligenceUpdateWithoutUserInput, JobDescriptionIntelligenceUncheckedUpdateWithoutUserInput>
  }

  export type JobDescriptionIntelligenceUpdateManyWithWhereWithoutUserInput = {
    where: JobDescriptionIntelligenceScalarWhereInput
    data: XOR<JobDescriptionIntelligenceUpdateManyMutationInput, JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserInput>
  }

  export type JobDescriptionIntelligenceScalarWhereInput = {
    AND?: JobDescriptionIntelligenceScalarWhereInput | JobDescriptionIntelligenceScalarWhereInput[]
    OR?: JobDescriptionIntelligenceScalarWhereInput[]
    NOT?: JobDescriptionIntelligenceScalarWhereInput | JobDescriptionIntelligenceScalarWhereInput[]
    id?: StringFilter<"JobDescriptionIntelligence"> | string
    userId?: StringFilter<"JobDescriptionIntelligence"> | string
    resumeId?: StringNullableFilter<"JobDescriptionIntelligence"> | string | null
    role?: StringFilter<"JobDescriptionIntelligence"> | string
    seniority?: StringFilter<"JobDescriptionIntelligence"> | string
    keywords?: StringNullableListFilter<"JobDescriptionIntelligence">
    responsibilities?: StringNullableListFilter<"JobDescriptionIntelligence">
    qualifications?: StringNullableListFilter<"JobDescriptionIntelligence">
    categories?: JsonFilter<"JobDescriptionIntelligence">
    createdAt?: DateTimeFilter<"JobDescriptionIntelligence"> | Date | string
  }

  export type ResumeTagUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumeTagWhereUniqueInput
    update: XOR<ResumeTagUpdateWithoutUserInput, ResumeTagUncheckedUpdateWithoutUserInput>
    create: XOR<ResumeTagCreateWithoutUserInput, ResumeTagUncheckedCreateWithoutUserInput>
  }

  export type ResumeTagUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumeTagWhereUniqueInput
    data: XOR<ResumeTagUpdateWithoutUserInput, ResumeTagUncheckedUpdateWithoutUserInput>
  }

  export type ResumeTagUpdateManyWithWhereWithoutUserInput = {
    where: ResumeTagScalarWhereInput
    data: XOR<ResumeTagUpdateManyMutationInput, ResumeTagUncheckedUpdateManyWithoutUserInput>
  }

  export type ResumeTagScalarWhereInput = {
    AND?: ResumeTagScalarWhereInput | ResumeTagScalarWhereInput[]
    OR?: ResumeTagScalarWhereInput[]
    NOT?: ResumeTagScalarWhereInput | ResumeTagScalarWhereInput[]
    id?: StringFilter<"ResumeTag"> | string
    userId?: StringFilter<"ResumeTag"> | string
    resumeId?: StringFilter<"ResumeTag"> | string
    tag?: StringFilter<"ResumeTag"> | string
  }

  export type ResumeMetadataUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumeMetadataWhereUniqueInput
    update: XOR<ResumeMetadataUpdateWithoutUserInput, ResumeMetadataUncheckedUpdateWithoutUserInput>
    create: XOR<ResumeMetadataCreateWithoutUserInput, ResumeMetadataUncheckedCreateWithoutUserInput>
  }

  export type ResumeMetadataUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumeMetadataWhereUniqueInput
    data: XOR<ResumeMetadataUpdateWithoutUserInput, ResumeMetadataUncheckedUpdateWithoutUserInput>
  }

  export type ResumeMetadataUpdateManyWithWhereWithoutUserInput = {
    where: ResumeMetadataScalarWhereInput
    data: XOR<ResumeMetadataUpdateManyMutationInput, ResumeMetadataUncheckedUpdateManyWithoutUserInput>
  }

  export type ResumeMetadataScalarWhereInput = {
    AND?: ResumeMetadataScalarWhereInput | ResumeMetadataScalarWhereInput[]
    OR?: ResumeMetadataScalarWhereInput[]
    NOT?: ResumeMetadataScalarWhereInput | ResumeMetadataScalarWhereInput[]
    id?: StringFilter<"ResumeMetadata"> | string
    userId?: StringFilter<"ResumeMetadata"> | string
    resumeId?: StringFilter<"ResumeMetadata"> | string
    contentSnippet?: StringFilter<"ResumeMetadata"> | string
    tailoringMode?: StringFilter<"ResumeMetadata"> | string
    iterations?: IntFilter<"ResumeMetadata"> | number
    passedRules?: BoolFilter<"ResumeMetadata"> | boolean
    atsScore?: IntFilter<"ResumeMetadata"> | number
    jdScore?: IntFilter<"ResumeMetadata"> | number
    createdAt?: DateTimeFilter<"ResumeMetadata"> | Date | string
  }

  export type ResumeSectionRationaleUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumeSectionRationaleWhereUniqueInput
    update: XOR<ResumeSectionRationaleUpdateWithoutUserInput, ResumeSectionRationaleUncheckedUpdateWithoutUserInput>
    create: XOR<ResumeSectionRationaleCreateWithoutUserInput, ResumeSectionRationaleUncheckedCreateWithoutUserInput>
  }

  export type ResumeSectionRationaleUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumeSectionRationaleWhereUniqueInput
    data: XOR<ResumeSectionRationaleUpdateWithoutUserInput, ResumeSectionRationaleUncheckedUpdateWithoutUserInput>
  }

  export type ResumeSectionRationaleUpdateManyWithWhereWithoutUserInput = {
    where: ResumeSectionRationaleScalarWhereInput
    data: XOR<ResumeSectionRationaleUpdateManyMutationInput, ResumeSectionRationaleUncheckedUpdateManyWithoutUserInput>
  }

  export type ResumeSectionRationaleScalarWhereInput = {
    AND?: ResumeSectionRationaleScalarWhereInput | ResumeSectionRationaleScalarWhereInput[]
    OR?: ResumeSectionRationaleScalarWhereInput[]
    NOT?: ResumeSectionRationaleScalarWhereInput | ResumeSectionRationaleScalarWhereInput[]
    id?: StringFilter<"ResumeSectionRationale"> | string
    resumeId?: StringFilter<"ResumeSectionRationale"> | string
    userId?: StringFilter<"ResumeSectionRationale"> | string
    sectionName?: StringFilter<"ResumeSectionRationale"> | string
    rationale?: StringFilter<"ResumeSectionRationale"> | string
    createdAt?: DateTimeFilter<"ResumeSectionRationale"> | Date | string
  }

  export type UserCreateWithoutResumesInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumesInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumesInput, UserUncheckedCreateWithoutResumesInput>
  }

  export type TailoringAnalyticsCreateWithoutResumeInput = {
    id?: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
    user: UserCreateNestedOneWithoutAnalyticsInput
  }

  export type TailoringAnalyticsUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
  }

  export type TailoringAnalyticsCreateOrConnectWithoutResumeInput = {
    where: TailoringAnalyticsWhereUniqueInput
    create: XOR<TailoringAnalyticsCreateWithoutResumeInput, TailoringAnalyticsUncheckedCreateWithoutResumeInput>
  }

  export type TailoringAnalyticsCreateManyResumeInputEnvelope = {
    data: TailoringAnalyticsCreateManyResumeInput | TailoringAnalyticsCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ScrubbedResumeCreateWithoutResumeInput = {
    id?: string
    cleanText: string
    createdAt?: Date | string
  }

  export type ScrubbedResumeUncheckedCreateWithoutResumeInput = {
    id?: string
    cleanText: string
    createdAt?: Date | string
  }

  export type ScrubbedResumeCreateOrConnectWithoutResumeInput = {
    where: ScrubbedResumeWhereUniqueInput
    create: XOR<ScrubbedResumeCreateWithoutResumeInput, ScrubbedResumeUncheckedCreateWithoutResumeInput>
  }

  export type PromptArchiveCreateWithoutResumeInput = {
    id?: string
    content: string
    response: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PromptArchiveUncheckedCreateWithoutResumeInput = {
    id?: string
    content: string
    response: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PromptArchiveCreateOrConnectWithoutResumeInput = {
    where: PromptArchiveWhereUniqueInput
    create: XOR<PromptArchiveCreateWithoutResumeInput, PromptArchiveUncheckedCreateWithoutResumeInput>
  }

  export type PromptArchiveCreateManyResumeInputEnvelope = {
    data: PromptArchiveCreateManyResumeInput | PromptArchiveCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeInteractionCreateWithoutResumeInput = {
    id?: string
    action: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInteractionsInput
  }

  export type ResumeInteractionUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    action: string
    createdAt?: Date | string
  }

  export type ResumeInteractionCreateOrConnectWithoutResumeInput = {
    where: ResumeInteractionWhereUniqueInput
    create: XOR<ResumeInteractionCreateWithoutResumeInput, ResumeInteractionUncheckedCreateWithoutResumeInput>
  }

  export type ResumeInteractionCreateManyResumeInputEnvelope = {
    data: ResumeInteractionCreateManyResumeInput | ResumeInteractionCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeTagCreateWithoutResumeInput = {
    id?: string
    tag: string
    user: UserCreateNestedOneWithoutResumeTagInput
  }

  export type ResumeTagUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    tag: string
  }

  export type ResumeTagCreateOrConnectWithoutResumeInput = {
    where: ResumeTagWhereUniqueInput
    create: XOR<ResumeTagCreateWithoutResumeInput, ResumeTagUncheckedCreateWithoutResumeInput>
  }

  export type ResumeTagCreateManyResumeInputEnvelope = {
    data: ResumeTagCreateManyResumeInput | ResumeTagCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeMetadataCreateWithoutResumeInput = {
    id?: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutResumeMetadataInput
  }

  export type ResumeMetadataUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt?: Date | string
  }

  export type ResumeMetadataCreateOrConnectWithoutResumeInput = {
    where: ResumeMetadataWhereUniqueInput
    create: XOR<ResumeMetadataCreateWithoutResumeInput, ResumeMetadataUncheckedCreateWithoutResumeInput>
  }

  export type TailoringPromptCreateWithoutResumeInput = {
    id?: string
    tailoringMode: string
    prompt: string
    attempt: number
    version: number
    createdAt?: Date | string
  }

  export type TailoringPromptUncheckedCreateWithoutResumeInput = {
    id?: string
    tailoringMode: string
    prompt: string
    attempt: number
    version: number
    createdAt?: Date | string
  }

  export type TailoringPromptCreateOrConnectWithoutResumeInput = {
    where: TailoringPromptWhereUniqueInput
    create: XOR<TailoringPromptCreateWithoutResumeInput, TailoringPromptUncheckedCreateWithoutResumeInput>
  }

  export type TailoringPromptCreateManyResumeInputEnvelope = {
    data: TailoringPromptCreateManyResumeInput | TailoringPromptCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type CoverLetterCreateWithoutResumeInput = {
    id?: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoverLettersInput
  }

  export type CoverLetterUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoverLetterCreateOrConnectWithoutResumeInput = {
    where: CoverLetterWhereUniqueInput
    create: XOR<CoverLetterCreateWithoutResumeInput, CoverLetterUncheckedCreateWithoutResumeInput>
  }

  export type CoverLetterCreateManyResumeInputEnvelope = {
    data: CoverLetterCreateManyResumeInput | CoverLetterCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeExportCreateWithoutResumeInput = {
    id?: string
    templateId: string
    format: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutResumeExportsInput
  }

  export type ResumeExportUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    templateId: string
    format: string
    createdAt?: Date | string
  }

  export type ResumeExportCreateOrConnectWithoutResumeInput = {
    where: ResumeExportWhereUniqueInput
    create: XOR<ResumeExportCreateWithoutResumeInput, ResumeExportUncheckedCreateWithoutResumeInput>
  }

  export type ResumeExportCreateManyResumeInputEnvelope = {
    data: ResumeExportCreateManyResumeInput | ResumeExportCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type TailoringProgressCreateWithoutResumeInput = {
    id?: string
    userId: string
    status: string
    progress: number
    currentAttempt?: number | null
    maxAttempts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TailoringProgressUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    status: string
    progress: number
    currentAttempt?: number | null
    maxAttempts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TailoringProgressCreateOrConnectWithoutResumeInput = {
    where: TailoringProgressWhereUniqueInput
    create: XOR<TailoringProgressCreateWithoutResumeInput, TailoringProgressUncheckedCreateWithoutResumeInput>
  }

  export type TailoringProgressCreateManyResumeInputEnvelope = {
    data: TailoringProgressCreateManyResumeInput | TailoringProgressCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type TailoringAttemptCreateWithoutResumeInput = {
    id?: string
    userId: string
    attemptNumber: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    feedback: string
    suggestions: string
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
    modifiedSectionsSent?: string | null
    modifiedSectionsReceived?: string | null
    promptTokens?: number | null
    goldenRuleFeedback?: string | null
    iteration?: number | null
    modifiedSections?: string | null
    score?: number | null
  }

  export type TailoringAttemptUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    attemptNumber: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    feedback: string
    suggestions: string
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
    modifiedSectionsSent?: string | null
    modifiedSectionsReceived?: string | null
    promptTokens?: number | null
    goldenRuleFeedback?: string | null
    iteration?: number | null
    modifiedSections?: string | null
    score?: number | null
  }

  export type TailoringAttemptCreateOrConnectWithoutResumeInput = {
    where: TailoringAttemptWhereUniqueInput
    create: XOR<TailoringAttemptCreateWithoutResumeInput, TailoringAttemptUncheckedCreateWithoutResumeInput>
  }

  export type TailoringAttemptCreateManyResumeInputEnvelope = {
    data: TailoringAttemptCreateManyResumeInput | TailoringAttemptCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ManualEditCreateWithoutResumeInput = {
    id?: string
    userId: string
    editedText: string
    createdAt?: Date | string
  }

  export type ManualEditUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    editedText: string
    createdAt?: Date | string
  }

  export type ManualEditCreateOrConnectWithoutResumeInput = {
    where: ManualEditWhereUniqueInput
    create: XOR<ManualEditCreateWithoutResumeInput, ManualEditUncheckedCreateWithoutResumeInput>
  }

  export type ManualEditCreateManyResumeInputEnvelope = {
    data: ManualEditCreateManyResumeInput | ManualEditCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ManualScoringCreateWithoutResumeInput = {
    id?: string
    userId: string
    atsScore: number
    jdScore: number
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
  }

  export type ManualScoringUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    atsScore: number
    jdScore: number
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
  }

  export type ManualScoringCreateOrConnectWithoutResumeInput = {
    where: ManualScoringWhereUniqueInput
    create: XOR<ManualScoringCreateWithoutResumeInput, ManualScoringUncheckedCreateWithoutResumeInput>
  }

  export type ManualScoringCreateManyResumeInputEnvelope = {
    data: ManualScoringCreateManyResumeInput | ManualScoringCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeFeedbackCreateWithoutResumeInput = {
    id?: string
    userId: string
    feedbackType: string
    feedbackPoints?: ResumeFeedbackCreatefeedbackPointsInput | string[]
    sourceVersion?: number | null
    createdAt?: Date | string
  }

  export type ResumeFeedbackUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    feedbackType: string
    feedbackPoints?: ResumeFeedbackCreatefeedbackPointsInput | string[]
    sourceVersion?: number | null
    createdAt?: Date | string
  }

  export type ResumeFeedbackCreateOrConnectWithoutResumeInput = {
    where: ResumeFeedbackWhereUniqueInput
    create: XOR<ResumeFeedbackCreateWithoutResumeInput, ResumeFeedbackUncheckedCreateWithoutResumeInput>
  }

  export type ResumeFeedbackCreateManyResumeInputEnvelope = {
    data: ResumeFeedbackCreateManyResumeInput | ResumeFeedbackCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeSectionRationaleCreateWithoutResumeInput = {
    id?: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutResumeSectionRationaleInput
  }

  export type ResumeSectionRationaleUncheckedCreateWithoutResumeInput = {
    id?: string
    userId: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
  }

  export type ResumeSectionRationaleCreateOrConnectWithoutResumeInput = {
    where: ResumeSectionRationaleWhereUniqueInput
    create: XOR<ResumeSectionRationaleCreateWithoutResumeInput, ResumeSectionRationaleUncheckedCreateWithoutResumeInput>
  }

  export type ResumeSectionRationaleCreateManyResumeInputEnvelope = {
    data: ResumeSectionRationaleCreateManyResumeInput | ResumeSectionRationaleCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutResumesInput = {
    update: XOR<UserUpdateWithoutResumesInput, UserUncheckedUpdateWithoutResumesInput>
    create: XOR<UserCreateWithoutResumesInput, UserUncheckedCreateWithoutResumesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResumesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResumesInput, UserUncheckedUpdateWithoutResumesInput>
  }

  export type UserUpdateWithoutResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TailoringAnalyticsUpsertWithWhereUniqueWithoutResumeInput = {
    where: TailoringAnalyticsWhereUniqueInput
    update: XOR<TailoringAnalyticsUpdateWithoutResumeInput, TailoringAnalyticsUncheckedUpdateWithoutResumeInput>
    create: XOR<TailoringAnalyticsCreateWithoutResumeInput, TailoringAnalyticsUncheckedCreateWithoutResumeInput>
  }

  export type TailoringAnalyticsUpdateWithWhereUniqueWithoutResumeInput = {
    where: TailoringAnalyticsWhereUniqueInput
    data: XOR<TailoringAnalyticsUpdateWithoutResumeInput, TailoringAnalyticsUncheckedUpdateWithoutResumeInput>
  }

  export type TailoringAnalyticsUpdateManyWithWhereWithoutResumeInput = {
    where: TailoringAnalyticsScalarWhereInput
    data: XOR<TailoringAnalyticsUpdateManyMutationInput, TailoringAnalyticsUncheckedUpdateManyWithoutResumeInput>
  }

  export type ScrubbedResumeUpsertWithoutResumeInput = {
    update: XOR<ScrubbedResumeUpdateWithoutResumeInput, ScrubbedResumeUncheckedUpdateWithoutResumeInput>
    create: XOR<ScrubbedResumeCreateWithoutResumeInput, ScrubbedResumeUncheckedCreateWithoutResumeInput>
    where?: ScrubbedResumeWhereInput
  }

  export type ScrubbedResumeUpdateToOneWithWhereWithoutResumeInput = {
    where?: ScrubbedResumeWhereInput
    data: XOR<ScrubbedResumeUpdateWithoutResumeInput, ScrubbedResumeUncheckedUpdateWithoutResumeInput>
  }

  export type ScrubbedResumeUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    cleanText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScrubbedResumeUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    cleanText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptArchiveUpsertWithWhereUniqueWithoutResumeInput = {
    where: PromptArchiveWhereUniqueInput
    update: XOR<PromptArchiveUpdateWithoutResumeInput, PromptArchiveUncheckedUpdateWithoutResumeInput>
    create: XOR<PromptArchiveCreateWithoutResumeInput, PromptArchiveUncheckedCreateWithoutResumeInput>
  }

  export type PromptArchiveUpdateWithWhereUniqueWithoutResumeInput = {
    where: PromptArchiveWhereUniqueInput
    data: XOR<PromptArchiveUpdateWithoutResumeInput, PromptArchiveUncheckedUpdateWithoutResumeInput>
  }

  export type PromptArchiveUpdateManyWithWhereWithoutResumeInput = {
    where: PromptArchiveScalarWhereInput
    data: XOR<PromptArchiveUpdateManyMutationInput, PromptArchiveUncheckedUpdateManyWithoutResumeInput>
  }

  export type PromptArchiveScalarWhereInput = {
    AND?: PromptArchiveScalarWhereInput | PromptArchiveScalarWhereInput[]
    OR?: PromptArchiveScalarWhereInput[]
    NOT?: PromptArchiveScalarWhereInput | PromptArchiveScalarWhereInput[]
    id?: StringFilter<"PromptArchive"> | string
    resumeId?: StringFilter<"PromptArchive"> | string
    content?: StringFilter<"PromptArchive"> | string
    response?: StringFilter<"PromptArchive"> | string
    metadata?: JsonNullableFilter<"PromptArchive">
    createdAt?: DateTimeFilter<"PromptArchive"> | Date | string
  }

  export type ResumeInteractionUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeInteractionWhereUniqueInput
    update: XOR<ResumeInteractionUpdateWithoutResumeInput, ResumeInteractionUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeInteractionCreateWithoutResumeInput, ResumeInteractionUncheckedCreateWithoutResumeInput>
  }

  export type ResumeInteractionUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeInteractionWhereUniqueInput
    data: XOR<ResumeInteractionUpdateWithoutResumeInput, ResumeInteractionUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeInteractionUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeInteractionScalarWhereInput
    data: XOR<ResumeInteractionUpdateManyMutationInput, ResumeInteractionUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeTagUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeTagWhereUniqueInput
    update: XOR<ResumeTagUpdateWithoutResumeInput, ResumeTagUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeTagCreateWithoutResumeInput, ResumeTagUncheckedCreateWithoutResumeInput>
  }

  export type ResumeTagUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeTagWhereUniqueInput
    data: XOR<ResumeTagUpdateWithoutResumeInput, ResumeTagUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeTagUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeTagScalarWhereInput
    data: XOR<ResumeTagUpdateManyMutationInput, ResumeTagUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeMetadataUpsertWithoutResumeInput = {
    update: XOR<ResumeMetadataUpdateWithoutResumeInput, ResumeMetadataUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeMetadataCreateWithoutResumeInput, ResumeMetadataUncheckedCreateWithoutResumeInput>
    where?: ResumeMetadataWhereInput
  }

  export type ResumeMetadataUpdateToOneWithWhereWithoutResumeInput = {
    where?: ResumeMetadataWhereInput
    data: XOR<ResumeMetadataUpdateWithoutResumeInput, ResumeMetadataUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeMetadataUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumeMetadataNestedInput
  }

  export type ResumeMetadataUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringPromptUpsertWithWhereUniqueWithoutResumeInput = {
    where: TailoringPromptWhereUniqueInput
    update: XOR<TailoringPromptUpdateWithoutResumeInput, TailoringPromptUncheckedUpdateWithoutResumeInput>
    create: XOR<TailoringPromptCreateWithoutResumeInput, TailoringPromptUncheckedCreateWithoutResumeInput>
  }

  export type TailoringPromptUpdateWithWhereUniqueWithoutResumeInput = {
    where: TailoringPromptWhereUniqueInput
    data: XOR<TailoringPromptUpdateWithoutResumeInput, TailoringPromptUncheckedUpdateWithoutResumeInput>
  }

  export type TailoringPromptUpdateManyWithWhereWithoutResumeInput = {
    where: TailoringPromptScalarWhereInput
    data: XOR<TailoringPromptUpdateManyMutationInput, TailoringPromptUncheckedUpdateManyWithoutResumeInput>
  }

  export type TailoringPromptScalarWhereInput = {
    AND?: TailoringPromptScalarWhereInput | TailoringPromptScalarWhereInput[]
    OR?: TailoringPromptScalarWhereInput[]
    NOT?: TailoringPromptScalarWhereInput | TailoringPromptScalarWhereInput[]
    id?: StringFilter<"TailoringPrompt"> | string
    resumeId?: StringFilter<"TailoringPrompt"> | string
    tailoringMode?: StringFilter<"TailoringPrompt"> | string
    prompt?: StringFilter<"TailoringPrompt"> | string
    attempt?: IntFilter<"TailoringPrompt"> | number
    version?: IntFilter<"TailoringPrompt"> | number
    createdAt?: DateTimeFilter<"TailoringPrompt"> | Date | string
  }

  export type CoverLetterUpsertWithWhereUniqueWithoutResumeInput = {
    where: CoverLetterWhereUniqueInput
    update: XOR<CoverLetterUpdateWithoutResumeInput, CoverLetterUncheckedUpdateWithoutResumeInput>
    create: XOR<CoverLetterCreateWithoutResumeInput, CoverLetterUncheckedCreateWithoutResumeInput>
  }

  export type CoverLetterUpdateWithWhereUniqueWithoutResumeInput = {
    where: CoverLetterWhereUniqueInput
    data: XOR<CoverLetterUpdateWithoutResumeInput, CoverLetterUncheckedUpdateWithoutResumeInput>
  }

  export type CoverLetterUpdateManyWithWhereWithoutResumeInput = {
    where: CoverLetterScalarWhereInput
    data: XOR<CoverLetterUpdateManyMutationInput, CoverLetterUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeExportUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeExportWhereUniqueInput
    update: XOR<ResumeExportUpdateWithoutResumeInput, ResumeExportUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeExportCreateWithoutResumeInput, ResumeExportUncheckedCreateWithoutResumeInput>
  }

  export type ResumeExportUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeExportWhereUniqueInput
    data: XOR<ResumeExportUpdateWithoutResumeInput, ResumeExportUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeExportUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeExportScalarWhereInput
    data: XOR<ResumeExportUpdateManyMutationInput, ResumeExportUncheckedUpdateManyWithoutResumeInput>
  }

  export type TailoringProgressUpsertWithWhereUniqueWithoutResumeInput = {
    where: TailoringProgressWhereUniqueInput
    update: XOR<TailoringProgressUpdateWithoutResumeInput, TailoringProgressUncheckedUpdateWithoutResumeInput>
    create: XOR<TailoringProgressCreateWithoutResumeInput, TailoringProgressUncheckedCreateWithoutResumeInput>
  }

  export type TailoringProgressUpdateWithWhereUniqueWithoutResumeInput = {
    where: TailoringProgressWhereUniqueInput
    data: XOR<TailoringProgressUpdateWithoutResumeInput, TailoringProgressUncheckedUpdateWithoutResumeInput>
  }

  export type TailoringProgressUpdateManyWithWhereWithoutResumeInput = {
    where: TailoringProgressScalarWhereInput
    data: XOR<TailoringProgressUpdateManyMutationInput, TailoringProgressUncheckedUpdateManyWithoutResumeInput>
  }

  export type TailoringProgressScalarWhereInput = {
    AND?: TailoringProgressScalarWhereInput | TailoringProgressScalarWhereInput[]
    OR?: TailoringProgressScalarWhereInput[]
    NOT?: TailoringProgressScalarWhereInput | TailoringProgressScalarWhereInput[]
    id?: StringFilter<"TailoringProgress"> | string
    userId?: StringFilter<"TailoringProgress"> | string
    resumeId?: StringFilter<"TailoringProgress"> | string
    status?: StringFilter<"TailoringProgress"> | string
    progress?: IntFilter<"TailoringProgress"> | number
    currentAttempt?: IntNullableFilter<"TailoringProgress"> | number | null
    maxAttempts?: IntNullableFilter<"TailoringProgress"> | number | null
    createdAt?: DateTimeFilter<"TailoringProgress"> | Date | string
    updatedAt?: DateTimeFilter<"TailoringProgress"> | Date | string
  }

  export type TailoringAttemptUpsertWithWhereUniqueWithoutResumeInput = {
    where: TailoringAttemptWhereUniqueInput
    update: XOR<TailoringAttemptUpdateWithoutResumeInput, TailoringAttemptUncheckedUpdateWithoutResumeInput>
    create: XOR<TailoringAttemptCreateWithoutResumeInput, TailoringAttemptUncheckedCreateWithoutResumeInput>
  }

  export type TailoringAttemptUpdateWithWhereUniqueWithoutResumeInput = {
    where: TailoringAttemptWhereUniqueInput
    data: XOR<TailoringAttemptUpdateWithoutResumeInput, TailoringAttemptUncheckedUpdateWithoutResumeInput>
  }

  export type TailoringAttemptUpdateManyWithWhereWithoutResumeInput = {
    where: TailoringAttemptScalarWhereInput
    data: XOR<TailoringAttemptUpdateManyMutationInput, TailoringAttemptUncheckedUpdateManyWithoutResumeInput>
  }

  export type TailoringAttemptScalarWhereInput = {
    AND?: TailoringAttemptScalarWhereInput | TailoringAttemptScalarWhereInput[]
    OR?: TailoringAttemptScalarWhereInput[]
    NOT?: TailoringAttemptScalarWhereInput | TailoringAttemptScalarWhereInput[]
    id?: StringFilter<"TailoringAttempt"> | string
    userId?: StringFilter<"TailoringAttempt"> | string
    resumeId?: StringFilter<"TailoringAttempt"> | string
    attemptNumber?: IntFilter<"TailoringAttempt"> | number
    atsScore?: IntFilter<"TailoringAttempt"> | number
    jdScore?: IntFilter<"TailoringAttempt"> | number
    goldenPassed?: BoolFilter<"TailoringAttempt"> | boolean
    feedback?: StringFilter<"TailoringAttempt"> | string
    suggestions?: StringFilter<"TailoringAttempt"> | string
    atsFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    jdFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    createdAt?: DateTimeFilter<"TailoringAttempt"> | Date | string
    modifiedSectionsSent?: StringNullableFilter<"TailoringAttempt"> | string | null
    modifiedSectionsReceived?: StringNullableFilter<"TailoringAttempt"> | string | null
    promptTokens?: IntNullableFilter<"TailoringAttempt"> | number | null
    goldenRuleFeedback?: StringNullableFilter<"TailoringAttempt"> | string | null
    iteration?: IntNullableFilter<"TailoringAttempt"> | number | null
    modifiedSections?: StringNullableFilter<"TailoringAttempt"> | string | null
    score?: IntNullableFilter<"TailoringAttempt"> | number | null
  }

  export type ManualEditUpsertWithWhereUniqueWithoutResumeInput = {
    where: ManualEditWhereUniqueInput
    update: XOR<ManualEditUpdateWithoutResumeInput, ManualEditUncheckedUpdateWithoutResumeInput>
    create: XOR<ManualEditCreateWithoutResumeInput, ManualEditUncheckedCreateWithoutResumeInput>
  }

  export type ManualEditUpdateWithWhereUniqueWithoutResumeInput = {
    where: ManualEditWhereUniqueInput
    data: XOR<ManualEditUpdateWithoutResumeInput, ManualEditUncheckedUpdateWithoutResumeInput>
  }

  export type ManualEditUpdateManyWithWhereWithoutResumeInput = {
    where: ManualEditScalarWhereInput
    data: XOR<ManualEditUpdateManyMutationInput, ManualEditUncheckedUpdateManyWithoutResumeInput>
  }

  export type ManualEditScalarWhereInput = {
    AND?: ManualEditScalarWhereInput | ManualEditScalarWhereInput[]
    OR?: ManualEditScalarWhereInput[]
    NOT?: ManualEditScalarWhereInput | ManualEditScalarWhereInput[]
    id?: StringFilter<"ManualEdit"> | string
    userId?: StringFilter<"ManualEdit"> | string
    resumeId?: StringFilter<"ManualEdit"> | string
    editedText?: StringFilter<"ManualEdit"> | string
    createdAt?: DateTimeFilter<"ManualEdit"> | Date | string
  }

  export type ManualScoringUpsertWithWhereUniqueWithoutResumeInput = {
    where: ManualScoringWhereUniqueInput
    update: XOR<ManualScoringUpdateWithoutResumeInput, ManualScoringUncheckedUpdateWithoutResumeInput>
    create: XOR<ManualScoringCreateWithoutResumeInput, ManualScoringUncheckedCreateWithoutResumeInput>
  }

  export type ManualScoringUpdateWithWhereUniqueWithoutResumeInput = {
    where: ManualScoringWhereUniqueInput
    data: XOR<ManualScoringUpdateWithoutResumeInput, ManualScoringUncheckedUpdateWithoutResumeInput>
  }

  export type ManualScoringUpdateManyWithWhereWithoutResumeInput = {
    where: ManualScoringScalarWhereInput
    data: XOR<ManualScoringUpdateManyMutationInput, ManualScoringUncheckedUpdateManyWithoutResumeInput>
  }

  export type ManualScoringScalarWhereInput = {
    AND?: ManualScoringScalarWhereInput | ManualScoringScalarWhereInput[]
    OR?: ManualScoringScalarWhereInput[]
    NOT?: ManualScoringScalarWhereInput | ManualScoringScalarWhereInput[]
    id?: StringFilter<"ManualScoring"> | string
    userId?: StringFilter<"ManualScoring"> | string
    resumeId?: StringFilter<"ManualScoring"> | string
    atsScore?: IntFilter<"ManualScoring"> | number
    jdScore?: IntFilter<"ManualScoring"> | number
    atsFeedback?: StringNullableFilter<"ManualScoring"> | string | null
    jdFeedback?: StringNullableFilter<"ManualScoring"> | string | null
    createdAt?: DateTimeFilter<"ManualScoring"> | Date | string
  }

  export type ResumeFeedbackUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeFeedbackWhereUniqueInput
    update: XOR<ResumeFeedbackUpdateWithoutResumeInput, ResumeFeedbackUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeFeedbackCreateWithoutResumeInput, ResumeFeedbackUncheckedCreateWithoutResumeInput>
  }

  export type ResumeFeedbackUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeFeedbackWhereUniqueInput
    data: XOR<ResumeFeedbackUpdateWithoutResumeInput, ResumeFeedbackUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeFeedbackUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeFeedbackScalarWhereInput
    data: XOR<ResumeFeedbackUpdateManyMutationInput, ResumeFeedbackUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeFeedbackScalarWhereInput = {
    AND?: ResumeFeedbackScalarWhereInput | ResumeFeedbackScalarWhereInput[]
    OR?: ResumeFeedbackScalarWhereInput[]
    NOT?: ResumeFeedbackScalarWhereInput | ResumeFeedbackScalarWhereInput[]
    id?: StringFilter<"ResumeFeedback"> | string
    userId?: StringFilter<"ResumeFeedback"> | string
    resumeId?: StringFilter<"ResumeFeedback"> | string
    feedbackType?: StringFilter<"ResumeFeedback"> | string
    feedbackPoints?: StringNullableListFilter<"ResumeFeedback">
    sourceVersion?: IntNullableFilter<"ResumeFeedback"> | number | null
    createdAt?: DateTimeFilter<"ResumeFeedback"> | Date | string
  }

  export type ResumeSectionRationaleUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeSectionRationaleWhereUniqueInput
    update: XOR<ResumeSectionRationaleUpdateWithoutResumeInput, ResumeSectionRationaleUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeSectionRationaleCreateWithoutResumeInput, ResumeSectionRationaleUncheckedCreateWithoutResumeInput>
  }

  export type ResumeSectionRationaleUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeSectionRationaleWhereUniqueInput
    data: XOR<ResumeSectionRationaleUpdateWithoutResumeInput, ResumeSectionRationaleUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeSectionRationaleUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeSectionRationaleScalarWhereInput
    data: XOR<ResumeSectionRationaleUpdateManyMutationInput, ResumeSectionRationaleUncheckedUpdateManyWithoutResumeInput>
  }

  export type UserCreateWithoutAnalyticsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
  }

  export type ResumeCreateWithoutAnalyticsInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutAnalyticsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutAnalyticsInput, ResumeUncheckedCreateWithoutAnalyticsInput>
  }

  export type UserUpsertWithoutAnalyticsInput = {
    update: XOR<UserUpdateWithoutAnalyticsInput, UserUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalyticsInput, UserUncheckedUpdateWithoutAnalyticsInput>
  }

  export type UserUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutAnalyticsInput = {
    update: XOR<ResumeUpdateWithoutAnalyticsInput, ResumeUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<ResumeCreateWithoutAnalyticsInput, ResumeUncheckedCreateWithoutAnalyticsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutAnalyticsInput, ResumeUncheckedUpdateWithoutAnalyticsInput>
  }

  export type ResumeUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutScrubbedResumeInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutScrubbedResumeInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutScrubbedResumeInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutScrubbedResumeInput, ResumeUncheckedCreateWithoutScrubbedResumeInput>
  }

  export type ResumeUpsertWithoutScrubbedResumeInput = {
    update: XOR<ResumeUpdateWithoutScrubbedResumeInput, ResumeUncheckedUpdateWithoutScrubbedResumeInput>
    create: XOR<ResumeCreateWithoutScrubbedResumeInput, ResumeUncheckedCreateWithoutScrubbedResumeInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutScrubbedResumeInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutScrubbedResumeInput, ResumeUncheckedUpdateWithoutScrubbedResumeInput>
  }

  export type ResumeUpdateWithoutScrubbedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutScrubbedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutPromptArchivesInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutPromptArchivesInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutPromptArchivesInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutPromptArchivesInput, ResumeUncheckedCreateWithoutPromptArchivesInput>
  }

  export type ResumeUpsertWithoutPromptArchivesInput = {
    update: XOR<ResumeUpdateWithoutPromptArchivesInput, ResumeUncheckedUpdateWithoutPromptArchivesInput>
    create: XOR<ResumeCreateWithoutPromptArchivesInput, ResumeUncheckedCreateWithoutPromptArchivesInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutPromptArchivesInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutPromptArchivesInput, ResumeUncheckedUpdateWithoutPromptArchivesInput>
  }

  export type ResumeUpdateWithoutPromptArchivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutPromptArchivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type UserCreateWithoutInteractionsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInteractionsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInteractionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
  }

  export type ResumeCreateWithoutInteractionsInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutInteractionsInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutInteractionsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutInteractionsInput, ResumeUncheckedCreateWithoutInteractionsInput>
  }

  export type UserUpsertWithoutInteractionsInput = {
    update: XOR<UserUpdateWithoutInteractionsInput, UserUncheckedUpdateWithoutInteractionsInput>
    create: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInteractionsInput, UserUncheckedUpdateWithoutInteractionsInput>
  }

  export type UserUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutInteractionsInput = {
    update: XOR<ResumeUpdateWithoutInteractionsInput, ResumeUncheckedUpdateWithoutInteractionsInput>
    create: XOR<ResumeCreateWithoutInteractionsInput, ResumeUncheckedCreateWithoutInteractionsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutInteractionsInput, ResumeUncheckedUpdateWithoutInteractionsInput>
  }

  export type ResumeUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type UserCreateWithoutResumeTagInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumeTagInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumeTagInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumeTagInput, UserUncheckedCreateWithoutResumeTagInput>
  }

  export type ResumeCreateWithoutTagsInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutTagsInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutTagsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutTagsInput, ResumeUncheckedCreateWithoutTagsInput>
  }

  export type UserUpsertWithoutResumeTagInput = {
    update: XOR<UserUpdateWithoutResumeTagInput, UserUncheckedUpdateWithoutResumeTagInput>
    create: XOR<UserCreateWithoutResumeTagInput, UserUncheckedCreateWithoutResumeTagInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResumeTagInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResumeTagInput, UserUncheckedUpdateWithoutResumeTagInput>
  }

  export type UserUpdateWithoutResumeTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumeTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutTagsInput = {
    update: XOR<ResumeUpdateWithoutTagsInput, ResumeUncheckedUpdateWithoutTagsInput>
    create: XOR<ResumeCreateWithoutTagsInput, ResumeUncheckedCreateWithoutTagsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutTagsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutTagsInput, ResumeUncheckedUpdateWithoutTagsInput>
  }

  export type ResumeUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type UserCreateWithoutResumeMetadataInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumeMetadataInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumeMetadataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumeMetadataInput, UserUncheckedCreateWithoutResumeMetadataInput>
  }

  export type ResumeCreateWithoutMetadataInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutMetadataInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutMetadataInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutMetadataInput, ResumeUncheckedCreateWithoutMetadataInput>
  }

  export type UserUpsertWithoutResumeMetadataInput = {
    update: XOR<UserUpdateWithoutResumeMetadataInput, UserUncheckedUpdateWithoutResumeMetadataInput>
    create: XOR<UserCreateWithoutResumeMetadataInput, UserUncheckedCreateWithoutResumeMetadataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResumeMetadataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResumeMetadataInput, UserUncheckedUpdateWithoutResumeMetadataInput>
  }

  export type UserUpdateWithoutResumeMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumeMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutMetadataInput = {
    update: XOR<ResumeUpdateWithoutMetadataInput, ResumeUncheckedUpdateWithoutMetadataInput>
    create: XOR<ResumeCreateWithoutMetadataInput, ResumeUncheckedCreateWithoutMetadataInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutMetadataInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutMetadataInput, ResumeUncheckedUpdateWithoutMetadataInput>
  }

  export type ResumeUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutTailoringPromptsInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutTailoringPromptsInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutTailoringPromptsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutTailoringPromptsInput, ResumeUncheckedCreateWithoutTailoringPromptsInput>
  }

  export type ResumeUpsertWithoutTailoringPromptsInput = {
    update: XOR<ResumeUpdateWithoutTailoringPromptsInput, ResumeUncheckedUpdateWithoutTailoringPromptsInput>
    create: XOR<ResumeCreateWithoutTailoringPromptsInput, ResumeUncheckedCreateWithoutTailoringPromptsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutTailoringPromptsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutTailoringPromptsInput, ResumeUncheckedUpdateWithoutTailoringPromptsInput>
  }

  export type ResumeUpdateWithoutTailoringPromptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutTailoringPromptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutTailoringProgressInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutTailoringProgressInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutTailoringProgressInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutTailoringProgressInput, ResumeUncheckedCreateWithoutTailoringProgressInput>
  }

  export type ResumeUpsertWithoutTailoringProgressInput = {
    update: XOR<ResumeUpdateWithoutTailoringProgressInput, ResumeUncheckedUpdateWithoutTailoringProgressInput>
    create: XOR<ResumeCreateWithoutTailoringProgressInput, ResumeUncheckedCreateWithoutTailoringProgressInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutTailoringProgressInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutTailoringProgressInput, ResumeUncheckedUpdateWithoutTailoringProgressInput>
  }

  export type ResumeUpdateWithoutTailoringProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutTailoringProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutTailoringAttemptsInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutTailoringAttemptsInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutTailoringAttemptsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutTailoringAttemptsInput, ResumeUncheckedCreateWithoutTailoringAttemptsInput>
  }

  export type ResumeUpsertWithoutTailoringAttemptsInput = {
    update: XOR<ResumeUpdateWithoutTailoringAttemptsInput, ResumeUncheckedUpdateWithoutTailoringAttemptsInput>
    create: XOR<ResumeCreateWithoutTailoringAttemptsInput, ResumeUncheckedCreateWithoutTailoringAttemptsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutTailoringAttemptsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutTailoringAttemptsInput, ResumeUncheckedUpdateWithoutTailoringAttemptsInput>
  }

  export type ResumeUpdateWithoutTailoringAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutTailoringAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutResumeFeedbackInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutResumeFeedbackInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutResumeFeedbackInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutResumeFeedbackInput, ResumeUncheckedCreateWithoutResumeFeedbackInput>
  }

  export type ResumeUpsertWithoutResumeFeedbackInput = {
    update: XOR<ResumeUpdateWithoutResumeFeedbackInput, ResumeUncheckedUpdateWithoutResumeFeedbackInput>
    create: XOR<ResumeCreateWithoutResumeFeedbackInput, ResumeUncheckedCreateWithoutResumeFeedbackInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutResumeFeedbackInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutResumeFeedbackInput, ResumeUncheckedUpdateWithoutResumeFeedbackInput>
  }

  export type ResumeUpdateWithoutResumeFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutResumeFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutManualEditsInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutManualEditsInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutManualEditsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutManualEditsInput, ResumeUncheckedCreateWithoutManualEditsInput>
  }

  export type ResumeUpsertWithoutManualEditsInput = {
    update: XOR<ResumeUpdateWithoutManualEditsInput, ResumeUncheckedUpdateWithoutManualEditsInput>
    create: XOR<ResumeCreateWithoutManualEditsInput, ResumeUncheckedCreateWithoutManualEditsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutManualEditsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutManualEditsInput, ResumeUncheckedUpdateWithoutManualEditsInput>
  }

  export type ResumeUpdateWithoutManualEditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutManualEditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateWithoutManualScoringsInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutManualScoringsInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutManualScoringsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutManualScoringsInput, ResumeUncheckedCreateWithoutManualScoringsInput>
  }

  export type ResumeUpsertWithoutManualScoringsInput = {
    update: XOR<ResumeUpdateWithoutManualScoringsInput, ResumeUncheckedUpdateWithoutManualScoringsInput>
    create: XOR<ResumeCreateWithoutManualScoringsInput, ResumeUncheckedCreateWithoutManualScoringsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutManualScoringsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutManualScoringsInput, ResumeUncheckedUpdateWithoutManualScoringsInput>
  }

  export type ResumeUpdateWithoutManualScoringsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutManualScoringsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type UserCreateWithoutCoverLettersInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoverLettersInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoverLettersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoverLettersInput, UserUncheckedCreateWithoutCoverLettersInput>
  }

  export type ResumeCreateWithoutCoverLettersInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutCoverLettersInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutCoverLettersInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutCoverLettersInput, ResumeUncheckedCreateWithoutCoverLettersInput>
  }

  export type UserUpsertWithoutCoverLettersInput = {
    update: XOR<UserUpdateWithoutCoverLettersInput, UserUncheckedUpdateWithoutCoverLettersInput>
    create: XOR<UserCreateWithoutCoverLettersInput, UserUncheckedCreateWithoutCoverLettersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoverLettersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoverLettersInput, UserUncheckedUpdateWithoutCoverLettersInput>
  }

  export type UserUpdateWithoutCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutCoverLettersInput = {
    update: XOR<ResumeUpdateWithoutCoverLettersInput, ResumeUncheckedUpdateWithoutCoverLettersInput>
    create: XOR<ResumeCreateWithoutCoverLettersInput, ResumeUncheckedCreateWithoutCoverLettersInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutCoverLettersInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutCoverLettersInput, ResumeUncheckedUpdateWithoutCoverLettersInput>
  }

  export type ResumeUpdateWithoutCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type UserCreateWithoutLinkedInOptimizationsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLinkedInOptimizationsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLinkedInOptimizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLinkedInOptimizationsInput, UserUncheckedCreateWithoutLinkedInOptimizationsInput>
  }

  export type UserUpsertWithoutLinkedInOptimizationsInput = {
    update: XOR<UserUpdateWithoutLinkedInOptimizationsInput, UserUncheckedUpdateWithoutLinkedInOptimizationsInput>
    create: XOR<UserCreateWithoutLinkedInOptimizationsInput, UserUncheckedCreateWithoutLinkedInOptimizationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLinkedInOptimizationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLinkedInOptimizationsInput, UserUncheckedUpdateWithoutLinkedInOptimizationsInput>
  }

  export type UserUpdateWithoutLinkedInOptimizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLinkedInOptimizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInterviewSessionsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterviewSessionsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterviewSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterviewSessionsInput, UserUncheckedCreateWithoutInterviewSessionsInput>
  }

  export type UserUpsertWithoutInterviewSessionsInput = {
    update: XOR<UserUpdateWithoutInterviewSessionsInput, UserUncheckedUpdateWithoutInterviewSessionsInput>
    create: XOR<UserCreateWithoutInterviewSessionsInput, UserUncheckedCreateWithoutInterviewSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterviewSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterviewSessionsInput, UserUncheckedUpdateWithoutInterviewSessionsInput>
  }

  export type UserUpdateWithoutInterviewSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterviewSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutResumeExportsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumeExportsInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumeExportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumeExportsInput, UserUncheckedCreateWithoutResumeExportsInput>
  }

  export type ResumeCreateWithoutExportsInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutExportsInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutExportsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutExportsInput, ResumeUncheckedCreateWithoutExportsInput>
  }

  export type UserUpsertWithoutResumeExportsInput = {
    update: XOR<UserUpdateWithoutResumeExportsInput, UserUncheckedUpdateWithoutResumeExportsInput>
    create: XOR<UserCreateWithoutResumeExportsInput, UserUncheckedCreateWithoutResumeExportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResumeExportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResumeExportsInput, UserUncheckedUpdateWithoutResumeExportsInput>
  }

  export type UserUpdateWithoutResumeExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumeExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutExportsInput = {
    update: XOR<ResumeUpdateWithoutExportsInput, ResumeUncheckedUpdateWithoutExportsInput>
    create: XOR<ResumeCreateWithoutExportsInput, ResumeUncheckedCreateWithoutExportsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutExportsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutExportsInput, ResumeUncheckedUpdateWithoutExportsInput>
  }

  export type ResumeUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type UserCreateWithoutJdIntelligenceInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJdIntelligenceInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJdIntelligenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJdIntelligenceInput, UserUncheckedCreateWithoutJdIntelligenceInput>
  }

  export type UserUpsertWithoutJdIntelligenceInput = {
    update: XOR<UserUpdateWithoutJdIntelligenceInput, UserUncheckedUpdateWithoutJdIntelligenceInput>
    create: XOR<UserCreateWithoutJdIntelligenceInput, UserUncheckedCreateWithoutJdIntelligenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJdIntelligenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJdIntelligenceInput, UserUncheckedUpdateWithoutJdIntelligenceInput>
  }

  export type UserUpdateWithoutJdIntelligenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJdIntelligenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeCreateWithoutResumeSectionRationaleInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResumesInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionCreateNestedManyWithoutResumeInput
    tags?: ResumeTagCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterCreateNestedManyWithoutResumeInput
    exports?: ResumeExportCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutResumeSectionRationaleInput = {
    id?: string
    userId: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutResumeInput
    scrubbedResume?: ScrubbedResumeUncheckedCreateNestedOneWithoutResumeInput
    promptArchives?: PromptArchiveUncheckedCreateNestedManyWithoutResumeInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutResumeInput
    tags?: ResumeTagUncheckedCreateNestedManyWithoutResumeInput
    metadata?: ResumeMetadataUncheckedCreateNestedOneWithoutResumeInput
    tailoringPrompts?: TailoringPromptUncheckedCreateNestedManyWithoutResumeInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutResumeInput
    exports?: ResumeExportUncheckedCreateNestedManyWithoutResumeInput
    tailoringProgress?: TailoringProgressUncheckedCreateNestedManyWithoutResumeInput
    tailoringAttempts?: TailoringAttemptUncheckedCreateNestedManyWithoutResumeInput
    manualEdits?: ManualEditUncheckedCreateNestedManyWithoutResumeInput
    manualScorings?: ManualScoringUncheckedCreateNestedManyWithoutResumeInput
    resumeFeedback?: ResumeFeedbackUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutResumeSectionRationaleInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutResumeSectionRationaleInput, ResumeUncheckedCreateWithoutResumeSectionRationaleInput>
  }

  export type UserCreateWithoutResumeSectionRationaleInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumeSectionRationaleInput = {
    id?: string
    email: string
    fullName?: string | null
    isPremium?: boolean
    dailyResetDate?: Date | string | null
    dailyBasicTailoringsUsed?: number
    dailyPersonalizedTailoringsUsed?: number
    dailyAggressiveTailoringsUsed?: number
    dailyCoverLettersUsed?: number
    dailyLinkedinOptimizationsUsed?: number
    dailyInterviewSessionsUsed?: number
    analyticsTimeRange?: string | null
    analyticsViewMode?: string | null
    resumeTemplate?: string | null
    preferredTailoringMode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    analytics?: TailoringAnalyticsUncheckedCreateNestedManyWithoutUserInput
    interactions?: ResumeInteractionUncheckedCreateNestedManyWithoutUserInput
    coverLetters?: CoverLetterUncheckedCreateNestedManyWithoutUserInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    resumeExports?: ResumeExportUncheckedCreateNestedManyWithoutUserInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedCreateNestedManyWithoutUserInput
    ResumeTag?: ResumeTagUncheckedCreateNestedManyWithoutUserInput
    ResumeMetadata?: ResumeMetadataUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumeSectionRationaleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumeSectionRationaleInput, UserUncheckedCreateWithoutResumeSectionRationaleInput>
  }

  export type ResumeUpsertWithoutResumeSectionRationaleInput = {
    update: XOR<ResumeUpdateWithoutResumeSectionRationaleInput, ResumeUncheckedUpdateWithoutResumeSectionRationaleInput>
    create: XOR<ResumeCreateWithoutResumeSectionRationaleInput, ResumeUncheckedCreateWithoutResumeSectionRationaleInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutResumeSectionRationaleInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutResumeSectionRationaleInput, ResumeUncheckedUpdateWithoutResumeSectionRationaleInput>
  }

  export type ResumeUpdateWithoutResumeSectionRationaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumesNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutResumeSectionRationaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type UserUpsertWithoutResumeSectionRationaleInput = {
    update: XOR<UserUpdateWithoutResumeSectionRationaleInput, UserUncheckedUpdateWithoutResumeSectionRationaleInput>
    create: XOR<UserCreateWithoutResumeSectionRationaleInput, UserUncheckedCreateWithoutResumeSectionRationaleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResumeSectionRationaleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResumeSectionRationaleInput, UserUncheckedUpdateWithoutResumeSectionRationaleInput>
  }

  export type UserUpdateWithoutResumeSectionRationaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumeSectionRationaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    dailyResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dailyBasicTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyPersonalizedTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyAggressiveTailoringsUsed?: IntFieldUpdateOperationsInput | number
    dailyCoverLettersUsed?: IntFieldUpdateOperationsInput | number
    dailyLinkedinOptimizationsUsed?: IntFieldUpdateOperationsInput | number
    dailyInterviewSessionsUsed?: IntFieldUpdateOperationsInput | number
    analyticsTimeRange?: NullableStringFieldUpdateOperationsInput | string | null
    analyticsViewMode?: NullableStringFieldUpdateOperationsInput | string | null
    resumeTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTailoringMode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutUserNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutUserNestedInput
    linkedInOptimizations?: LinkedInOptimizationUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    resumeExports?: ResumeExportUncheckedUpdateManyWithoutUserNestedInput
    jdIntelligence?: JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserNestedInput
    ResumeTag?: ResumeTagUncheckedUpdateManyWithoutUserNestedInput
    ResumeMetadata?: ResumeMetadataUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeCreateManyUserInput = {
    id?: string
    resumeText: string
    jobDescription: string
    modifiedResume?: string | null
    tailoringMode: string
    version?: number
    label?: string | null
    atsScore?: number | null
    jdScore?: number | null
    goldenPassed?: boolean
    isRefinement?: boolean
    isSaved?: boolean
    originalResumeId?: string | null
    wasManuallyEdited?: boolean
    scoresStale?: boolean
    finalModifiedSections?: string | null
    atsWarnings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TailoringAnalyticsCreateManyUserInput = {
    id?: string
    resumeId: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
  }

  export type ResumeInteractionCreateManyUserInput = {
    id?: string
    resumeId: string
    action: string
    createdAt?: Date | string
  }

  export type CoverLetterCreateManyUserInput = {
    id?: string
    resumeId: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedInOptimizationCreateManyUserInput = {
    id?: string
    jobDescription: string
    originalAbout: string
    optimizedAbout: string
    tone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewSessionCreateManyUserInput = {
    id?: string
    jobDescription: string
    selectedTypes?: InterviewSessionCreateselectedTypesInput | string[]
    questions: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumeExportCreateManyUserInput = {
    id?: string
    resumeId: string
    templateId: string
    format: string
    createdAt?: Date | string
  }

  export type JobDescriptionIntelligenceCreateManyUserInput = {
    id?: string
    resumeId?: string | null
    role: string
    seniority: string
    keywords?: JobDescriptionIntelligenceCreatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceCreateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceCreatequalificationsInput | string[]
    categories: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ResumeTagCreateManyUserInput = {
    id?: string
    resumeId: string
    tag: string
  }

  export type ResumeMetadataCreateManyUserInput = {
    id?: string
    resumeId: string
    contentSnippet: string
    tailoringMode: string
    iterations: number
    passedRules: boolean
    atsScore: number
    jdScore: number
    createdAt?: Date | string
  }

  export type ResumeSectionRationaleCreateManyUserInput = {
    id?: string
    resumeId: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
  }

  export type ResumeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: TailoringAnalyticsUncheckedUpdateManyWithoutResumeNestedInput
    scrubbedResume?: ScrubbedResumeUncheckedUpdateOneWithoutResumeNestedInput
    promptArchives?: PromptArchiveUncheckedUpdateManyWithoutResumeNestedInput
    interactions?: ResumeInteractionUncheckedUpdateManyWithoutResumeNestedInput
    tags?: ResumeTagUncheckedUpdateManyWithoutResumeNestedInput
    metadata?: ResumeMetadataUncheckedUpdateOneWithoutResumeNestedInput
    tailoringPrompts?: TailoringPromptUncheckedUpdateManyWithoutResumeNestedInput
    coverLetters?: CoverLetterUncheckedUpdateManyWithoutResumeNestedInput
    exports?: ResumeExportUncheckedUpdateManyWithoutResumeNestedInput
    tailoringProgress?: TailoringProgressUncheckedUpdateManyWithoutResumeNestedInput
    tailoringAttempts?: TailoringAttemptUncheckedUpdateManyWithoutResumeNestedInput
    manualEdits?: ManualEditUncheckedUpdateManyWithoutResumeNestedInput
    manualScorings?: ManualScoringUncheckedUpdateManyWithoutResumeNestedInput
    resumeFeedback?: ResumeFeedbackUncheckedUpdateManyWithoutResumeNestedInput
    ResumeSectionRationale?: ResumeSectionRationaleUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeText?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    modifiedResume?: NullableStringFieldUpdateOperationsInput | string | null
    tailoringMode?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    isSaved?: BoolFieldUpdateOperationsInput | boolean
    originalResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    wasManuallyEdited?: BoolFieldUpdateOperationsInput | boolean
    scoresStale?: BoolFieldUpdateOperationsInput | boolean
    finalModifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    atsWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringAnalyticsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    resume?: ResumeUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type TailoringAnalyticsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TailoringAnalyticsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResumeInteractionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type ResumeInteractionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeInteractionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverLetterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutCoverLettersNestedInput
  }

  export type CoverLetterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverLetterUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedInOptimizationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    originalAbout?: StringFieldUpdateOperationsInput | string
    optimizedAbout?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedInOptimizationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    originalAbout?: StringFieldUpdateOperationsInput | string
    optimizedAbout?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedInOptimizationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    originalAbout?: StringFieldUpdateOperationsInput | string
    optimizedAbout?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    selectedTypes?: InterviewSessionUpdateselectedTypesInput | string[]
    questions?: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    selectedTypes?: InterviewSessionUpdateselectedTypesInput | string[]
    questions?: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    selectedTypes?: InterviewSessionUpdateselectedTypesInput | string[]
    questions?: JsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    needsReview?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeExportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutExportsNestedInput
  }

  export type ResumeExportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeExportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDescriptionIntelligenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seniority?: StringFieldUpdateOperationsInput | string
    keywords?: JobDescriptionIntelligenceUpdatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceUpdateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceUpdatequalificationsInput | string[]
    categories?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDescriptionIntelligenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seniority?: StringFieldUpdateOperationsInput | string
    keywords?: JobDescriptionIntelligenceUpdatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceUpdateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceUpdatequalificationsInput | string[]
    categories?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobDescriptionIntelligenceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    seniority?: StringFieldUpdateOperationsInput | string
    keywords?: JobDescriptionIntelligenceUpdatekeywordsInput | string[]
    responsibilities?: JobDescriptionIntelligenceUpdateresponsibilitiesInput | string[]
    qualifications?: JobDescriptionIntelligenceUpdatequalificationsInput | string[]
    categories?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeTagUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    resume?: ResumeUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ResumeTagUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeTagUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeMetadataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutMetadataNestedInput
  }

  export type ResumeMetadataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeMetadataUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentSnippet?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    passedRules?: BoolFieldUpdateOperationsInput | boolean
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeSectionRationaleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutResumeSectionRationaleNestedInput
  }

  export type ResumeSectionRationaleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeSectionRationaleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringAnalyticsCreateManyResumeInput = {
    id?: string
    userId: string
    tailoringMode: string
    iterations: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    isRefinement?: boolean
    createdAt?: Date | string
    modifiedSections?: string | null
  }

  export type PromptArchiveCreateManyResumeInput = {
    id?: string
    content: string
    response: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ResumeInteractionCreateManyResumeInput = {
    id?: string
    userId: string
    action: string
    createdAt?: Date | string
  }

  export type ResumeTagCreateManyResumeInput = {
    id?: string
    userId: string
    tag: string
  }

  export type TailoringPromptCreateManyResumeInput = {
    id?: string
    tailoringMode: string
    prompt: string
    attempt: number
    version: number
    createdAt?: Date | string
  }

  export type CoverLetterCreateManyResumeInput = {
    id?: string
    userId: string
    jobDescription: string
    content: string
    tone?: string
    atsScore?: number | null
    jdScore?: number | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResumeExportCreateManyResumeInput = {
    id?: string
    userId: string
    templateId: string
    format: string
    createdAt?: Date | string
  }

  export type TailoringProgressCreateManyResumeInput = {
    id?: string
    userId: string
    status: string
    progress: number
    currentAttempt?: number | null
    maxAttempts?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TailoringAttemptCreateManyResumeInput = {
    id?: string
    userId: string
    attemptNumber: number
    atsScore: number
    jdScore: number
    goldenPassed: boolean
    feedback: string
    suggestions: string
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
    modifiedSectionsSent?: string | null
    modifiedSectionsReceived?: string | null
    promptTokens?: number | null
    goldenRuleFeedback?: string | null
    iteration?: number | null
    modifiedSections?: string | null
    score?: number | null
  }

  export type ManualEditCreateManyResumeInput = {
    id?: string
    userId: string
    editedText: string
    createdAt?: Date | string
  }

  export type ManualScoringCreateManyResumeInput = {
    id?: string
    userId: string
    atsScore: number
    jdScore: number
    atsFeedback?: string | null
    jdFeedback?: string | null
    createdAt?: Date | string
  }

  export type ResumeFeedbackCreateManyResumeInput = {
    id?: string
    userId: string
    feedbackType: string
    feedbackPoints?: ResumeFeedbackCreatefeedbackPointsInput | string[]
    sourceVersion?: number | null
    createdAt?: Date | string
  }

  export type ResumeSectionRationaleCreateManyResumeInput = {
    id?: string
    userId: string
    sectionName: string
    rationale: string
    createdAt?: Date | string
  }

  export type TailoringAnalyticsUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type TailoringAnalyticsUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TailoringAnalyticsUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    iterations?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    isRefinement?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromptArchiveUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptArchiveUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptArchiveUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeInteractionUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type ResumeInteractionUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeInteractionUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeTagUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutResumeTagNestedInput
  }

  export type ResumeTagUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ResumeTagUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TailoringPromptUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    attempt?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringPromptUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    attempt?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringPromptUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailoringMode?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    attempt?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverLetterUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoverLettersNestedInput
  }

  export type CoverLetterUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoverLetterUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    jobDescription?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    jdScore?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeExportUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumeExportsNestedInput
  }

  export type ResumeExportUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeExportUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringProgressUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    currentAttempt?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringProgressUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    currentAttempt?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringProgressUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    currentAttempt?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailoringAttemptUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: StringFieldUpdateOperationsInput | string
    suggestions?: StringFieldUpdateOperationsInput | string
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSectionsSent?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedSectionsReceived?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    goldenRuleFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    iteration?: NullableIntFieldUpdateOperationsInput | number | null
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TailoringAttemptUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: StringFieldUpdateOperationsInput | string
    suggestions?: StringFieldUpdateOperationsInput | string
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSectionsSent?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedSectionsReceived?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    goldenRuleFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    iteration?: NullableIntFieldUpdateOperationsInput | number | null
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TailoringAttemptUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attemptNumber?: IntFieldUpdateOperationsInput | number
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    goldenPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: StringFieldUpdateOperationsInput | string
    suggestions?: StringFieldUpdateOperationsInput | string
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedSectionsSent?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedSectionsReceived?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: NullableIntFieldUpdateOperationsInput | number | null
    goldenRuleFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    iteration?: NullableIntFieldUpdateOperationsInput | number | null
    modifiedSections?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ManualEditUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    editedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualEditUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    editedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualEditUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    editedText?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualScoringUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualScoringUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualScoringUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    atsScore?: IntFieldUpdateOperationsInput | number
    jdScore?: IntFieldUpdateOperationsInput | number
    atsFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    jdFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeFeedbackUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: StringFieldUpdateOperationsInput | string
    feedbackPoints?: ResumeFeedbackUpdatefeedbackPointsInput | string[]
    sourceVersion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeFeedbackUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: StringFieldUpdateOperationsInput | string
    feedbackPoints?: ResumeFeedbackUpdatefeedbackPointsInput | string[]
    sourceVersion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeFeedbackUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: StringFieldUpdateOperationsInput | string
    feedbackPoints?: ResumeFeedbackUpdatefeedbackPointsInput | string[]
    sourceVersion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeSectionRationaleUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResumeSectionRationaleNestedInput
  }

  export type ResumeSectionRationaleUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeSectionRationaleUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sectionName?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}